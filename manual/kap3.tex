%% $Id$
%%
%% Kapitel 3 - Die Sprachen im Detail
%%

\chapter{Die Sprachen im Detail\label{DieSprachenImDetail}}

Dieses Kapitel beschreibt die in \TPML\ verf"ugbaren Sprachen im Detail. Dies beinhaltet sowohl die abstrakte Syntax der Sprachen als auch die
operationelle Semantik und das Typsystem, also die Regeln f"ur die big und small step Interpreter und den Type Checker. Dieses Kapitel ist
jedoch nicht geeignet als Ersatz f"ur den Besuch der Vorlesung oder "Ubung, ebensowenig sollte dieses Handbuch als vollst"andiges Skript
mi"sverstanden werden\footnote{Es mag wiederum allerdings n"utzlich als Grundlage f"ur die Pr"ufungsvorbereitung sein, da es eine vollst"andige
Auflistung des Regelwerks darstellt, welches jedoch nicht hunderprozentig mit dem Vorlesungsinhalt "ubereinstimmt.}.

Die Sprachen \LZERO\ bis \LFOUR\ sind strikt hierarchisch aufgebaut, das hei"st die Sprache $\mathcal{L}_{n+1}$ erweitert die Sprache
$\mathcal{L}_n$ ($0 \le n < 4$), beinhaltet also alle Merkmale der Sprache $\mathcal{L}_n$. Die Sprachen entsprechen im wesentlichen
den in der Vorlesung behandelten Sprachen. Kleinere Abweichungen sind jedoch m"oglich und stellenweise nicht vermeidbar. In der "Ubung
werden, falls notwendig, diese Abweichungen herausgestellt und erl"autert.



\section{Die Sprache \LZERO}

Die Sprache \LZERO\ stellt die einfachste denkbare Programmiersprache dar und entspricht dem \Define{reinen ungetypten $\lambda$-Kalk"ul}{reiner
ungetypter $\lambda$-Kalk"ul} \engl{pure untyped $\lambda$-calculus}. Die abstrakte Syntax enth"alt lediglich drei Produktionen.
\bgram
e \is \id
  \al \abstr{id}{e}
  \al e_1\,e_2
\egram
Ein g"ultiger Ausdruck ist also entweder ein Bezeichner, eine \notation{$\lambda$-Abstraktion} oder eine \notation{Applikation}.
Die Menge \notation{$\Val$}\ $\sleq \Exp$ der \Define{Werte}{Wert} \Engl{values}{value} \notation{$\name v$} wird durch
\bgram
v \is \id
  \al \abstr{id}{e}
\egram
definiert.


\subsection{Big step Semantik von \LZERO}

Ein \define{big step} ist eine Formel der Gestalt $e \eval v$ mit $r \in Val$. Ein big step hei"st g"ultig f"ur \LZERO, wenn
er sich mit den Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(VAL)}         & $v \eval v$ \\[3mm]
     \mbox{(BETA-V)}      & $\regel{e[v/\id] \eval v'}
                                   {(\abstr{id}{e})\,v \eval v'}$ \\[5mm]
     \mbox{(APP)}         & $\regel{e_1 \eval v_1 \quad e_2 \eval v_2 \quad v_1\,v_2 \eval v}
                                   {e_1\,e_2 \eval v}$
  \end{tabular}\\[7mm]
herleiten l"asst.


\subsection{Small step Semantik von \LZERO}

Ein \define{small step} ist eine Formel der Gestalt $e \to e'$. Ein small step hei"st g"ultig f"ur \LZERO, wenn er sich mit den
Regeln\\[5mm]
   \begin{tabular}{ll}
     \mbox{(BETA-V)}      & $(\abstr{id}{e})\,v \to e[v/\id]$ \\[5mm]
     \mbox{(APP-LEFT)}    & $\regel{e_1\to e'_1}
                               {e_1\,e_2 \to e'_1\,e_2}$ \\[3mm]
     \mbox{(APP-RIGHT)\ } & $\regel{e \to e'}
                                  {v\,e \to v\,e'}$
\end{tabular}\\[7mm]
herleiten l"asst.



\section{Die Sprache \LZEROCBN}

\index{Call By Name}
Die Sprache \LZEROCBN \ bietet den gleichen Funktionsumfang wie die Sprache \LZERO, benutzt aber statt der 
Call by Value eine Call by Name Semantik. Um dies zu realisieren werden verschiedene Regeln in der Big step 
und der Small step Semantik gel"oscht oder ge"andert. Nur diese ge"anderten bzw. gel"oschten Regeln werden hier
aufgef"uhrt.

\subsection{Big step Semantik von \LZEROCBN}

Ein \notation{big step} hei"st g"ultig f"ur \LZEROCBN, wenn er sich mit den big step Regeln von \LZERO\ und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $\regel{e_1[e_2/\id] \eval v}
                                   {(\abstr{id}{e_1})\,e_2 \eval v}$ \\[5mm]
     \mbox{(APP)}         & nicht vorhanden \\[3mm]
     \mbox{(APP-LEFT)}    & $\regel{e_1 \eval v_1 \quad v_1\,e_2 \eval v}
                                   {e_1\,e_2 \eval v}$ \\[3mm]
     \mbox{(APP-RIGHT)}   & $\regel{e_2 \eval v_2 \quad v_1\,v_2 \eval v}
                                   {v_1\,e_2 \eval v}$   \ 
                                   falls ${v_1}$ nicht von der Form $\abstr{id}{e}$
  \end{tabular}\\[7mm]
herleiten l"asst.


\subsection{Small step Semantik von \LZEROCBN}

Ein \notation{small step} hei"st g"ultig f"ur \LZEROCBN, wenn er sich mit den small step Regeln von \LZERO\ 
und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $(\abstr{id}{e_1})\,e_2 \to e_1[e_2/\id]$ \\[5mm]
     \mbox{(APP-RIGHT)\ } & $\regel{e \to e'}
                                   {v\,e \to v\,e'}$   \ 
                                   falls ${v}$ nicht von der Form $\abstr{id}{e_0}$
  \end{tabular}\\[7mm]
herleiten l"asst.



\section{Die Sprache \LONE}

Die Sprache \LONE\ erweitert \LZERO\ um Konstanten, bedingte Ausf"uhrung, den Bindungsmechanismus $\blet$, Ausnahmen
\engl{exceptions} und ein einfaches Typsystem, entspricht damit also dem einfach getypten $\lambda$-Kalk"ul. Vorgegeben seien:
\bitem
  \item eine Menge $\Exn$ von \Define{Ausnahmen}{Ausnahme} $\exn$ \[\Exn = \{ divide\_by\_zero \}\]
  \item f"ur jeden arithmetischen Operator $\op$ eine Funktion \[\op^\I: \Int \times \Int \to \Int \cup \Exn\]
  \item f"ur jeden Vergleichsoperator $\op$ eine Funktion \[\op^\I: \Int \times \Int \to \Bool\]
\eitem
Die Menge \notation{$\Type$} der \Define{Typen}{Typ} \Engl{types}{type} $\tau$ ist definiert durch:
\bgram
  \tau \is \bool \mid \inttype \mid \unit
       \al \arrowtype{\tau_1}{\tau_2}
       \al \mu t.\tau
       \al t
\egram
Die abstrakte Syntax, definiert durch die Menge $\Exp$ der g"ultigen Ausdr"ucke, wird erweitert durch neue Produktionen
\bgram
e \is c
  \al \abstr{\id: \tau}{e}
  \al \bli{\id}{e_1}{e_2}
  \al \bli{\id: \tau}{e_1}{e_2}
  \al \bifte{e_0}{e_1}{e_2}
  \al e_1\,\op\,e_2
  \al \andalso{e_1}{e_2}
  \al \orelse{e_1}{e_2}
  \al \coercion{e}{\tau}{\tau'}
\egram
wobei die Menge \notation{$\Const$} der \Define{Konstanten}{Konstante} \Engl{constants}{constant} $c$ durch
\bgram
c \is \nop                    & & \mbox{unit-Element}
  \al b \in \{\true,\false\}  & & \mbox{boolescher Wert}
  \al n \in \setZ             & & \mbox{ganze Zahl} 
  \al \op                     & & \mbox{Operator} 
\egram
und die Menge \notation{$\Op$} der \Define{Operatoren}{Operator} \Engl{operators}{operator} $\op$ durch
\bgram
\op \is + \ \mid\  - \ \mid\  * \ \mid\ / \ \mid \ \mbox{mod}     & & \mbox{arithmetische Operatoren}
    \al < \ \ \mid\ \ > \ \ \mid\ \ \leq \ \ \mid\ \  \geq \ |\ = & & \mbox{Vergleichsoperatoren}
    \al \Not                                                & & \mbox{Negation}
\egram
definiert ist. Die Menge \notation{$\Val$} der Werte $v$ wird um die Produktionen
\bgram
v \is c
  \al \op\,e_1
  \al \abstr{\id: \tau}{e}
\egram
erweitert. F"ur Zahlkonstanten existiert derzeit die Einschr"ankung, dass nur positive Ziffernfolgen vom Lexer
akzeptiert werden. Negative Zahlen k"onnen aber bei Bedarf durch Subtraktion konstruiert werden ($0 - n$ f"ur
$n \in \setN$).

Die Angabe eines Typs bei $\lambda$-Abstraktion und $\blet$ ist also optional, und f"ur den big und small step
Interpreter werden die Typangaben einfach ignoriert. Der Typechecker bestimmt bei $\abstr{\id}{e}$ den Typ f"ur
$\id$ mittels Typinferenz, w"ahrend bei $\blet$ die Angabe des Typs lediglich als zus"atzliche Sicherheit f"ur
den Programmierer dient.


\subsection{Big step Semantik von \LONE}

Ein \notation{big step} hei"st g"ultig f"ur \LONE, wenn er sich mit den big step Regeln von \LZERO, den Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(AND-FALSE)}   & $\regel{e_1 \eval \false}
                                   {\andalso{e_1}{e_2} \eval \false}$ \\[5mm]
     \mbox{(AND-TRUE)}    & $\regel{e_1 \eval \true \quad e_2 \eval v}
                                   {\andalso{e_1}{e_2} \eval v}$ \\[5mm]
     \mbox{(COND-TRUE)}   & $\regel{e_0 \eval \true \quad e_1 \eval v}
                                   {\bifte{e_0}{e_1}{e_2} \eval v}$ \\[5mm]
     \mbox{(COND-FALSE)}  & $\regel{e_0 \eval \false \quad e_2 \eval v}
                                   {\bifte{e_0}{e_1}{e_2} \eval v}$ \\[5mm]
     \mbox{(LET)}         & $\regel{e_1 \eval v_1 \quad e_2[v_1/\id] \eval v_2}
                                   {\bli{\id}{e_1}{e_2} \eval v_2}$ \\[5mm]
     \mbox{(NOT)}         & $\Not\,b \eval \neg b$ \\[3mm]
     \mbox{(OP)}          & $\op\,n_1\,n_2 \eval \op^{\I}(n_1,n_2)$ \\[3mm]
     \mbox{(OR-FALSE)}    & $\regel{e_1 \eval \false\quad e_2 \eval v}
                                   {\orelse{e_1}{e_2} \eval v}$ \\[5mm]
     \mbox{(OR-TRUE)}     & $\regel{e_1 \eval \true}
                                   {\orelse{e_1}{e_2} \eval \true}$\\[5mm]
     \mbox{(COERCE)}      & $\regel{e \eval v}
                                   {\coercion{e}{\tau}{\tau'} \eval v}$
  \end{tabular}\\[7mm]
und mit den zugeh"origen exception-Regeln herleiten l"asst. Diese exception-Regeln erh"alt man
aus den obigen Regeln indem man zu jeder Regel der Form\\[2mm]
   \begin{tabular}{ll}
     \mbox{(R)} & $\regel{e_1 \eval v_1 \quad \ldots \quad  e_n \eval v_n}
                         {e \eval v}$

   \end{tabular}\\[3mm]
(d.h.\ zu jeder Regel mit $n$ Pr\"amissen) f\"ur jedes $1 \le i \le n$ die Regel \\[3mm]
   \begin{tabular}{ll}
      \mbox{(R-EXN-$i$)} & $\regel{e_1 \eval v_1 \quad \ldots \quad e_{i-1} \eval v_{i-1} \quad e_i \eval \exn}
                                {e \eval \exn}$ \\[5mm]
   \end{tabular}\\[3mm]
hinzuf"ugt. Exception-Regeln m"ussen beim big step Interpreter nicht explizit ausgew"ahlt werden, sonde\mbox werden
automatisch eingesetzt, sobald eine Ausnahme weitergereicht werden mu"s.


\subsection{Small step Semantik von \LONE}

Ein \notation{small step} hei"st g"ultig f"ur \LONE, wenn er sich mit den small step Regeln von \LZERO, den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(AND-EVAL)}     & $\regel{e_1 \to e_1'}
                                 {\andalso{e_1}{e_2} \to \andalso{e_1'}{e_2}}$\\[5mm]
    \mbox{(AND-FALSE)}    & $\andalso{\false}{e_2} \to \false$\\[3mm]
    \mbox{(AND-TRUE)}     & $\andalso{\true}{e_2} \to e_2$\\[3mm]
    \mbox{(NOT)}          & $\Not\,b \to \neg b$\\[3mm]
    \mbox{(OP)}           & $\op\,n_1\,n_2 \to \op^{\I}(n_1,n_2)$ \\[3mm]
    \mbox{(COND-EVAL)\ }  & $\regel{e_0 \to e'_0}
                            {\bifte{e_0}{e_1}{e_2} \to \bifte{e'_0}{e_1}{e_2}}$ \\[5mm]
    \mbox{(COND-TRUE)\ }  & $\bifte{\true}{e_1}{e_2} \to e_1$ \\[3mm]
    \mbox{(COND-FALSE) }  & $\bifte{\false}{e_1}{e_2} \to e_2$ \\[3mm]
    \mbox{(LET-EVAL)\  }  & $\regel{e_1 \to e'_1}
                            {\bli{\id}{e_1}{e_2} \to \bli{\id}{e'_1}{e_2}}$ \\[5mm]
    \mbox{(LET-EXEC)}       & $\bli{\id}{v}{e} \to e[v/\id]$ \\[5mm]
    \mbox{(OR-EVAL)}      & $\regel{e_1 \to e_1'}
                                   {\orelse{e_1}{e_2} \to \orelse{e_1'}{e_2}}$\\[5mm]
    \mbox{(OR-FALSE)}     & $\orelse{\false}{e_2} \to e_2$\\[3mm]
    \mbox{(OR-TRUE)}      & $\orelse{\true}{e_2} \to \true$\\[3mm]
    \mbox{(COERCE)}       & $\coercion{e}{\tau}{\tau'} \to e$
  \end{tabular}\\[7mm]
und mit den zugeh"origen exception-Regeln herleiten l"asst. Diese exceptions-Regeln erh"alt man - "ahnlich wie
bei der big step Seminatik - aus den obigen Regeln indem man f"ur jede Regel der Form\\[2mm]
  \begin{tabular}{ll}
    \mbox{(R)} & $\regel{e_1 \to e'_1}{e_2 \to e'_2}$
  \end{tabular}\\[3mm]
(d.h.\ zu jeder Regel mit Pr\"amisse) die Regel \\[3mm]
  \begin{tabular}{ll}
    \mbox{(R-EXN)} & $\regel{e_1 \to \exn}{e_2 \to \exn}$
  \end{tabular}\\[3mm]
hinzunimmt. Wie beim big step Interpreter gilt auch f"ur den small step Interpreter, dass exception-Regeln nicht
explizit angegeben werden m"ussen.


\subsection{Typechecker Semantik von \LONE}

\LONE\ verf"ugt "uber ein einfaches \notation{Typsystem}, benutzt aber wie alle folgenden Sprachen schon den
\notation{Typinferenzalgorithmus}, was anfangs vielleicht zu schwer verst"andlichen Fehlermeldungen f"uhren kann.
In diesem Fall sollte es in der "Ubung angesprochen werden.

Ein \define{Typurteil} f"ur Ausdr"ucke ist von der Form $\Tj{\Gamma}{e}{\tau}$, wobei $\Gamma: \Id \pto \Type$ eine
partielle Funktion mit endlichem Definitionsbereich ist, die bestimmten Bezeichne\mbox einen Typ zuordnet. $\Gamma$ wird
als \define{Typumgebung} \engl{type environment} bezeichnet. Ein Typurteil heisst g"ultig f"ur \LONE, wenn es sich mit
den Regeln\\[3mm]
\begin{tabular}{ll}
  \mbox{(CONST)\  } & $\regel{\tj{c}{\tau}}
                           {\Tj{\Gamma}{c}{\tau}}$\\[5mm]
  \mbox{(ID)\     } & $\Tj{\Gamma}{\id}{\tau}$ \reason{falls $\id \in \dom \Gamma$ und $\Gamma(\id) = \tau$}\\[5mm]
  \mbox{(APP)\    } & $\regel{\Tj{\Gamma}{e_1}{\tau\to\tau'} 
                            \quad
                            \Tj{\Gamma}{e_2}{\tau}}
                           {\Tj{\Gamma}{e_1\,e_2}{\tau'}}$\\[5mm]
  \mbox{(COND)\   } & $\regel{\Tj{\Gamma}{e_0}{\bool}
                            \quad
                            \Tj{\Gamma}{e_1}{\tau}
                            \quad
                            \Tj{\Gamma}{e_2}{\tau}}
                          {\Tj{\Gamma}{\bifte{e_0}{e_1}{e_2}}{\tau}}$\\[5mm]
  \mbox{(LET)\ } & $\regel{\Tj{\Gamma}{e_1}{\tau_1}
                            \quad
                            \Tj{\Gamma[\tau_1/\id]}{e_2}{\tau_2}}
                           {\Tj{\Gamma}{\bli{\id}{e_1}{e_2}}{\tau_2}}$\\[5mm]
  \mbox{(ABSTR)\  } & $\regel{\Tj{\Gamma[\tau/\id]}{e}{\tau'}} 
                           {\Tj{\Gamma}{\abstr{\id:\tau}{e}}{\tau\to\tau'}}$ \\[5mm]
  \mbox{(AND)\ } & $\regel{\Tj{\Gamma}{e_1}{\bool} \quad \Tj{\Gamma}{e_2}{\bool}}
                          {\Tj{\Gamma}{\andalso{e_1}{e_2}}{\bool}}$ \\[5mm]
  \mbox{(OR)\  } & $\regel{\Tj{\Gamma}{e_1}{\bool} \quad \Tj{\Gamma}{e_2}{\bool}}
                          {\Tj{\Gamma}{\orelse{e_1}{e_2}}{\bool}}$\\[5mm]
  \mbox{(COERCE)\  } & $\regel{\Tj{\Gamma}{e}{\tau} \quad \subtype{\tau}{\tau'}}
                          {\Tj{\Gamma}{\coercion{e}{\tau}{\tau'}}{\tau'}}$
\end{tabular}\\[7mm]
herleiten l"asst. Die Regel (CONST) besagt hierbei, dass $c$ in der Typumgebung $\Gamma$ den Typ $\tau$ hat, wenn $c$
den Typ $\tau$ hat. Dies wird durch die Regeln\\[3mm]
\begin{tabular}{ll}
\mbox{(UNIT)\  } & $\tj{()}{\unit}$\\[2mm]
\mbox{(BOOL)\  } & $\tj{b}{\bool}$\\[2mm]
\mbox{(INT)\   } & $\tj{n}{\inttype}$\\[2mm]
\mbox{(NOT)\   } & $\tj{\Not}{\bool\to\bool}$\\[2mm]
\mbox{(AOP)\   } & $\tj{\op}{\inttype\to\inttype\to\inttype}$ 
                    \reason{ falls $\op$ arithmetischer Operator}\\[2mm]
\mbox{(ROP)\   } & $\tj{\op}{\inttype\to\inttype\to\bool}$ \reason{ falls $\op$ Vergleichsoperator}
\end{tabular}\\[7mm]
definiert. Beim Type Checker werden diese Regeln f"ur Konstanten nicht angegeben, sonde\mbox lediglich die (CONST) Regel.


\subsection{Minimal Typing Semantik von \LONE}

  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lom,
  wenn es sich mit den Typregeln  \\[5mm]
  \begin{tabular}{ll} 
    \mbox{(Id)\ }           & $\Tjm{\Gamma}{\id}{\tau} \quad \text{falls } \id\in\dom{\Gamma} \wedge \Gamma(\id) = \tau$ \\[1mm]
    \mbox{(Const)\ }        & $\RULE{\tj{c}{\tau}}
                              {\Tjm{\Gamma}{c}{\tau}}$ \\[4mm]
    \mbox{(App-Subsume)\ }  & $\RULE{\Tjm{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}
                               \quad
                               \Tj{\Gamma}{e_2}{\tau_2}
                               \quad
                               \subtype{\tau_2} {\tau_2'}}
                              {\Tjm{\Gamma}{\expApp{e_1}{e_2}}{\tau}}$ \\[4mm]
    \mbox{(Abstr)\ }        & $\RULE{\Tjm{\Gamma\SUB{\tau}{x}}{e}{\tau'}}
                              {\Tjm{\Gamma}{\expAbstr{x:\tau}{e}}{\typeArrow{\tau}{\tau'}}}$ \\[4mm]
    \mbox{(Let)\ }          & $\RULE{\Tjm{\Gamma}{e_1}{\tau_1}
                               \quad
                               \Tjm{\Gamma\SUB{\tau_1}{x}}{e_2}{\tau_2}}
                              {\Tjm{\Gamma}{\expLet{x}{e_1}{e_2}}{\tau_2}}$ \\[4mm]
   \mbox{(Cond-Subsume)\ } & $\RULE{\Tjm{\Gamma}{e_0}{\bool}
                               \quad
                               \Tjm{\Gamma}{e_1}{\tau_1}
                               \quad
                               \Tjm{\Gamma}{e_2}{\tau_2}}
                              {\Tjm{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau_1 \vee \tau_2}}$ \\[4mm]
  \mbox{(AND)\ } & $\regel{\Tjm{\Gamma}{e_1}{\bool} \quad \Tjm{\Gamma}{e_2}{\bool}}
                          {\Tjm{\Gamma}{\andalso{e_1}{e_2}}{\bool}}$ \\[4mm]
  \mbox{(OR)\  } & $\regel{\Tjm{\Gamma}{e_1}{\bool} \quad \Tjm{\Gamma}{e_2}{\bool}}
                          {\Tjm{\Gamma}{\orelse{e_1}{e_2}}{\bool}}$\\[4mm]
   \mbox{(COERCE)\ } & $\regel{\Tj{\Gamma}{e}{\tau} \quad \subtype{\tau}{\tau'}} 
                          {\Tj{\Gamma}{\coercion{e}{\tau}{\tau'}}{\tau'}}$
   
  \end{tabular} \\[7mm]
  und den Suptyping Regeln herleiten l\"a"st.



\subsection{Syntaktischer Zucker}

Die Sprache \LONE\ und alle folgenden Sprachen enthalten \Define{syntaktischen Zucker}{syntaktischer Zucker} um das Schreiben
von Programmen zu vereinfachen. Der syntaktische Zucker l"asst sich dann anschlie"send in Kernsyntax "ubersetzen oder direkt
verarbeiten. Hierbei wurden aus Gr"unden der "Ubersichtlichkeit nicht immer abgeleitete Regeln f"ur den syntaktischen Zucker eingef"uhrt,
sonde\mbox es wird implizit eine Konvertierung des betreffenden Teilausdrucks in \notation{Kernsyntax} vorgenommen. F"ur \LONE\ betrifft dies
Ausdr"ucke, die Operatoren in \notation{Infixschreibweise} enthalten, und die logischen Operatoren $\mathbin{\&\&}$ und $\mathbin{||}$. Es gilt:
\beqns
e_1\,\op\,e_2\quad \mbox{steht f"ur}\quad (\op\,e_1)\,e_2
\eeqns
Beim small step Interpreter w"urden also die Regeln (APP-LEFT) und (OP) angewendet. Beim Schreiben von Programmen ist dar"uber
hinaus zu beachten, dass Operatoren, sofe\mbox sie nicht in Infixausdr"ucken auftauchen, immer geklammert werden m"ussen. Die
Funktion, die $1$ zu ihrem Parameter addiert wird also als
\[(+)\,1\]
geschrieben. Dies entspricht der OCaml-Konvention und ist notwendig, da der Parser sonst bei bestimmten Ausdr"ucken nicht
entscheiden kann, ob es ein Infixausdruck ist, oder der Operator als Parameter in eine Funktion eingesetzt werden soll. Zum
Beispiel l"asst sich
\[x + y\]
interpretieren als Infixaddition von $x$ und $y$ oder als Anwendung der Funktion $x$ auf die Parameter $+$ und $y$. Intuitiv
w"urde ein Mensch ersteres vermuten, der Parser f"ur die konkrete Syntax kann dies jedoch nicht entscheiden.

Die logischen $\mathbin{\&\&}$- und 
$\mathbin{||}$-Verkn"upfungen sind syntaktischer Zucker f"ur die bedingte Ausf"uhrung
\beqns
  \andalso{e_1}{e_2} & \mbox{ steht f"ur } & \bifte{e_1}{e_2}{\false} \\
  \orelse{e_1}{e_2} & \mbox{ steht f"ur } & \bifte{e_1}{\true}{e_2}
\eeqns
und es existieren abgeleitete Interpreter- und Typregeln, da sonst der Umgang mit diesen Konstrukten zu aufwendig
w"are.

Interessant zu beobachten ist, dass auch der $\Not$-Operator als syntaktischer Zucker aufgefasst werden k"onnte.
\beqns
  \Not & \mbox{ steht f"ur } & \abstr{\id: \bool}{\bifte{\id}{\false}{\true}}
\eeqns
Dies sei aber nur am Rande erw"ahnt.



\section{Die Sprache \LONECBN}

\index{Call By Name}
Die Sprache \LONECBN \ bietet den gleichen Funktionsumfang wie die Sprache \LONE, benutzt aber statt der 
Call by Value eine Call by Name Semantik. Um dies zu realisieren werden verschiedene Regeln in der Big step 
und der Small step Semantik gel"oscht oder ge"andert. Nur diese ge"anderten bzw. gel"oschten Regeln werden hier
aufgef"uhrt.

\subsection{Big step Semantik von \LONECBN}

Ein \notation{big step} hei"st g"ultig f"ur \LONECBN, wenn er sich mit den big step Regeln von \LONE\ und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $\regel{e_1[e_2/\id] \eval v}
                                   {(\abstr{id}{e_1})\,e_2 \eval v}$ \\[5mm]
     \mbox{(APP)}         & nicht vorhanden \\[3mm]
     \mbox{(APP-LEFT)}    & $\regel{e_1 \eval v_1 \quad v_1\,e_2 \eval v}
                                   {e_1\,e_2 \eval v}$ \\[3mm]
     \mbox{(APP-RIGHT)}   & $\regel{e_2 \eval v_2 \quad v_1\,v_2 \eval v}
                                   {v_1\,e_2 \eval v}$   \ 
                                   falls ${v_1}$ nicht von der Form $\abstr{id}{e}$ \\[5mm]
     \mbox{(LET)}         & $\regel{e_2[e_1/\id] \eval v}
                                   {\bli{\id}{e_1}{e_2} \eval v}$
  \end{tabular}\\[7mm]
herleiten l"asst.


\subsection{Small step Semantik von \LONECBN}

Ein \notation{small step} hei"st g"ultig f"ur \LONECBN, wenn er sich mit den small step Regeln von \LONE\ 
und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $(\abstr{id}{e_1})\,e_2 \to e_1[e_2/\id]$ \\[5mm]
     \mbox{(APP-RIGHT)\ } & $\regel{e \to e'}
                                   {v\,e \to v\,e'}$   \ 
                                   falls ${v}$ nicht von der Form $\abstr{id}{e_0}$ \\[5mm]
     \mbox{(LET-EVAL)\  } & nicht vorhanden \\[3mm]
     \mbox{(LET-EXEC)}    & $\bli{\id}{e_1}{e_2} \to e_2[e_1/\id]$
  \end{tabular}\\[7mm]
herleiten l"asst.

\section{Die Sprache \LONESUB}
Die Sprache \LONESUB beschr"ankt sich auf das Typsystem von \LONE. 

\subsection{Sub Typing Semantik von \LONESUB}

Ein Beweisschritt f"ur Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
  \begin{tabular}{ll}
    \mbox{(S-Refl)\ }       & $\subtype{\tau}{\tau}$  \\[1mm]
    \mbox{(S-Arrow)\ }      & $\RULE{\subtype{\tau_1'} {\tau_1} \quad \subtype {\tau_2} {\tau_2'}}
                              {\subtype{\typeArrow{\tau_1}{\tau_2}} {\typeArrow{\tau_1'}{\tau_2'}}}$ \\[4mm]
  \end{tabular} \\[7mm]

herleiten l\"a"st.

\subsection{Rec Sub Typing Semantik von \LONESUB}

Ein Beweisschritt f"ur Rec Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
 \begin{tabular}{lll}
            \mbox{(S-Refl)\ } & $A \vdash \subtype{\tau}{\tau}$ \\[1mm]
            \mbox{(S-Assume)\ } & $\RULE{(\subtype{\tau_1} {\tau_2)} \in A}
                                   {A \vdash \subtype{\tau_1} {\tau_2}}$ \\[2mm]
            \mbox{(S-Arrow)\ } & $\RULE{A' \vdash \subtype{\tau_1} {\tau_1'}
                                   \quad
                                   A' \vdash \subtype{\tau_2} {\tau_2'}}
                                  {A \vdash \subtype{\typeArrow{\tau_1}{\tau_2}}
                                   {\typeArrow{\tau_1'}{\tau_2'}}}$ 
                                  & mit $A' = A \cup \{\subtype{\typeArrow{\tau_1}{\tau_2}}
                                   {\typeArrow{\tau_1'}{\tau_2'}}\}$ \\[2mm]
            \mbox{(S-Mu-Left)\ } & $\RULE{A' \vdash \subtype{\tau_1\SUB{\typeRec{t}{\tau_1}}{t}}
                                     {\tau_2}}
                                    {A \vdash \subtype{\typeRec{t}{\tau_1}} {\tau_2}}$
                                   & mit $A' = A \cup \{\subtype{\typeRec{t}{\tau_1}} {\tau_2\}}$ \\[2mm]
            \mbox{(S-Mu-Right)\ } & $\RULE{A' \vdash \subtype{\tau_1}
                                     {\tau_2\SUB{\typeRec{t}{\tau_2}}{t}}}
                                    {A \vdash \subtype{\tau_1} {\typeRec{t}{\tau_2}}}$
                                   & mit $A' = A \cup \{\subtype{\tau_1} {\typeRec{t}{\tau_2}\}}$ \\[2mm]
          \end{tabular}


herleiten l\"a"st.



\section{Die Sprache \LTWO}

\index{Rekursion}
Die Sprache \LTWO\ erweitert \LONE\ um rekursive Ausdr"ucke\footnote{Wohlgemerkt aber nicht um rekursive Typen. Das
Typsystem schr"ankt die Sprache also st"arker ein, als dies bei \LONE\ der Fall ist.} und syntaktischen Zucker, der
es erlaubt Funktionen einfacher zu definieren, "ahnlich zu OCaml.

Die Menge \notation{$\Exp$} der g"ultigen Ausdr"ucke wird um die Produktionen
\bgram
e \is \rec{\id: \tau}{e}
  \al \bli{\id (\id_1: \tau_1)\ldots(\id_n: \tau_n):\tau}{e_1}{e_2}
  \al \bli{\brec\,\id (\id_1: \tau_1)\ldots(\id_n: \tau_n):\tau}{e_1}{e_2}
\egram
erweitert, wobei s"amtliche Typangaben optional sind. Bei $\blet$ und $\blet\,\brec$ m"ussen die Bezeichner f"ur die
Parameter nur dann geklammert werden, wenn ein Typ f"ur diesen Parameter angegeben wird.


\subsection{Big step Semantik von \LTWO}

Ein \notation{big step} hei"st g"ultig f"ur \LTWO, wenn er sich mit den big step Regeln von \LONE\ und der Regel\\[3mm]
  \begin{tabular}{ll}
    \mbox{(UNFOLD)}      & $\regel{e[\rec{\id}{e}/\id] \eval v}
                                  {\rec{\id}{e} \eval v}$
  \end{tabular}\\[7mm]
sowie der dazugeh"origen exception-Regel herleiten l"asst.


\subsection{Small step Semantik von \LTWO}

Ein \notation{small step} hei"st g"ultig f"ur \LTWO, wenn er sich mit den small step Regeln von \LONE\ und der Regel\\[3mm]
  \begin{tabular}{ll}
    \mbox{(UNFOLD)}     & $\rec{\id}{e} \to e[\rec{\id}{e}/\id]$
  \end{tabular}\\[7mm]
herleiten l"asst.


\subsection{Typechecker Semantik von \LTWO}

Ein \notation{Typurteil} hei"st g"ultig f"ur \LTWO, wenn es sich mit den Typregeln von \LONE\ und der Regel\\[3mm]
\begin{tabular}{ll}
\mbox{(REC)\ } & $\regel{\Tj{\Gamma[\tau/\id]}{e}{\tau}} 
                         {\Tj{\Gamma}{\rec{\id:\tau}{e}}{\tau}}$
\end{tabular}\\[7mm]
herleiten l"asst. Fehlt die Angabe des Typs $\tau$ bei $\brec$ wird der Typ f"ur $e$ durch den Typinferenzalgorithmus
bestimmt.

\subsection{Minimal Typing Semantik von \LTWO}

  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lom,
  wenn es sich mit den Typregeln \\[5mm]
  \begin{tabular}{ll} 
    \mbox{(Rec-Subsume)\ }  & $\RULE{\Tjm{\Gamma\SUB{\tau}{x}}{e}{\tau'} \quad \tau' \le \tau}
                              {\Tjm{\Gamma}{\expRec{x:\tau}{e}}{\tau}}$ \\[4mm]
  \end{tabular} \\[7mm]
  und den Suptyping Regeln herleiten l\"a"st.


\subsection{Syntaktischer Zucker}

Die Sprache \LTWO\ enth"alt weitere Abk"urzungen zu den in \LONE\ definierten. Die folgenden Abk"urzungen stehen f"ur
die leichtere Definition von Funktionen zur Verf"ugung.
\beqns
  \bli{\id (\id_1: \tau_1)\ldots(\id_n: \tau_n):\tau}{e_1}{e_2}
\eeqns
steht f"ur
\beqns
  \bli{\id: \tau}{\abstr{\id_1: \tau_1}{\ldots\abstr{\id_n: \tau_n}{e_1}}}{e_2}
\eeqns
und
\beqns
  \bli{\brec\,\id (\id_1: \tau_1)\ldots(\id_n: \tau_n):\tau}{e_1}{e_2}
\eeqns
steht f"ur
\beqns
  \bli{\id: \tau}{\rec{\id: \tau}{\abstr{\id_1: \tau_1}{\ldots\abstr{\id_n: \tau_n}{e_1}}}}{e_2}\mbox{.}
\eeqns
F"ur diesen syntaktischen Zucker wurden keine abgeleiteten Regeln eingef"uhrt, stattdessen wird implizit
eine "Ubersetzung in \notation{Kernsyntax} vorgenommen.



\section{Die Sprache \LTWOCBN}

\index{Call By Name}
Die Sprache \LTWOCBN \ bietet den gleichen Funktionsumfang wie die Sprache \LTWO, benutzt aber statt der 
Call by Value eine Call by Name Semantik. Um dies zu realisieren werden verschiedene Regeln in der Big step 
und der Small step Semantik gel"oscht oder ge"andert. Nur diese ge"anderten bzw. gel"oschten Regeln werden hier
aufgef"uhrt.

\subsection{Big step Semantik von \LTWOCBN}

Ein \notation{big step} hei"st g"ultig f"ur \LTWOCBN, wenn er sich mit den big step Regeln von \LTWO\ und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $\regel{e_1[e_2/\id] \eval v}
                                   {(\abstr{id}{e_1})\,e_2 \eval v}$ \\[5mm]
     \mbox{(APP)}         & nicht vorhanden \\[3mm]
     \mbox{(APP-LEFT)}    & $\regel{e_1 \eval v_1 \quad v_1\,e_2 \eval v}
                                   {e_1\,e_2 \eval v}$ \\[3mm]
     \mbox{(APP-RIGHT)}   & $\regel{e_2 \eval v_2 \quad v_1\,v_2 \eval v}
                                   {v_1\,e_2 \eval v}$   \ 
                                   falls ${v_1}$ nicht von der Form $\abstr{id}{e}$ \\[5mm]
     \mbox{(LET)}         & $\regel{e_2[e_1/\id] \eval v}
                                   {\bli{\id}{e_1}{e_2} \eval v}$
  \end{tabular}\\[7mm]
herleiten l"asst.


\subsection{Small step Semantik von \LTWOCBN}

Ein \notation{small step} hei"st g"ultig f"ur \LTWOCBN, wenn er sich mit den small step Regeln von \LTWO\ 
und den ge"anderten bzw. gel"oschten Regeln\\[5mm]
  \begin{tabular}{ll}
     \mbox{(BETA-V)}      & nicht vorhanden \\[3mm]
     \mbox{(BETA)}        & $(\abstr{id}{e_1})\,e_2 \to e_1[e_2/\id]$ \\[5mm]
     \mbox{(APP-RIGHT)\ } & $\regel{e \to e'}
                                   {v\,e \to v\,e'}$   \ 
                                   falls ${v}$ nicht von der Form $\abstr{id}{e_0}$ \\[5mm]
     \mbox{(LET-EVAL)\  } & nicht vorhanden \\[3mm]
     \mbox{(LET-EXEC)}    & $\bli{\id}{e_1}{e_2} \to e_2[e_1/\id]$
  \end{tabular}\\[7mm]
herleiten l"asst.

\section{Die Sprache \LTWOSUB}
Die Sprache \LTWOSUB ist erweitert die Sprache \LONE um das Typsystem der Sprache \LTWO. 

\section{Die Sprache \LTWOO}
\index{Objekte}
Die Sprache \LTWOO \ erweitert die Sprache \LTWO\ um Objekte. Die Menge \notation{$\Exp$} der
g"ultigen Ausdr"ucke wird hierf"ur um die Produktionen
\bgram
e \is (\send{e}{m})                                                 & & \mbox{Methodenaufruf}
  \al \object {self: \tau}{r}                                       & & \mbox{Objekt}
  \al \duplication{a_1 = e_1;\ \ldots\ ;a_n = e_n}                  & & \mbox{Duplikation}
\egram
erweitert.
Die Menge \notation{$\Row$} aller \name{Reihen} r von \LTWOO\ ist definiert durch die kontextfreie Grammatik:
\bgram
r \is \eps                                                          & & \mbox{leere Reihe}
  \al \val {a}{e}\ r_1                                              & & \mbox{Attribut}
  \al \method {m: \tau}{e}\ r_1                                     & & \mbox{Methode}
\egram
Die Menge \notation{$\ValR$}\ $\sleq \Row$ aller \name{Reihenwerte} von \LTWOO\ ist definiert durch die kontextfreie Grammatik:
\bgram
\omega \is \eps                                                     & & \mbox{leere Reihe}
  \al \val {a}{v}\ \omega_1                                         & & \mbox{Attribut}
  \al \method {m: \tau}{e}\ \omega_1                                & & \mbox{Methode}
\egram
Die Menge \notation{$\Val$} der Werte $v$ wird um die Produktionen
\bgram
v \is \object {self: \tau}{\omega}                                  & & \mbox{Objektwert}
\egram
erweitert, wobei s"amtliche Typangaben wieder optional sind.

Die Menge der monomorphen Typen \notation{$\Type$} wird erweitert durch eine Produktion f"ur Objekte
\bgram
\tau \is <\phi>
\egram

und die Menge \notation{$\TypeR$} aller $\name{Reihentypen}$ $\phi$ von \LTWOO\ ist durch
\bgram
\phi \is \emptyset
  \al m : \tau;\ \phi_1
\egram
definiert, wobei die Methodennamen in einem Reihentyp $\phi$ paarweise verschieden sein m"ussen.


\subsection{Big step Semantik von \LTWOO}

Ein \notation{big step} hei"st g"ultig f"ur \LTWOO, wenn er sich mit den big step Regeln von \LTWO\ und den Regeln\\[3mm]
  \begin{tabular}{ll}
    \mbox{(OBJECT)}      & $\regel{r \eval \omega}
                                  {\object{self}{r} \eval \object{self}{\omega}}$ \\[5mm]
    \mbox{(SEND)}        & $\regel{e \eval \object{self}{\omega} \quad 
                                     \send{\omega [\object{self}{\omega}/self]}{m} \eval v}
                                  {\send{e}{m} \eval v}$ \\[5mm]
    \mbox{(SEND-ATTR)}   & $\regel{\send{\omega[v/a]}{m} \eval v'}
                                  {\send{(\val{a}{v}\omega)}{m} \eval v'}$ \\[5mm]
    \mbox{(SEND-SKIP)}   & $\regel{m \neq m' \vee m \in dom_m(\omega) \quad
                                   \send{\omega}{m} \eval v}
                                  {\send{(\method{m'}{e}\omega)}{m} \eval v}$ \\[5mm]
    \mbox{(SEND-EXEC)}   & $\regel{m = m' \wedge m \notin dom_m(\omega) \quad e \eval v}
                                  {\send{(\method{m'}{e}\omega)}{m} \eval v}$ \\[5mm]
    \mbox{(OMEGA)}       & $\omega \eval \omega$ \\[3mm]
    \mbox{(ATTR)}        & $\regel{e \eval v \quad r \eval \omega}
                                  {\val{a}{e}r \eval \val{a}{v}\omega}$ \\[5mm]
    \mbox{(METHOD)}      & $\regel{r \eval \omega}
                                  {\method{m}{e}r \eval \method{m}{e}\omega}$
  \end{tabular}\\[7mm]
sowie den dazugeh"origen exception-Regeln herleiten l"asst.


\subsection{Small step Semantik von \LTWOO}

Ein \notation{small step} hei"st g"ultig f"ur \LTWOO, wenn er sich mit den small step Regeln von \LTWO\ und den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(OBJECT-EVAL)}    & $\regel{r \to r'}
                                     {\object{self}{r} \to \object{self}{r'}}$ \\[5mm]
    \mbox{(SEND-EVAL)}      & $\regel{e \to e'}
                                     {\send{e}{m} \to \send{e'}{m}}$ \\[5mm]
    \mbox{(SEND-UNFOLD)}    & $\send{\object{self}{\omega}}{m} \to 
                               \send{\omega [\object{self}{\omega}/self]}{m}$ \\[3mm]
    \mbox{(SEND-ATTR)}      & $\send{(\val{a}{v}\omega)}{m} \to \send{\omega [v/a]}{m}$ \\[3mm]
    \mbox{(SEND-SKIP)}      & $\send{(\method{m'}{e}\omega)}{m} \to \send{\omega}{m}$ \ 
                              $falls\ m \neq m' \vee m \in dom_m(\omega)$ \\[3mm]
    \mbox{(SEND-EXEC)}      & $\send{(\method{m'}{e}\omega)}{m} \to e$ \ 
                              $falls\ m = m' \wedge m \notin dom_m(\omega)$ \\[3mm]
    \mbox{(ATTR-EVAL)}      & $\regel{e \to e'}
                                     {\val{a}{e}r \to \val{a}{e'}r}$ \\[5mm]
    \mbox{(ATTR-RIGHT)}     & $\regel{r \to r'}
                                     {\val{a}{v}r \to \val{a}{v}r'}$ \\[5mm]
    \mbox{(METHOD-RIGHT)}   & $\regel{r \to r'}
                                     {\method{m}{e}r \to \method{m}{e}r'}$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln herleiten l"asst.


\subsection{Typechecker Semantik von \LTWOO}

Ein \notation{Typurteil} hei"st g"ultig f"ur \LTWOO, wenn es sich mit den Typregeln von \LTWO\ und den Regeln\\[3mm]
\begin{tabular}{ll}
  \mbox{(SEND)\   } & $\regel{\Tj{\Gamma}{e}{<m:\tau;\phi>}}
                           {\Tj{\Gamma}{\send{e}{m}}{\tau}}$\\[5mm]
  \mbox{(OBJECT)\ } & $\regel{\Tj{\Gamma^*[\tau/self]}{r}{\phi}
                             \quad \tau =\ \objecttype{\phi}}
                             {\Tj{\Gamma}{\object{self:\tau}{r}}{\tau}}$\\[5mm]
  \mbox{(DUPL)\   } & $\regel{\Tj{\Gamma}{self}{\tau}
                              \quad \forall i = 1 \ldots n :
                              \Tj{\Gamma}{a_i}{\tau_i} \wedge
                              \Tj{\Gamma}{e_i}{\tau_i}}
                             {\Tj{\Gamma}{\{< a_1 = e_1;\ldots;a_n = e_n >\}}{\tau}}$\\[5mm]
  \mbox{(EMPTY)\  } & $\Tj{\Gamma}{\epsilon}{\emptyset}$\\[5mm]
  \mbox{(ATTR)\   } & $\regel{\Tj{\Gamma^*}{e}{\tau}
                              \quad \Tj{\Gamma[\tau/a]}{r_1}{\phi}}
                             {\Tj{\Gamma}{\val{a}{e}r_1}{\phi}}$ \\[5mm]
  \mbox{(METHOD)\ } & $\regel{\Tj{\Gamma}{e}{\tau}
                              \quad \Tj{\Gamma}{r_1}{\phi}}
                             {\Tj{\Gamma}{\method{m}{e}r_1}{m:\tau;\phi}}$
\end{tabular}\\[7mm]
herleiten l"asst. $\Gamma^*$ ist die Typumgebung mit der Eigenschaft, dass nur Identifier enthalten sind,
die nicht zu einem Objekt oder Attribut geh"oren.

\subsection{Minimal Typing Semantik von \LTWOO}

  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lom,
  wenn es sich mit den  Typregeln \\[5mm]

     \begin{tabular}{ll}
    \mbox{(Send)\ }         & $\RULE{\Tjm{\Gamma}{e}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}}
                              {\Tjm{\Gamma}{\expSend{e}{m}}{\tau}}$ \\[4mm]
    \mbox{(Object)\ }       & $\RULE{\Tjm{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}
                               \quad
                               \tau = \typeObject{\phi}}
                              {\Tjm{\Gamma}{\expObject{\self:\tau}{r}}{\tau}}$ \\[4mm]
    \mbox{(Dupl-Subsume)\ } & $\RULE{\Tjm{\Gamma}{\self}{\tau}
                               \quad
                               \forall i=1 \ldots n:\Tjm{\Gamma}{a_i}{\tau_i}
                                             \wedge \Tjm{\Gamma}{e_i}{\tau_i'}
                                             \wedge \tau_i' \le \tau_i}
                              {\Tjm{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}}$\\[4mm]
    \mbox{(Empty)\ }          & $\Tjm{\Gamma}{\rowEpsilon}{\rtypeEmpty}$ \\[2mm]
    \mbox{(Attr)\ }           & $\RULE{\Tjm{\Gamma^\star}{e}{\tau}
                                 \quad
                                 \Tjm{\Gamma\SUB{\tau}{a}}{r_1}{\phi}}
                                {\Tjm{\Gamma}{\rowVal{a}{e}{r_1}}{\phi}}$ \\[4mm]
    \mbox{(Method-Subsume)\ } & $\RULE{\Tjm{\Gamma}{\self}{\typeObject{\rtypeMethod{m}{\tau}{\phi'}}}
                                 \quad
                                 \Tjm{\Gamma}{e}{\tau'}
                                 \quad
                                 \Tjm{\Gamma}{r_1}{\phi}
                                 \quad
                                 \tau' \le \tau}
                                {\Tjm{\Gamma}{\rowMethod{m}{e}{r_1}}
                                             {(\rtypeMethod{m}{\tau}{\rtypeEmpty}) \oplus \phi}}$
  \end{tabular} \\[7mm]
  und den Suptyping Regeln herleiten l\"a"st.


\subsection{Syntaktischer Zucker}

Die Sprache \LTWOO\ enth"alt weitere Abk"urzungen zu den in \LTWO\ definierten. Die folgende Abk"urzung steht f"ur die leichtere Definition von Funktionen zur Verf"ugung.
\beqns
  \method{m (\id_1: \tau_1)\ldots(\id_n: \tau_n):\tau}{e}
\eeqns
steht f"ur
\beqns
  \method{m: \tau}{\abstr{\id_1: \tau_1}{\ldots\abstr{\id_n: \tau_n}{e}}}
\eeqns
F"ur diesen syntaktischen Zucker wurden keine abgeleiteten Regeln eingef"uhrt, stattdessen wird implizit
eine "Ubersetzung in \notation{Kernsyntax} vorgenommen.

\section{Die Sprache \LTWOOSUB}
Die Sprache \LTWOOSUB erweitert die Sprache \LTWOSUB um das Typsystem von \LTWOO. 

\subsection{Sub Typing Semantik von \LTWOOSUB}

Ein Beweisschritt f"ur Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
  \begin{tabular}{ll}
    \mbox{(S-Trans)\ }      & $\RULE{\subtype{\tau_1} {\tau_2} \quad \subtype{\tau_2} {\tau_3}}
                              {\subtype{\tau_1} {\tau_3}}$ \\[4mm]
    \mbox{(S-Obj-Width)\ }  & $\subtype{\typeObject{m_1:\tau_1;\ldots;m_{n+k}:\tau_{n+k}}}
                          {\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}}$ \\[2mm]
    \mbox{(S-Obj-Depth)\ }  & $\RULE{\subtype{\tau_i} {\tau_i'} \text{ f\"ur } i=1,\ldots,n}
                              {\subtype{\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}}
                               \subtype{\typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}}}$ \\[5mm]
    \mbox{(S-Object)\ }    & $\RULE{\subtype{\tau_i} {_m \tau_j'} \text{ f\"ur alle } i,j \text{ mit } m_i = m_j'}
                              {\subtype{\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}}
                               {_m \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}}}$ \\[4mm]
                      & $\text{falls } \{m_1',\ldots,m_l'\} \subseteq \{m_1,\ldots,m_k\}$
  \end{tabular} \\[7mm]

herleiten l\"a"st.

\subsection{Rec Sub Typing Semantik von \LTWOOSUB} 

Ein Beweisschritt f"ur Rec Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
 \begin{tabular}{lll}
    \mbox{(S-Trans)\ }      & $\RULE{\subtype{A \vdash \tau_1} {\tau_2} \quad \subtype{A \vdash \tau_2} {\tau_3}}
                              {A \vdash \subtype{\tau_1} {\tau_3}}$ \\[4mm]
    \mbox{(S-Obj-Width)\ }  & $A \vdash \subtype{\typeObject{m_1:\tau_1;\ldots;m_{n+k}:\tau_{n+k}}}
                          {\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}}$ \\[2mm]
    \mbox{(S-Obj-Depth)\ }  & $\RULE{A' \vdash \subtype{\tau_i} {\tau_i'} \text{ f\"ur } i=1,\ldots,n}
                              {A \vdash \subtype{\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}}
                               {\typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}}}$ \\[5mm]
				& mit $A' = A \cup \{\subtype{\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}}
                               {\typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}}\}$\\[5mm]
    \mbox{(S-Object)\ }    & $\RULE{A' \vdash \subtype{\tau_i} {_m \tau_j'} \text{ f\"ur alle } i,j \text{ mit } m_i = m_j'}
                              {\subtype{\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}}
                               {_m \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}}}$ \\[4mm]
				& mit $A' = A \cup \{\subtype{\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}}
                               {_m \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}}\}$	\\[2mm]
                      & $\text{falls } \{m_1',\ldots,m_l'\} \subseteq \{m_1,\ldots,m_k\}$
          \end{tabular}


herleiten l\"a"st.

\section{Die Sprache \LTWOC}
\index{Klassen}
\index{Vererbung}
Die Sprache \LTWOC\ erweitert die Sprache \LTWOO\ um Klassen bzw. Vererbung.
Die Menge \notation{\Exp} der g"ultigen Ausdr"ucke wird hierf"ur um die Produktionen
\bgram
e \is \class{self: \tau}{b}                                         & & \mbox{Klassen}
  \al \new{e}				                            & & \mbox{New}
\egram
erweitert.

Die Menge \notation{\Body} aller \name{Klassenr"umpfe} b von \LTWOC\ ist definiert durch die
kontextfreie Grammatik:
\bgram
b \is \inherit{a_1,\ \ldots\ ,a_k}{e}{b}                            & & \mbox{Inherit}
  \al r                                                             & & \mbox{Reihe}
\egram

Die Menge \notation{\Val} der Werte $v$ wird um die Produktionen
\bgram
v \is \class{self: \tau}{r}                                         & & \mbox{Klassenwert}
\egram
erweitert, wobei s"amtliche Typangaben wieder optional sind.

Die Menge der monomorphen Typen \notation{\Type} wird erweitert durch eine Produktion f"ur Klassen
\bgram
\tau \is \classtype{\tau}{\phi}
\egram

und die Menge \notation{$\TypeR$} aller $\name{Reihentypen}$ $\phi$ von \LTWOC\ wird erweitert durch
\bgram
\phi \is a : \tau;\ \phi_1
\egram
, wobei die Methodennamen und Attributnamen in einem Reihentyp $\phi$ paarweise
verschieden sein m"ussen.


\subsection{Big step Semantik von \LTWOC}

Ein \notation{big step} hei"st g"ultig f"ur \LTWOC, wenn er sich mit den big step Regeln von \LTWOO\ und den Regeln\\[3mm]
  \begin{tabular}{ll}
    \mbox{(CLASS)}       & $\regel{b \eval r}
                                  {\class{self}{b} \eval \class{self}{r}}$ \\[5mm]
    \mbox{(NEW)}         & $\regel{e \eval \class{self}{r}}
                                  {\new{e} \eval \object{self}{r}}$ \\[5mm]
    \mbox{(INHERIT)}     & $\regel{b \eval r_2 \quad  e \eval \class{self}{r_1} \quad \doma{r_1} = A}
                                  {\inherit{A}{e}{b} \eval r_1 \oplus r_2}$
  \end{tabular}\\[7mm]
sowie den dazugeh"origen exception-Regeln herleiten l"asst.

Bei dem Symbol $\oplus$ handelt es sich um die Vereinigung der beiden Reihen $r_1$ und $r_2$.
Das Ergebniss ist eine Reihe, in der erst die Kinder der Reihe $r_1$ vorkommen und danach
die Kinder der Reihe $r_2$.

Die Bedingung $\doma{r_1} = A$ bedeutet, dass alle angegebenen
Attributnamen in dem Inherit Teil mit den Attributen in der Reihe $r_1$ "ubereinstimmen m"ussen.
Ist dies nicht der Fall, bleibt der Small Step Interpreter stecken.

\subsection{Small step Semantik von \LTWOC}

Ein \notation{small step} hei"st g"ultig f"ur \LTWOC, wenn er sich mit den small step Regeln von \LTWOO\ und den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(CLASS-EVAL)}     & $\regel{b \to b'}
                                     {\class{self}{b} \to \class{self}{b'}}$ \\[5mm]
    \mbox{(NEW-EVAL)}       & $\regel{e \to e'}
                                     {\new{e} \to \new{e'}}$ \\[5mm]
    \mbox{(NEW-EXEC)}       & $\new{(\class{self}{r})} \to \object{self}{r}$ \\[3mm]
    \mbox{(INHERIT-RIGHT)}  & $\regel{b \to b'}
                                     {\inherit{A}{e}{b} \to \inherit{A}{e}{b'}}$ \\[5mm]
    \mbox{(INHERIT-LEFT)}   & $\regel{e \to e'}
                                     {\inherit{A}{e}{r} \to \inherit{A}{e'}{r}}$ \\[5mm]
    \mbox{(INHERIT-EXEC)}   & $\inherit{A}{\class{self}{r_1}}{r_2} \to r_1 \oplus r_2$ \\
                            & $\text{falls } \doma{r_1} = A$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln herleiten l"asst.

Bei dem Symbol $\oplus$ handelt es sich um die Vereinigung der beiden Reihen $r_1$ und $r_2$.
Das Ergebniss ist eine Reihe, in der erst die Kinder der Reihe $r_1$ vorkommen und danach
die Kinder der Reihe $r_2$.

Die Bedingung $\doma{r_1} = A$ bedeutet, dass alle angegebenen
Attributnamen in dem Inherit Teil mit den Attributen in der Reihe $r_1$ "ubereinstimmen m"ussen.
Ist dies nicht der Fall, bleibt der Small Step Interpreter stecken.


\section{Die Sprache \LTHREE}

\index{Polymorphie}
Die Sprache \LTHREE\ erweitert die Sprache \LTWO\ um ein polymorphes \notation{Typsystem}, sowie \notation{Tupel} und 
\notation{Listen}, f"ur die zus"atzlich abk"urzende Schreibweisen eingef"uhrt wurden. Die Menge \notation{$\Exp$} der
g"ultigen Ausdr"ucke wird hierf"ur um die Produktionen
\bgram
e \is (e_1,\ldots,e_n) \qquad (n \ge 2)                             & & \mbox{$n$-Tupel}
  \al [e_1;\ldots;e_n]                                              & & \mbox{Liste}
  \al e_1 \coloncolon e_2                                           & & \mbox{Konkatenation}
  \al \abstr{(\id_1,\ldots,\id_n): \tau_1 * \ldots * \tau_n}{e}
  \al \bli{(\id_1,\ldots,\id_n): \tau_1 * \ldots * \tau_n}{e1}{e2}
\egram
erweitert, wobei s"amtliche Typangaben wieder optional sind. Die Mengen \notation{$\Const$} und \notation{$\Val$}
werden durch die Produktionen
\bgram
c \is \Fst \mid \Snd                & & \mbox{Paarprojektionen}
  \al \#n\_i \qquad (1 \le i \le n) & & \mbox{Projektionen}
  \al \Cons \mid [\,]               & & \mbox{Listenkonstruktion}
  \al \Hd \mid \Tl \mid \Empty      & & \mbox{Listenoperatoren}
\egram
und
\bgram
v \is (v_1,\ldots,v_n)
  \al [v_1,\ldots,v_n]
  \al \Cons\,v_1
\egram
erweitert. F"ur Listenoperationen wird eine weitere Ausnahme
\bgram
\exn \is empty\_list
\egram
hinzugenommen.

Die Menge der monomorphen Typen \notation{$\Type$} wird erweitert durch Produktionen f"ur Tupel- und Listentypen, sowie
Typvariablen $\alpha\ldots\omega$.
\bgram
\tau \is \tau_1 * \ldots * \tau_n \qquad (n \ge 2)
     \al \listtype{\tau'}
     \al \alpha \mid \ldots \mid \omega
\egram


\subsection{Big step Semantik von \LTHREE}

Ein \notation{big step} hei"st g"ultig f"ur \LTHREE, wenn er sich mit den big step Regeln von \LTWO\ und den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(TUPLE)}          & $\regel{e_1 \eval v_1 \quad \ldots \quad e_n \eval v_n}
                                     {(e_1,\ldots,e_n) \eval (v_1,\ldots,v_n)}$ \\[5mm]
    \mbox{(FST)}            & $\Fst\,(v_1,v_2) \eval v_1$ \\[3mm]
    \mbox{(SND)}            & $\Snd\,(v_1,v_2) \eval v_2$ \\[3mm]
    \mbox{(PROJ)}           & $\#n\_i\,(v_1,\ldots,v_n) \eval v_i \qquad (1 \le i \le n)$ \\[3mm]
    \mbox{(LIST)}           & $\regel{e_1 \eval v_1 \quad \ldots \quad e_n \eval v_n}
                                     {[e_1;\ldots;e_n] \eval [v_1;\ldots;v_n]}$ \\[5mm]
    \mbox{(CONS)}           & $(\coloncolon)\,v'\,[v_1;\ldots;v_n] \eval [v';v_1;\ldots;v_n]$ \\[3mm]
    \mbox{(HD)}             & $\Hd\,\left(\Cons\,\left(v_1,v_2\right)\right) \eval v_1$ \\[3mm]
    \mbox{(HD-EMPTY)}       & $\Hd\,[\,] \eval\,\uparrow empty\_list$ \\[3mm]
    \mbox{(TL)}             & $\Tl\,\left(\Cons\,\left(v_1,v_2\right)\right) \eval v_2$ \\[3mm]
    \mbox{(TL-EMPTY)}       & $\Tl\,[\,] \eval\,\uparrow empty\_list$ \\[3mm]
    \mbox{(IS-EMPTY-FALSE)} & $\Empty\,\left(\Cons\,v\right) \eval \false$ \\[3mm]
    \mbox{(IS-EMPTY-TRUE)}  & $\Empty\,[\,] \eval \true$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln herleiten l"asst. Zu beachten ist, dass - vielleicht wider der Intuition - die
(CONS) Regel\footnote{Der Leser wird sich hoffentlich erinne\mbox, dass bin"are Operatoren, die au"serhalb eines Infixausdrucks
verwendet werden, geklammert werden m"ussen. $v'\,\coloncolon\,[v_1,\ldots,v_n]$ ist also syntaktischer Zucker f"ur
$(\coloncolon)\,v'\,[v_1;\ldots;v_n]$.} f"ur den bin"aren Konkatenationsoperator $\coloncolon$ definiert ist, und nicht f"ur den
un"aren Listenkonstruktor $\Cons$. Dies wird jedoch leicht ersichtlich, wenn man sich vor Augen h"alt, dass $(\Cons\,v) \in \Val$.
F"ur Details zum Thema Listen sei hier auf den Inhalt der Vorlesung verwiesen.


\subsection{Small step Semantik von \LTHREE}

Die \notation{small step} Regeln f"ur \LTHREE\ entsprechen im wesentlichen den big step Regeln. Ein small step hei"st g"ultig f"ur
\LTHREE, wenn er sich mit den small step Regeln von \LTWO\ und den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(TUPLE)}          & $\regel{e_i \to e_i'}
                                     {(e_1,\ldots,e_i,\ldots,e_n) \to (e_1,\ldots,e_i',\ldots,e_n)}$ \\[5mm]
    \mbox{(FST)}            & $\Fst\,(v_1,v_2) \to v_1$ \\[3mm]
    \mbox{(SND)}            & $\Snd\,(v_1,v_2) \to v_2$ \\[3mm]
    \mbox{(PROJ)}           & $\#n\_i\,(v_1,\ldots,v_n) \to v_i \qquad (1 \le i \le n)$ \\[3mm]
    \mbox{(LIST)}           & $\regel{e_i \to e_i'}
                                     {[e_1;\ldots;e_i;\ldots,e_n] \to [e_1;\ldots;e_i';\ldots;e_n]}$ \\[5mm]
    \mbox{(CONS)}           & $(\coloncolon)\,v'\,[v_1;\ldots;v_n] \to [v';v_1;\ldots;v_n]$ \\[3mm]
    \mbox{(HD)}             & $\Hd\,\left(\Cons\,\left(v_1,v_2\right)\right) \to v_1$ \\[3mm]
    \mbox{(HD-EMPTY)}       & $\Hd\,[\,] \to \, \uparrow empty\_list$ \\[3mm]
    \mbox{(TL)}             & $\Tl\,\left(\Cons\,\left(v_1,v_2\right)\right) \to v_2$ \\[3mm]
    \mbox{(TL-EMPTY)}       & $\Tl\,[\,] \to \, \uparrow empty\_list$ \\[3mm]
    \mbox{(IS-EMPTY-FALSE)} & $\Empty\,\left(\Cons\,v\right) \to \false$ \\[3mm]
    \mbox{(IS-EMPTY-TRUE)}  & $\Empty\,[\,] \to \true$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln herleiten l"asst.


\subsection{Typechecker Semantik von \LTHREE}

Wie bereits erw"ahnt verf"ugt die Sprache \LTHREE\ "uber ein \notation{polymorphes Typsystem}, das hei"st dass die Axiome f"ur
Konstanten jetzt von der Form $\tj{c}{\pi}$ sind. F"ur die Konstanten der Sprachen \LONE\ bis \LTWO\ sei $\pi$
einfach der bisherige monomorphe Typ $\tau$, f"ur die mit \LTHREE\ neu hinzukommenden Konstanten sei es der
polymorphe Typ, wie im Folgenden dargestellt.
\begin{eqnarray*}
 [\,]         & :: & \forall\alpha.\,\listtype{\alpha} \\
\Cons         & :: & \forall\alpha.\,\alpha * \listtype{\alpha}\to \listtype{\alpha}\\
  \Hd         & :: & \forall\alpha.\,\listtype{\alpha} \to \alpha \\
  \Tl         & :: & \forall\alpha.\,\listtype{\alpha} \to \listtype{\alpha}\\
\Empty        & :: & \forall\alpha.\,\listtype{\alpha} \to \bool\\
 \coloncolon  & :: & \forall\alpha.\,\alpha \to \listtype{\alpha} \to \listtype{\alpha}\\
 \Fst         & :: & \forall\alpha_1,\alpha_2.\,\alpha_1 * \alpha_2 \to \alpha_1\\
 \Snd         & :: & \forall\alpha_1,\alpha_2.\,\alpha_1 * \alpha_2 \to \alpha_2\\
 \#n\_i       & :: & \forall\alpha_1,\ldots,\alpha_n.\,\alpha_1 * \ldots * \alpha_n \to \alpha_i \quad (1 \le i \le n)
\end{eqnarray*}
Die Regel
\[ \mbox{(P-CONST) }\ \regel{\tj{c}{\pi}}
                            {\Tj{\Gamma}{c}{\tau}}
   \ \mbox{ falls $\tau$ Instanz von $\pi$}\]
ersetzt die bisherige Regel (CONST), wobei $\tau'$ eine \emph{neue Instanz} des polymorphen Typs
$\pi = \forall\alpha_1,\ldots,\alpha_n.\,\tau$ ist, wenn $\tau'$ von der Form $\tau[\alpha_1'/\alpha_1,\ldots,\alpha_n'/\alpha_n]$
ist, wobei $\alpha_1',\ldots,\alpha_n'$ neue Typvariablen sind.

In die Typumgebung $\Gamma: \Id \pto \Ptype$ werden nun polymorphe Typen eingetragen. Entsprechend ersetzt die Regel
\[ \mbox{(P-ID) }\ \Tj{\Gamma}{\id}{\tau} \reason{falls $\id \in \dom \Gamma$, $\Gamma(\id) = \pi$ und $\tau$ Instanz von $\pi$} \]
die bisherige Regel (ID). Die neue Regel
\[ \mbox{(P-LET) }\ \regel{\Tj{\Gamma}{e_1}{\tau}
                          \quad
                          \Tj{\Gamma[Closure_\Gamma(\tau)/\id]}{e_2}{\tau'}}
                          {\Tj{\Gamma}{\bli{\id}{e_1}{e_2}}{\tau'}}\]
sorgt f"ur das ,,polymorph machen'' des Typs beim Eintragen in die Typumgebung, wobei der polymorphe Abschlu"s eines Typs $\tau$
in der Typumgebung $\Gamma$ durch
\[
  Closure_\Gamma(\tau) = \forall\alpha_1,\ldots,\alpha_n.\,\tau \reason{mit $\{\alpha_1,\ldots,\alpha_n\} = free(\tau) \backslash free(\Gamma)$}
\]
definiert ist. Die Regel (LET) wird beibehalten, da sie f"ur \LFOUR, wo (P-LET) eingeschr"ankt wird, noch ben"otigt wird. F"ur \LTHREE\ ist
es also zul"assig, im Falle von $Closure_\Gamma(\tau) = \tau$ sowohl (LET) als auch (P-LET) anzuwenden\footnote{Na"urlich auch dann, wenn
es f"ur die Wohlgetyptheit nicht erforderlich ist, dass f"ur $\id$ ein polymorpher Typ eingetragen wird.}.

F"ur Listen und Tupel werden die Regeln\\[3mm]
\begin{tabular}{ll}
  \mbox{(LIST)\ } & $\regel{\Tj{\Gamma}{e_1}{\tau} \quad \ldots \quad \Tj{\Gamma}{e_n}{\tau}}
                           {\Tj{\Gamma}{[e_1;\ldots;e_n]}{\listtype{\tau}}}$ \\[5mm]
  \mbox{(TUPLE)\ }& $\regel{\Tj{\Gamma}{e_1}{\tau_1} \quad \ldots \quad \Tj{\Gamma}{e_n}{\tau_n}}
                           {\Tj{\Gamma}{(e_1,\ldots,e_n)}{\tau_1 * \ldots * \tau_n}}$
\end{tabular}\\[7mm]
hinzugenommen.


\subsection{Minimal Typing Semantik von \LTHREE}

  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lom,
  wenn es sich mit den  Typregeln \\[5mm]

     \begin{tabular}{ll}
  \mbox{(LIST)\ } & $\regel{\Tjm{\Gamma}{e_1}{\tau} \quad \ldots \quad \Tjm{\Gamma}{e_n}{\tau}}
                           {\Tjm{\Gamma}{[e_1;\ldots;e_n]}{\listtype{\tau}}}$ \\[5mm]
  \mbox{(TUPLE)\ }& $\regel{\Tjm{\Gamma}{e_1}{\tau_1} \quad \ldots \quad \Tjm{\Gamma}{e_n}{\tau_n}}
                           {\Tjm{\Gamma}{(e_1,\ldots,e_n)}{\tau_1 * \ldots * \tau_n}}$
  \end{tabular} \\[7mm]
  und den Suptyping Regeln herleiten l\"a"st.

\subsection{Syntaktischer Zucker}

\LTHREE\ enth"alt wie gesehen syntaktischen Zucker f"ur den leichteren Umgang mit Listen und Tupeln. Die Ak"urzungen werden
wie im Folgenden dargestellt in die Kernsyntax "ubersetzt.
\begin{eqnarray*}
  [e_1;\ldots;e_n]    & \mbox{ steht f"ur } & \Cons\,(e_1,\ldots \Cons\,(e_n, [\,])) \quad (n \le 1) \\
  e_1 \coloncolon e_2 & \mbox{ steht f"ur } & \Cons\,(e_1, e_2) \\
  \Fst                & \mbox{ steht f"ur } & \#2\_1 \\
  \Snd                & \mbox{ steht f"ur } & \#2\_2
\end{eqnarray*}
Mehrfaches $\lambda$
\[
  \lambda(\id_1,\ldots,\id_n):\,\tau_1 * \ldots * \tau_n.\,e
\]
steht f"ur
\[
  \lambda \id:\,\tau_1 * \ldots * \tau_n.\,\blet\,\id_1 = (\#n\_1\,id)\,\bin \ldots \blet\,\id_n = (\#n\_n\,id)\,\bin\,e
\]
und mehrfaches $\blet$
\[
  \bli{(\id_1,\ldots,\id_n):\,\tau_1 * \ldots * \tau_n}{e_1}{e_2}
\]
steht f"ur
\[
  \bli{\id:\,\tau_1 * \ldots * \tau_n}{e_1}{\blet\,\id_1 = (\#n\_1\,id)\,\bin \ldots \blet\,\id_n = (\#n\_n\,id)\,\bin\,e_2}
\]
wobei $\id_1,\ldots,\id_n$ verschieden sind und $\id$ ein neuer Name, der nicht in $e$ bzw. $e_2$ und unter $\id_1,\ldots,\id_n$
vorkommt.

\section{Die Sprache \LTHREESUB}
Die Sprache \LTWOSUB erweitert die Sprache \LTWOSUB um das Typsystem von \LTHREE. 

\subsection{Sub Typing Semantik von \LTHREESUB}

Ein Beweisschritt f"ur Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
  \begin{tabular}{ll}
    \mbox{(S-LIST)\ }      & $\RULE{\subtype{\tau} {\tau'} }
                              {\subtype{\listtype{\tau}} {\listtype{\tau'}}}$ \\[4mm]
    \mbox{(S-PRODUCT)\ }      & $\RULE{\subtype{\tau_i} {\tau_i} \text{ f\"ur  i = 1 ... n }}
                              {\subtype{\tau_1 * \ldots * \tau_n} {\tau_1' * \ldots * \tau_n'}}$ \\[4mm]
  \end{tabular} \\[7mm]

herleiten l\"a"st.

\subsection{Rec Sub Typing Semantik von \LTHREESUB}

Ein Beweisschritt f"ur Rec Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
 \begin{tabular}{lll}
    \mbox{(S-LIST)\ }      & $\RULE{A' \vdash \subtype{\tau} {\tau'} }
                              {A \vdash \subtype{\listtype{\tau}} {\listtype{\tau'}}}$ 
				& mit $A' = A \cup \{\subtype{\listtype{\tau}} {\listtype{\tau'}}\}$ \\[4mm]
    \mbox{(S-PRODUCT)\ }      & $\RULE{A' \vdash \subtype{\tau_i} {\tau_i} \text{ f\"ur  i = 1 ... n }}
                              {\subtype{\tau_1 * \ldots * \tau_n} {\tau_1' * \ldots * \tau_n'}}$ 
				& mit $A' = A \cup \{\subtype{\tau_1 * \ldots * \tau_n} {\tau_1' * \ldots * \tau_n'}\}$ \\[4mm]
          \end{tabular}


herleiten l\"a"st.


\section{Die Sprache \LFOUR}

Die Sprache \LFOUR\ erweitert schlie"slich \LTHREE\ um \notation{imperative Konzepte}, also \notation{Speicher}, \notation{sequentielle Ausf"uhrung} und
\notation{Schleifen}. Die Menge $\Exp$ der g"ultigen Ausdr"ucke wird hierzu um die Produktionen
\bgram
e \is \bift{e_1}{e_2}
  \al \bwd{e_1}{e_2}
  \al e_1\,;\,e_2
\egram
und die Menge $\Const$ um die Produktionen 
\bgram
c \is \Ref \mid \Deref \mid \Assign
\egram
erweitert.

Die operationelle Semantik muss f"ur die Sprache \LFOUR\ angepasst werden. Dazu sei eine unendliche Menge \notation{$\Loc$} vorgegen,
deren Element ($X, Y, \ldots$) \Define{Speicherpl"atze}{Speicherplatz} \engl{locations}{location} genannt werden. Ein \define{Speicherzustand}
\engl{store} ist eine partielle Funktion
\[
  \sigma: \Loc \pto \Val
\]
mit endlichem Definitionsbereich $dom(\sigma)$.
\name{Store} sei die Menge aller Speicherzust"ande. Eine \define{Konfiguration} ist entweder ein Paar
$(e,\sigma) \in \Exp \times \name{Store}$ oder $(exn, \sigma) \in \Exn \times \name{Store}$. F"ur die Semantik des
$\Ref$-Operators sei eine totale Funktion
\[
  alloc: \name{Store} \to \Loc
\]
mit $alloc(\sigma) \not\in dom(\sigma)$ gegeben ($alloc(\sigma)$ ist also ein Speicherplatz in $\sigma$,
der bisher noch nicht alloziert wurde).


\subsection{Big step Semantik von \LFOUR}

Ein \notation{big step} ist von der Form $(e,\sigma) \eval (v,\sigma')$ oder $(e,\sigma) \eval (exn,\sigma')$. Ein big step
heisst g"ultig f"ur \LFOUR, wenn er sich mit den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(DEREF)}        & $(\Deref\,X, \sigma) \eval (\sigma(X), \sigma)$   \ falls $X \in dom(\sigma)$ \\[3mm]
    \mbox{(ASSIGN)}       & $(X\,\Assign\,v, \sigma) \eval ((), \sigma[v/X])$ \ falls $X \in dom(\sigma)$ \\[3mm]
    \mbox{(REF)}          & $(\Ref\,v, \sigma) \eval (X, \sigma[v/X])$        \ mit $X = alloc(\sigma)$ \\[3mm]
    \mbox{(SEQ)}          & $\regel{(e_1,\sigma) \eval (v_1,\sigma') \quad (e_2,\sigma') \eval (v_2,\sigma'')}
                                   {(e_1\,;\,e_2,\sigma) \eval (v_2,\sigma'')}$ \\[5mm]
    \mbox{(COND-1-FALSE)} & $\regel{(e_0,\sigma) \eval (\false,\sigma')}
                                   {(\bift{e_0}{e_1},\sigma) \eval ((), \sigma')}$ \\[5mm]
    \mbox{(COND-1-TRUE)}  & $\regel{(e_0,\sigma) \eval (\true,\sigma') \quad (e_1,\sigma') \eval (v_1,\sigma'')}
                                   {(\bift{e_0}{e_1},\sigma) \eval (v_1,\sigma'')}$ \\[5mm]
    \mbox{(WHILE)}        & $\regel{(\bift{e_1}{e_2\,;\,\bwd{e_1}{e_2}}, \sigma) \eval (v,\sigma')}
                                   {(\bwd{e_1}{e_2}, \sigma) \eval (v,\sigma')}$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln und den durch Speicherzust"ande erweiterten big step Regeln von \LTHREE\ 
herleiten l"asst.


\subsection{Small step Semantik von \LFOUR}

Ein \notation{small step} ist nun von der Form $(e,\sigma) \to (e',\sigma')$ oder $(e,\sigma) \to (exn,\sigma)$. Ein small
step heisst g"ultig f"ur \LFOUR, wenn er sich mit den Regeln\\[5mm]
  \begin{tabular}{ll}
    \mbox{(DEREF)}        & $(\Deref\,X, \sigma) \to (\sigma(X), \sigma)$   \ falls $X \in dom(\sigma)$ \\[3mm]
    \mbox{(ASSIGN)}       & $(X\,\Assign\,v, \sigma) \to ((), \sigma[v/X])$ \ falls $X \in dom(\sigma)$ \\[3mm]
    \mbox{(REF)}          & $(\Ref\,v, \sigma) \to (X, \sigma[v/X])$        \ mit $X = alloc(\sigma)$ \\[3mm]
    \mbox{(SEQ-EVAL)}     & $\regel{(e_1,\sigma) \to (e_1',\sigma')}
                                   {(e_1\,;\,e_2,\sigma) \to (e_1'\,;\,e_2,\sigma)}$ \\[5mm]
    \mbox{(SEQ-EXEC)}     & $(v\,;\,e,\sigma) \to (e,\sigma)$ \\[3mm]
    \mbox{(COND-1-EVAL)}  & $\regel{(e_0,\sigma) \to (e_0',\sigma')}
                                   {(\bift{e_0}{e_1},\sigma) \to (\bift{e_0'}{e_1},\sigma)}$ \\[5mm]
    \mbox{(COND-1-FALSE)} & $(\bift{\false}{e},\sigma) \to ((),\sigma)$ \\[3mm]
    \mbox{(COND-1-TRUE)}  & $(\bift{\true}{e},\sigma) \to (e,\sigma)$ \\[3mm]
    \mbox{(WHILE)}        & $(\bwd{e_0}{e_1},\sigma) \to (\bift{e_0}{e_1\,;\,\bwd{e_0}{e_1}}, \sigma)$
  \end{tabular}\\[7mm]
sowie den entsprechenden exception-Regeln und den durch Speicherzust"ande erweiterten small step Regeln von \LTHREE\ 
herleiten l"asst.


\subsection{Typechecker Semantik von \LFOUR}

Ein \notation{Typurteil} hei"st g"ultig f"ur \LTWO, wenn es sich mit den Typregeln von \LONE\ und den Regeln\\[3mm]
\begin{tabular}{ll}
\mbox{(SEQ)\ }    & $\regel{\Tj{\Gamma}{e_1}{\tau_1} \quad \Tj{\Gamma}{e_2}{\tau_2}}
                           {\Tj{\Gamma}{e_1\,;\,e_2}{\tau_2}}$ \\[5mm]
\mbox{(WHILE)\ }  & $\regel{\Tj{\Gamma}{e_1}{\bool} \quad \Tj{\Gamma}{e_2}{\tau}}
                           {\Tj{\Gamma}{\bwd{e_1}{e_2}}{\unit}}$ \\[5mm]
\mbox{(COND-1)\ } & $\regel{\Tj{\Gamma}{e_0}{\bool} \quad \Tj{\Gamma}{e_1}{\unit}}
                           {\Tj{\Gamma}{\bift{e_0}{e_1}}{\unit}}$
\end{tabular}\\[7mm]
herleiten l"asst.
Die neuen Konstanten werden "uber die Regel (P-CONST) behandelt und haben die folgenden polymorphen Typen.
\begin{eqnarray*}
\Deref  & :: & \forall\alpha.\,\reftype{\alpha} \to \alpha \\
\Ref    & :: & \forall\alpha.\,\alpha \to \reftype{\alpha} \\
\Assign & :: & \forall\alpha.\,\reftype{\alpha} \to \alpha \to \unit
\end{eqnarray*}
Um die \notation{Typsicherheit} zu gew"ahrleisten, muss die Regel (P-LET) eingeschr"ankt werden, und zwar wird nun
nur noch "uber Werte quantifiziert
\[ \mbox{(P-LET) }\ \regel{\Tj{\Gamma}{v_1}{\tau}
                          \quad
                          \Tj{\Gamma[Closure_\Gamma(\tau)/\id]}{e_2}{\tau'}}
                          {\Tj{\Gamma}{\bli{\id}{v_1}{e_2}}{\tau'}}\]
wobei $v_1 \in \Val$. Das bedeutet also in der Folge, dass (P-LET) nur noch angewendet werden darf, wenn
hinter dem Gleichheitszeichen ein Wert steht. Sonst muss (LET) angewendet werden. Dies entspricht dem
OCaml Typsystem.


\subsection{Syntaktischer Zucker}
Die Sprache \LFOUR\ beinhaltet drei Abk"urzungen, die wie folgt in \notation{Kernsyntax} "ubersetzt werden
\begin{eqnarray*}
  e_1\,;\,e_2     & \mbox{ steht f"ur } & \bli{\id}{e_1}{e_2} \\
  \bift{e_1}{e_2} & \mbox{ steht f"ur } & \bifte{e_1}{e_2}{()} \\
  \bwd{e_1}{e_2}  & \mbox{ steht f"ur } & \rec{\id: unit}{\bift{e_1}{(e_2\,;\,\id)}}
\end{eqnarray*}
wobei $\id \not\in free(e_1) \cup free(e_2)$.


\section{Die Sprache \LFOURSUB}
Die Sprache \LFOURSUB erweitert die Sprache \LTHREESUB um das Typsystem von \LFOUR. 


\subsection{Sub Typing Semantik von \LFOURSUB}

Ein Beweisschritt f"ur Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
  \begin{tabular}{ll}
    \mbox{(S-REF)\ }      & $\RULE{\subtype{\tau} {\tau'} }
                              {\subtype{\reftype{\tau}} {\reftype{\tau'}}}$ \\[4mm]
   \end{tabular} \\[7mm]

herleiten l\"a"st.

\subsection{Rec Sub Typing Semantik von \LFOURSUB}

Ein Beweisschritt f"ur Rec Sub Typing hei"st g"ultig, wenn er sich mit den Regeln  \\[5mm]
 \begin{tabular}{lll}
    \mbox{(S-REF)\ }      & $\RULE{A' \vdash \subtype{\tau} {\tau'} }
                              {A \vdash \subtype{\reftype{\tau}} {\reftype{\tau'}}}$ 
                                  & mit $A' = A \cup \{\subtype{\reftype{\tau}} {\reftype{\tau'}}\}$ \\[4mm]
          \end{tabular}


herleiten l\"a"st.


\section{Konkrete Syntax}
Da es mitunter nicht mit jeder herk"ommlichen Tastatur m"oglich ist, griechische Buchstaben zu tippen,
k"onnen die aufgef"uhrten Schl"usselw"orter als Ersatz benutzt werden. Ebenso ist es nicht so einfach
Unicode Zeichen einzugeben, auch hierf"ur gibt es die entsprechenden Abk"urzungen. Unterscheidungen,
die nur in er Theorie m"oglich sind, in der Praxis aber nicht unterscheidbar sind, m"ussen mit
Schl"usselw"orte\mbox unterschieden werden.\\[5mm]
\begin{tabular}{lll}
  \mbox{$\lambda$}                            & $\textbf{lambda}$                        & Lambda Ausdruck\\
  \mbox{$\mu$}                                & $\textbf{mu}$                            & Rekursive Typen\\
  \mbox{$\zeta$}                              & $\textbf{zeta}$                          & Klassentypen\\
  \mbox{$\alpha,\ \beta,\ \ldots$}            & $\texttt{'a}$, $\texttt{'b}$, $\ldots$   & Typvariablen\\
  \mbox{$\to$}                                & $\texttt{->}$                            & Funktionstypen\\
  \mbox{$a: \tau_1;\ m: \tau_2;\ \phi \quad$} & $\texttt{attr}\ a: \tau_1;\ m: \tau_2;\ \phi \quad$
                                                                                         & Reihentypen\\
\end{tabular}\\[5mm]
Bei den Reihentypen muss eine Entscheidung getroffen werden, ob es sich bei einem eingegebenen Identifier
um einen Attributnamen oder um einen Methodennamen handelt. Da der Parser das nicht automatisch erkennen
kann, muss das Schl"usselwort \glqq$\texttt{attr}$\grqq\ verwendet werden, wenn der Benutzer ein 
Attributnamen meint. Wird das Schl"usselwort nicht eingegeben, handelt es sich um einen Methodennamen.

Zu beachten ist auch, dass der Scanner den Ausdruck \glqq$\app{\app{(*)}{4}}{5}$\grqq\ nicht akzeptiert,
da Kommentare mit einem \glqq$(*$\grqq\ eingeleitet werden. Er erwartet ein \glqq$*)$\grqq,
um den Kommentar zu beenden. Wenn multipliziert werden soll, muss \glqq$\app{\app{(\ *)}{4}}{5}$\grqq\ 
eingeben werden.


% vi:set syntax=tex ts=2 sw=2 et encoding=UTF-8:
