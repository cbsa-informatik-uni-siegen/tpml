import de.unisiegen.tpml.core.types.*;
import de.unisiegen.tpml.core.expressions.*;
import java.util.ArrayList;
import de.unisiegen.tpml.core.exceptions.LanguageParserMultiException;
import de.unisiegen.tpml.core.languages.LanguageParserException;
import de.unisiegen.tpml.core.Messages ;
import java.text.MessageFormat;


/* Helper classes */
action code 
{:
  private static class IdTypePair 
  {
    Identifier id;
    MonoType type;
    
    public IdTypePair(Identifier pId, MonoType pType) 
    { 
      this.id = pId;
      this.type = pType; 
    }
  }
  
  private static class IdExprPair 
  {
    Identifier id;
    Expression expression;
    
    public IdExprPair(Identifier pId, Expression pExpression)
    { 
      this.id = pId; 
      this.expression = pExpression;
    }
  }
 
  private static class Error
  {
    public static void expect(String pSymbol, String ... pTokenSequence)
    {
      expect (0, 0, pSymbol, pTokenSequence);
    }
    
    public static void expect(int pLeft, int pRight, String pSymbol, String ... pTokenSequence)
    {
      String or = Messages.getString ( "Parser.15" ) ;
      String result = "" ;
      for ( int i = 0; i < pTokenSequence.length ; i++)
      {
        if ( i == 0 )
        {
          result += "\"" + pTokenSequence [i] + "\"" ;
        }
        else if ( i == pTokenSequence.length - 1 )
        {
          result += " " + or + " \"" + pTokenSequence [i]+ "\"";
        }
        else
        {
          result += ", \"" + pTokenSequence [i]+ "\"";
        }
      }
      throw new LanguageParserException (  
        MessageFormat.format ( "<html>" + Messages.getString ( "Parser.14" ) + "</html>", 
          result, pSymbol), pLeft, pRight);
    }
  }
  
  private static class Duplicated
  {
    public static void check(Row pRow)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Expression [ ] rowExpressions = pRow.getExpressions ( ) ;
      for ( int i = 0 ; i < rowExpressions.length ; i ++ )
      {
        if ( rowExpressions[i] instanceof Attribute )
        {
          negativeIdentifiers.clear();
          Attribute attribute1 = (Attribute) rowExpressions[i] ;
          for ( int j = i+1 ; j < rowExpressions.length ; j++ )
          {
            if ( rowExpressions[j] instanceof Attribute )
    	    {
    	      Attribute attribute2 = (Attribute) rowExpressions[j] ;
    	      if ( attribute1.getId().equals(attribute2.getId()))
    	      {
    	        negativeIdentifiers.add(attribute2.getId());
    	      }
    	    }
    	  }
    	  negativeIdentifiers.add ( attribute1.getId() ) ;
    	  LanguageParserMultiException.throwExceptionRow ( negativeIdentifiers ) ;
        }
      }
    }
    
    
    public static void check(Duplication pDuplication)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pDuplication.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionDuplication ( negativeIdentifiers ) ;
      }
    }
    
    
    public static void check(RowType pRowType)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pRowType.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionRowType ( negativeIdentifiers ) ;
      }
    }
  }
:}


/* Syntactic tokens */
terminal			ARROW;
terminal			LPAREN, RPAREN;
terminal			DOT;
terminal			STAR;

/* Types */
terminal			BOOL, INT, UNIT;
terminal			MU;
terminal			LIST;

/* Special tokens */
terminal Integer	TYPEVARIABLE;
terminal String		IDENTIFIER;

/* Non terminals */
non terminal MonoType				type;
non terminal MonoType				simple_type;
non terminal BooleanType			boolean_type;
non terminal IntegerType			integer_type;
non terminal UnitType				unit_type;
non terminal TypeVariable			type_variable;
non terminal ArrowType				arrow_type;
non terminal TypeName				type_name;
non terminal RecType				rec_type;
non terminal TupleType				tuple_type;
non terminal ListType				list_type;
non terminal MonoType[]				tuple_type_list;

/* Error non terminals */
non terminal 		simple_type_error;
non terminal 		arrow_type_error;
non terminal		rec_type_error;
non terminal		tuple_type_list_error;

/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence right	ARROW;
precedence left		STAR;


/*********
 * Types *
 *********/


type							::=	simple_type:t
									{: RESULT = t; :}
								|	arrow_type:a
									{: RESULT = a; :}
								|	tuple_type:t
									{: RESULT = t; :}
								|	list_type:l
									{: RESULT = l; :}
								;

simple_type						::=	LPAREN:l type:t RPAREN:r
									{: RESULT = t; :}
								|	LPAREN type simple_type_error
									{: :}
								|	boolean_type:b
									{: RESULT = b; :}
								|	integer_type:i
									{: RESULT = i; :}
								|	unit_type:u
									{: RESULT = u; :}
								|	type_variable:t
									{: RESULT = t; :}
								|	type_name:t
									{: RESULT = t; :}
								|	rec_type:r
									{: RESULT = r; :}
								;

simple_type_error				::= /* epsilon */
									{: Error.expect("Type", ")"); :}
								;

arrow_type						::= type:t1 ARROW type:t2
									{: RESULT = new ArrowType(t1, t2, t1left, t2right); :}
								|	type ARROW arrow_type_error
									{: :}
								;

arrow_type_error				::= /* epsilon */
									{: Error.expect("Arrow-Type", "\u03C4<sub>2</sub>"); :}
								;

boolean_type					::= BOOL:b
									{: RESULT = new BooleanType(bleft, bright); :}
								;

integer_type					::= INT:i
									{: RESULT = new IntegerType(ileft, iright); :}
								;

unit_type						::= UNIT:u
									{: RESULT = new UnitType(uleft, uright); :}
								;

type_variable					::= TYPEVARIABLE:t
									{: RESULT = new TypeVariable(0, t, tleft, tright); :}
								;

type_name						::= IDENTIFIER:id
									{: RESULT = new TypeName(id, idleft, idright); :}
								;

rec_type						::= MU:m IDENTIFIER:id DOT type:t
									{: RESULT = new RecType(new TypeName(id, idleft, idright), t, mleft, tright); :}
								|	MU rec_type_error
									{: :}								
								;

rec_type_error					::= /* epsilon */
									{: Error.expect("Rec-Type", "t.\u03C4"); :}
								|	IDENTIFIER
									{: Error.expect("Rec-Type", ".\u03C4"); :}
								|	IDENTIFIER DOT
									{: Error.expect("Rec-Type", "\u03C4"); :}
								;

tuple_type						::= tuple_type_list:t
									{: RESULT = new TupleType(t, tleft, tright); :}
								;

list_type						::=	type:t LIST:l
									{: RESULT = new ListType(t, tleft, lright); :}
								;

tuple_type_list					::= tuple_type_list:tl STAR type:t
									{:
									   RESULT = new MonoType[tl.length + 1];
									   System.arraycopy(tl, 0, RESULT, 0, tl.length);
									   RESULT[tl.length] = t;
									:}
								|	type:t1 STAR type:t2
									{: RESULT = new MonoType[] { t1, t2 }; :}
								|	tuple_type_list STAR tuple_type_list_error
									{: :}
								|	type STAR tuple_type_list_error
									{: :}
								;

tuple_type_list_error			::= /* epsilon */
									{: Error.expect("Tuple-Type", "\u03C4"); :}
								;