import de.unisiegen.tpml.core.expressions.And ;
import de.unisiegen.tpml.core.expressions.Application ;
import de.unisiegen.tpml.core.expressions.ArithmeticOperator ;
import de.unisiegen.tpml.core.expressions.Attribute ;
import de.unisiegen.tpml.core.expressions.BinaryOperator ;
import de.unisiegen.tpml.core.expressions.BooleanConstant ;
import de.unisiegen.tpml.core.expressions.Class;
import de.unisiegen.tpml.core.expressions.Coercion;
import de.unisiegen.tpml.core.expressions.Condition ;
import de.unisiegen.tpml.core.expressions.Constant ;
import de.unisiegen.tpml.core.expressions.CurriedLet ;
import de.unisiegen.tpml.core.expressions.CurriedLetRec ;
import de.unisiegen.tpml.core.expressions.CurriedMethod ;
import de.unisiegen.tpml.core.expressions.Duplication ;
import de.unisiegen.tpml.core.expressions.Expression ;
import de.unisiegen.tpml.core.expressions.Identifier ;
import de.unisiegen.tpml.core.expressions.InfixOperation ;
import de.unisiegen.tpml.core.expressions.IntegerConstant ;
import de.unisiegen.tpml.core.expressions.Lambda ;
import de.unisiegen.tpml.core.expressions.Let ;
import de.unisiegen.tpml.core.expressions.LetRec ;
import de.unisiegen.tpml.core.expressions.Method ;
import de.unisiegen.tpml.core.expressions.New ;
import de.unisiegen.tpml.core.expressions.Not ;
import de.unisiegen.tpml.core.expressions.ObjectExpr ;
import de.unisiegen.tpml.core.expressions.Or ;
import de.unisiegen.tpml.core.expressions.Recursion ;
import de.unisiegen.tpml.core.expressions.RelationalOperator ;
import de.unisiegen.tpml.core.expressions.Row ;
import de.unisiegen.tpml.core.expressions.Send ;
import de.unisiegen.tpml.core.expressions.UnitConstant ;
import de.unisiegen.tpml.core.languages.Error ;
import de.unisiegen.tpml.core.languages.IdentifierExpressionPair ;
import de.unisiegen.tpml.core.languages.IdentifierTypePair ;
import de.unisiegen.tpml.core.languages.MultipleIdentifier ;
import de.unisiegen.tpml.core.types.ArrowType ;
import de.unisiegen.tpml.core.types.BooleanType ;
import de.unisiegen.tpml.core.types.IntegerType ;
import de.unisiegen.tpml.core.types.MonoType ;
import de.unisiegen.tpml.core.types.ObjectType ;
import de.unisiegen.tpml.core.types.RecType ;
import de.unisiegen.tpml.core.types.RowType ;
import de.unisiegen.tpml.core.types.TypeName ;
import de.unisiegen.tpml.core.types.TypeVariable ;
import de.unisiegen.tpml.core.types.UnitType ;


/* Terminals */
terminal			PLUS;
terminal			MINUS;
terminal			STAR;
terminal			SLASH;
terminal			MOD;
terminal			EQUAL;
terminal			LESS;
terminal			GREATER;
terminal			LESSEQUAL;
terminal			GREATEREQUAL;
terminal			AMPERAMPER;
terminal			BARBAR;
terminal			NOT;

/* Syntactic */
terminal			DOT;
terminal			LPAREN;
terminal			RPAREN;
terminal			ARROW;
terminal			COLON;
terminal			PARENPAREN;
terminal			SUBTYPE;
terminal			SEMI ;
terminal			DUPLBEGIN ;
terminal			DUPLEND ;
terminal			HASHKEY ;

/* Keywords */
terminal			LAMBDA;
terminal			LET;
terminal			IN;
terminal			IF;
terminal			THEN;
terminal			ELSE;
terminal			TRUE;
terminal			FALSE;
terminal			REC;
terminal			OBJECT;
terminal			END;
terminal			ATTRIBUTE;
terminal			METHOD;
terminal			CLASS;
terminal			NEW;
terminal			INHERIT;
terminal			FROM;
terminal			AS;
		
/* Types */
terminal			BOOL;
terminal			INT;
terminal			UNIT;
terminal			MU;

/* Special */
terminal String		IDENTIFIER;
terminal			COMMENT;
terminal Integer	NUMBER;
terminal Integer	TYPEVARIABLE;
terminal String		SELF ;

/* Non terminal - Expression */
non terminal Expression				seq_expr;
non terminal Expression				expr;
non terminal Expression				simple_expr;
non terminal Expression[]			simple_expr_list;
non terminal Identifier				identifier;
non terminal Expression				application;
non terminal Lambda					lambda;
non terminal Constant				constant;
non terminal BinaryOperator			operator;
non terminal ArithmeticOperator		arithmetic_operator;
non terminal RelationalOperator		relational_operator;
non terminal InfixOperation 		infix_operation;
non terminal InfixOperation 		infix_operation_plus;
non terminal InfixOperation 		infix_operation_minus;
non terminal InfixOperation 		infix_operation_mult;
non terminal InfixOperation 		infix_operation_div;
non terminal InfixOperation 		infix_operation_mod;
non terminal InfixOperation 		infix_operation_equal;
non terminal InfixOperation 		infix_operation_less;
non terminal InfixOperation 		infix_operation_greater;
non terminal InfixOperation 		infix_operation_less_equal;
non terminal InfixOperation 		infix_operation_greater_equal;
non terminal And					and;
non terminal Or						or;
non terminal Condition				condition;
non terminal Let					let;
non terminal CurriedLet				curried_let;
non terminal UnitConstant			unit_constant;
non terminal BooleanConstant		boolean_constant;
non terminal IntegerConstant		integer_constant;
non terminal Not					not;
non terminal Coercion				coercion;
non terminal Recursion				recursion;
non terminal LetRec					let_rec;
non terminal CurriedLetRec			curried_let_rec;
non terminal ObjectExpr				object_expr;
non terminal Duplication			duplication;
non terminal Send					send;
non terminal Row					row;
non terminal Attribute				attribute;
non terminal Method					method;
non terminal CurriedMethod			curried_method;
non terminal Class					class;
non terminal New					new;

/* Non terminal - Type */
non terminal MonoType				type;
non terminal MonoType				simple_type;
non terminal BooleanType			boolean_type;
non terminal IntegerType			integer_type;
non terminal UnitType				unit_type;
non terminal TypeVariable			type_variable;
non terminal ArrowType				arrow_type;
non terminal TypeName				type_name;
non terminal RecType				rec_type;
non terminal ObjectType				object_type;
non terminal RowType				row_type;

/* Non terminal - Helper */
non terminal IdentifierTypePair[]			curried_let_list;
non terminal IdentifierTypePair				curried_let_pair;
non terminal IdentifierTypePair[]			curried_let_rec_list;
non terminal IdentifierTypePair				curried_let_rec_pair;
non terminal IdentifierTypePair[]			curried_method_list;
non terminal IdentifierTypePair				curried_method_pair;
non terminal IdentifierExpressionPair[]		duplication_list;
non terminal IdentifierExpressionPair		duplication_pair;

/* Non terminal - Error */
non terminal 		epsilon;
non terminal 		simple_expr_error;
non terminal 		lambda_error;
non terminal 		and_error;
non terminal 		or_error;
non terminal 		condition_error;
non terminal 		let_error;
non terminal 		curried_let_error;
non terminal 		curried_let_pair_error;
non terminal 		infix_operation_plus_error;
non terminal  		infix_operation_minus_error;
non terminal  		infix_operation_mult_error;
non terminal  		infix_operation_div_error;
non terminal  		infix_operation_mod_error;
non terminal  		infix_operation_equal_error;
non terminal  		infix_operation_less_error;
non terminal  		infix_operation_greater_error;
non terminal  		infix_operation_less_equal_error;
non terminal  		infix_operation_greater_equal_error;
non terminal		coercion_error;
non terminal 		simple_type_error;
non terminal 		arrow_type_error;
non terminal		rec_type_error;
non terminal 		recursion_error;
non terminal 		let_rec_error;
non terminal 		curried_let_rec_error;
non terminal 		curried_let_rec_pair_error;
non terminal 		object_expr_error;
non terminal 		attribute_error;
non terminal 		curried_method_error;
non terminal 		curried_method_pair_error;
non terminal 		method_error;
non terminal 		duplication_error;
non terminal 		send_error;
non terminal 		duplication_pair_error;
non terminal 		duplication_list_error;
non terminal 		object_type_error;
non terminal		row_type_error;
non terminal		class_error;

/* Precedence */
precedence right	ARROW;
precedence right	BARBAR;
precedence right	AMPERAMPER;
precedence left		EQUAL;
precedence left		LESS;
precedence left		GREATER;
precedence left		LESSEQUAL;
precedence left		GREATEREQUAL;
precedence left		PLUS;
precedence left		MINUS;
precedence left		STAR;
precedence left		SLASH;
precedence left		MOD;


/***************
 * Expressions *
 ***************/


seq_expr						::= expr:e
									{: RESULT = e; :}
								;

expr							::=	simple_expr:e
									{: RESULT = e; :}
								|   application:a
									{: RESULT = a; :}
								|	lambda:l
									{: RESULT = l; :}
								|   infix_operation:i
									{: RESULT = i; :}
								|	and:a
									{: RESULT = a; :}
								|	or:o
									{: RESULT = o; :}
								|	condition:c
									{: RESULT = c; :}
								|	let:l
									{: RESULT = l; :}
								|	curried_let:c
									{: RESULT = c; :}
								|	recursion:r
									{: RESULT = r; :}
								|	let_rec:l
									{: RESULT = l; :}
								|   curried_let_rec:c
									{: RESULT = c; :}
								|	object_expr:o
									{: RESULT = o; :}
								|   duplication:d
									{: RESULT = d; :}
								|   class:c
									{: RESULT = c; :}
								|   new:n
									{: RESULT = n; :}
								;

identifier						::= IDENTIFIER:id
									{: RESULT = new Identifier (id,idleft,idright); :}
								|	SELF:s
									{: RESULT = new Identifier (s,sleft,sright); :}
								;

application						::= simple_expr:e simple_expr_list:l
									{:
									   for (int n = 0; n < l.length; ++n) 
						  			   {
						    			 e = new Application(e, l[n],
						      			   e.getParserStartOffset ( ) , 
						       				 l[n].getParserEndOffset ( ) );
						   			   }
						   			   RESULT = e; 
						   			:}
								;

infix_operation					::= infix_operation_plus:i
									{: RESULT = i ; :}
								|	infix_operation_minus:i
									{: RESULT = i ; :}
								|	infix_operation_mult:i
									{: RESULT = i ; :}
								|	infix_operation_div:i
									{: RESULT = i ; :}
								|	infix_operation_mod:i
									{: RESULT = i ; :}
								|	infix_operation_equal:i
									{: RESULT = i ; :}
								|	infix_operation_less:i
									{: RESULT = i ; :}
								|	infix_operation_greater:i
									{: RESULT = i ; :}
								|	infix_operation_less_equal:i
									{: RESULT = i ; :}
								|	infix_operation_greater_equal:i
									{: RESULT = i ; :}
								;

infix_operation_plus			::= expr:e1 PLUS:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newPlus(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_plus_error
									{: :}
								;

infix_operation_plus_error		::= expr:e1 PLUS:p epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, pright, "e<sub>2</sub>" ); :}
								;

infix_operation_minus			::= expr:e1 MINUS:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMinus(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_minus_error
									{: :}
								;

infix_operation_minus_error		::= expr:e1 MINUS:m epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, mright, "e<sub>2</sub>" ); :}
								;

infix_operation_mult			::=	expr:e1 STAR:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMult(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_mult_error
									{: :}
								;

infix_operation_mult_error		::= expr:e1 STAR:s epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, sright, "e<sub>2</sub>" ); :}
								;

infix_operation_div				::=	expr:e1 SLASH:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newDiv(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_div_error
									{: :}
								;

infix_operation_div_error		::= expr:e1 SLASH:s epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, sright, "e<sub>2</sub>" ); :}
								;

infix_operation_mod				::=	expr:e1 MOD:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMod(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_mod_error
									{: :}
								;

infix_operation_mod_error		::= expr:e1 MOD:m epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, mright, "e<sub>2</sub>" ); :}
								;

infix_operation_equal			::=	expr:e1 EQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newEquals(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_equal_error
									{: :}
								;

infix_operation_equal_error		::= expr:e1 EQUAL:e epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, eright, "e<sub>2</sub>" ); :}
								;

infix_operation_less			::=	expr:e1 LESS:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newLowerThan(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_less_error
									{: :}
								;

infix_operation_less_error		::= expr:e1 LESS:l epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, lright, "e<sub>2</sub>" ); :}
								;
						
infix_operation_greater			::=	expr:e1 GREATER:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newGreaterThan(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_greater_error
									{: :}
								;

infix_operation_greater_error	::= expr:e1 GREATER:g epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, gright, "e<sub>2</sub>" ); :}
								;

infix_operation_less_equal		::=	expr:e1 LESSEQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newLowerEqual(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_less_equal_error
									{: :}
								;

infix_operation_less_equal_error	::= expr:e1 LESSEQUAL:l epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, lright, "e<sub>2</sub>" ); :}
								;

infix_operation_greater_equal	::=	expr:e1 GREATEREQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newGreaterEqual(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_greater_equal_error
									{: :}
								;

infix_operation_greater_equal_error	::= expr:e1 GREATEREQUAL:g epsilon
									{: Error.expect("Infix-Operation", " e2", e1left, gright, "e<sub>2</sub>" ); :}
								;

and								::= expr:e1 AMPERAMPER expr:e2
									{: RESULT = new And(e1, e2,e1left,e2right); :}
								|	and_error
									{: :}
								;

and_error						::= expr:e1 AMPERAMPER:a epsilon
									{: Error.expect("And", " e2", e1left, aright, "e<sub>2</sub>" ); :}
								;

or								::= expr:e1 BARBAR expr:e2
									{: RESULT = new Or(e1, e2, e1left, e2right); :}
								|	or_error
									{: :}
								;

or_error						::= expr:e1 BARBAR:b epsilon
									{: Error.expect("Or", " e2", e1left, bright, "e<sub>2</sub>" ); :}
								;

condition						::= IF:i seq_expr:e0 THEN seq_expr:e1 ELSE seq_expr:e2
									{: RESULT = new Condition(e0, e1, e2, ileft, e2right); :}
								|	condition_error
									{: :}
								;

condition_error					::= IF:i epsilon
									{: Error.expect("Condition", " e0 then e1 else e2", ileft, iright, "e<sub>0</sub> then e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr:e epsilon
									{: Error.expect("Condition", " then e1 else e2", ileft, eright, "then e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr THEN:t epsilon
									{: Error.expect("Condition", " e1 else e2", ileft, tright, "e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr THEN seq_expr:e epsilon
									{: Error.expect("Condition", " else e2", ileft, eright, "else e<sub>2</sub>" ); :}
								|	IF:i seq_expr THEN seq_expr ELSE:e epsilon
									{: Error.expect("Condition", " e2", ileft, eright, "e<sub>2</sub>" ); :}
								// Missing e0
								|	IF:i THEN
									{: Error.expect("Condition", " e0 ", ileft, iright, "e<sub>0</sub>" ); :}
								// Missing e1
								|	IF:i seq_expr THEN:t ELSE
									{: Error.expect("Condition", " e1 ", ileft, tright, "e1" ); :}
								// Missing e0 and then
								|	IF:i seq_expr ELSE
									{: Error.expect("Condition", " e0 then ", ileft, iright, "e0 then" ); :}
								// Missing e0, then and e1
								|	IF:i ELSE
									{: Error.expect("Condition", " e0 then e1 ", ileft, iright, "e0 then e1" ); :}
								;

lambda							::= LAMBDA:l IDENTIFIER:id DOT seq_expr:e
									{: RESULT = new Lambda(new Identifier (id,idleft,idright), null, e, lleft, eright); :}
								|	LAMBDA:l IDENTIFIER:id COLON type:tau DOT seq_expr:e
									{: RESULT = new Lambda(new Identifier (id,idleft,idright), tau, e, lleft, eright); :}
								|	lambda_error
									{: :}
								;

lambda_error					::= LAMBDA:l epsilon
									{: Error.expect("Lambda", " id.e", lleft, lright, "id.e", "id: \u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER:i epsilon
									{: Error.expect("Lambda", ".e", lleft, iright, ".e", ": \u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER DOT:d epsilon
									{: Error.expect("Lambda", "e", lleft, dright, "e" ); :}
								|	LAMBDA:l IDENTIFIER COLON:c epsilon
									{: Error.expect("Lambda", " \u03C4.e", lleft, cright, "\u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER COLON type:t epsilon
									{: Error.expect("Lambda", ".e", lleft, tright, ".e" ); :}
								|	LAMBDA:l IDENTIFIER COLON type DOT:d epsilon
									{: Error.expect("Lambda", "e", lleft, dright, "e" ); :}
								// Missing identifier
								|	LAMBDA:l DOT
									{: Error.expect("Lambda", " id", lleft, lright, "id" ); :}
								|	LAMBDA:l COLON
									{: Error.expect("Lambda", " id", lleft, lright, "id" ); :}
								// Missing dot
								|	LAMBDA:l IDENTIFIER:id seq_expr
									{: Error.expect("Lambda", ".", lleft, idright, "." ); :}
								|	LAMBDA:l IDENTIFIER COLON type:tau seq_expr
									{: Error.expect("Lambda", ".", lleft, tauright, "." ); :}
								// Missing colon
								|	LAMBDA:l IDENTIFIER:id type
									{: Error.expect("Lambda", ": ", lleft, idright, ":" ); :}
								// Missing type
								|	LAMBDA:l IDENTIFIER COLON:c DOT
									{: Error.expect("Lambda", " \u03C4", lleft, cright, "\u03C4" ); :}
								// Missing identifier and colon
								|	LAMBDA:l type
									{: Error.expect("Lambda", " id: ", lleft, lright, "id:" ); :}
								// Missing type and dot
								|	LAMBDA:l IDENTIFIER COLON:c seq_expr:e
									{: Error.expect("Lambda", " \u03C4.", lleft, cright, "\u03C4." ); :}
								;

let								::= LET:l IDENTIFIER:id EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new Let(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
								|	LET:l IDENTIFIER:id COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new Let(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
								|	let_error
									{: :}
								;

let_error						::= LET:l epsilon
									{: Error.expect("Let", " id = e1 in e2", lleft, lright, "id = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER:i epsilon
									{: Error.expect("Let", " = e1 in e2", lleft, iright, "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l IDENTIFIER COLON:c epsilon
									{: Error.expect("Let", " \u03C4 = e1 in e2", lleft, cright, "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}	
								|	LET:l IDENTIFIER COLON type:t epsilon
									{: Error.expect("Let", " = e1 in e2", lleft, tright, "= e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l IDENTIFIER COLON type EQUAL:e epsilon
									{: Error.expect("Let", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER COLON type EQUAL seq_expr:e epsilon
									{: Error.expect("Let", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER COLON type EQUAL seq_expr IN:i epsilon
									{: Error.expect("Let", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL:e epsilon
									{: Error.expect("Let", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL seq_expr:e epsilon
									{: Error.expect("Let", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL seq_expr IN:i epsilon
									{: Error.expect("Let", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								// Missing identifier
								|	LET:l EQUAL
									{: Error.expect("Let", " id ", lleft, lright, "id" ); :}
								|	LET:l COLON
									{: Error.expect("Let", " id ", lleft, lright, "id" ); :}
								// Missing equal							
								|	LET:l IDENTIFIER COLON type:tau seq_expr
									{: Error.expect("Let", " = ", lleft, tauright, "=" ); :}
								// Missing colon
								|	LET:l IDENTIFIER:id type
									{: Error.expect("Let", ": ", lleft, idright, ":" ); :}
								// Missing type
								|	LET:l IDENTIFIER COLON:c EQUAL
									{: Error.expect("Let", " \u03C4 ", lleft, cright, "\u03C4" ); :}
								// Missing e1
								|	LET:l IDENTIFIER EQUAL:e IN
									{: Error.expect("Let", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								|	LET:l IDENTIFIER COLON type EQUAL:e IN
									{: Error.expect("Let", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								// Missing equal and e1
								|	LET:l IDENTIFIER:id IN
									{: Error.expect("Let", " = e1 ", lleft, idright, "= e<sub>1</sub>" ); :}
								|	LET:l IDENTIFIER COLON type:tau IN
									{: Error.expect("Let", " = e1 ", lleft, tauright, "= e<sub>1</sub>" ); :}
								// Missing identifier and colon
								|	LET:l type
									{: Error.expect("Let", " id: ", lleft, lright, "id:" ); :}
								// Missing type and equal
								|	LET:l IDENTIFIER COLON:c seq_expr
									{: Error.expect("Let", " \u03C4 = ", lleft, cright, "\u03C4 =" ); :}
								// Missing identifier, equal and e1
								|	LET:l IN
									{: Error.expect("Let", " id = e1 ", lleft, lright, "id = e<sub>1</sub>" ); :}
								// Missing type, equal and e1
								|	LET:l IDENTIFIER COLON:c IN
									{: Error.expect("Let", " \u03C4 = e1 ", lleft, cright, "\u03C4 = e<sub>1</sub>" ); :}
								;

curried_let						::= LET:l IDENTIFIER:id curried_let_list:itl EQUAL seq_expr:e1 IN seq_expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].getId();
									     types[n + 1] = itl[n].getTau();
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	LET:l IDENTIFIER:id curried_let_list:itl COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].getId();
									     types[n + 1] = itl[n].getTau();
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   types[0] = tau;
									   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	curried_let_error
									{: :}
								;

curried_let_error				::= LET:l IDENTIFIER curried_let_list:c epsilon
									{: Error.expect("Curried-Let", " = e1 in e2", lleft, cright, "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON:c epsilon
									{: Error.expect("Curried-Let", " \u03C4 = e1 in e2", lleft, cright, "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type:t epsilon
									{: Error.expect("Curried-Let", " = e1 in e2", lleft, tright, "= e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL:e epsilon
									{: Error.expect("Curried-Let", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL seq_expr:e epsilon
									{: Error.expect("Curried-Let", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL seq_expr IN:i epsilon
									{: Error.expect("Curried-Let", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL:e epsilon
									{: Error.expect("Curried-Let", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL seq_expr:e epsilon
									{: Error.expect("Curried-Let", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL seq_expr IN:i epsilon
									{: Error.expect("Curried-Let", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								// Missing e1
								|	LET:l IDENTIFIER curried_let_list EQUAL:e IN
									{: Error.expect("Curried-Let", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL:e IN
									{: Error.expect("Curried-Let", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}									
								// Missing colon
								|	LET:l IDENTIFIER curried_let_list:cll type
									{: Error.expect("Curried-Let", ": ", lleft, cllright, ":" ); :}								
								// Missing type
								|	LET:l IDENTIFIER curried_let_list COLON:c EQUAL
									{: Error.expect("Curried-Let", " \u03C4 ", lleft, cright, "\u03C4" ); :}
								// Missing equal
								|	LET:l IDENTIFIER curried_let_list COLON type:tau seq_expr
									{: Error.expect("Curried-Let", " = ", lleft, tauright, "=" ); :}
								// Missing equal and e1
								|	LET:l IDENTIFIER curried_let_list:cll IN
									{: Error.expect("Curried-Let", " = e1 ", lleft, cllright, "= e<sub>1</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type:tau IN
									{: Error.expect("Curried-Let", " = e1 ", lleft, tauright, "= e<sub>1</sub>" ); :}
								// Missing type and equal
								|	LET:l IDENTIFIER curried_let_list COLON:c seq_expr
									{: Error.expect("Curried-Let", " \u03C4 = ", lleft, cright, "\u03C4 =" ); :}
								// Missing type, equal and e1	
								|	LET:l IDENTIFIER curried_let_list COLON:c IN
									{: Error.expect("Curried-Let", " \u03C4 = e1 ", lleft, cright, "\u03C4 = e<sub>1</sub>" ); :}
								;

curried_let_list				::= curried_let_list:l curried_let_pair:p
									{: 
									   RESULT = new IdentifierTypePair[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = p;
									:}
								|	curried_let_pair:p
									{: RESULT = new IdentifierTypePair[] { p }; :}
								;

curried_let_pair				::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), tau); :}
								|	IDENTIFIER:id
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), null); :}
								|	curried_let_pair_error
									{: :}
								;

curried_let_pair_error			::= LPAREN:l epsilon
									{: Error.expect("Curried-Let", "id: \u03C4)", lleft, lright, "id: \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER:i epsilon
									{: Error.expect("Curried-Let", ": \u03C4)", lleft, iright, ": \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON:c epsilon
									{: Error.expect("Curried-Let", " \u03C4)", lleft, cright, "\u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON type:t epsilon
									{: Error.expect("Curried-Let", ")", lleft, tright, ")" ); :}
								// Missing type
								|	LPAREN:l IDENTIFIER COLON:c RPAREN
									{: Error.expect("Curried-Let", " \u03C4", lleft, cright, "\u03C4" ); :}
								;

coercion						::= LPAREN:l seq_expr:e COLON type:tau1 SUBTYPE type:tau2 RPAREN:r
									{: RESULT = new Coercion (e, tau1, tau2, lleft, rright); :}
								|	coercion_error
									{: :}
								;

coercion_error					::= LPAREN:l seq_expr COLON:c
									{: Error.expect("Coercion", " \u03C4 <: \u03C4)", lleft, cright, "\u03C4 &lt: \u03C4)" ); :}
								|	LPAREN:l seq_expr COLON type:tau1
									{: Error.expect("Coercion", " <: \u03C4)", lleft, tau1right, "&lt: \u03C4)" ); :}
								|	LPAREN:l seq_expr COLON type SUBTYPE:s
									{: Error.expect("Coercion", " \u03C4)", lleft, sright, "\u03C4)" ); :}
								|	LPAREN:l seq_expr COLON type SUBTYPE type:tau2
									{: Error.expect("Coercion", ")", lleft, tau2right, ")" ); :}
								// Missing colon
								|	LPAREN:l seq_expr:e type
									{: Error.expect("Coercion", ": ", lleft, eright, ":" ); :}
								// Missing type 1
								|	LPAREN:l seq_expr COLON:c SUBTYPE
									{: Error.expect("Coercion", " \u03C4 ", lleft, cright, "\u03C4" ); :}
								// Missing subtype
								|	LPAREN:l seq_expr COLON type:tau1 type
									{: Error.expect("Coercion", " <: ", lleft, tau1right, "&lt:" ); :}
								// Missing type 2
								|	LPAREN:l seq_expr COLON type SUBTYPE:s RPAREN
									{: Error.expect("Coercion", " \u03C4", lleft, sright, "\u03C4" ); :}
								// Missing colon and type 1
								|	LPAREN:l seq_expr:e SUBTYPE
									{: Error.expect("Coercion", ": \u03C4 ", lleft, eright, ": \u03C4" ); :}
								// Missing subtyping and type 2
								|	LPAREN:l seq_expr COLON type:tau1 RPAREN
									{: Error.expect("Coercion", " <: \u03C4", lleft, tau1right, "&lt: \u03C4" ); :}
								// Missing type 1, subtyping and type 2
								|	LPAREN:l seq_expr COLON:c RPAREN
									{: Error.expect("Coercion", " \u03C4 <: \u03C4", lleft, cright, "\u03C4 &lt: \u03C4" ); :}
								;

recursion						::= REC:r IDENTIFIER:id DOT seq_expr:e
									{: RESULT = new Recursion(new Identifier (id,idleft,idright), null, e, rleft, eright); :}
								|	REC:r IDENTIFIER:id COLON type:tau DOT seq_expr:e
									{: RESULT = new Recursion(new Identifier (id,idleft,idright), tau, e, rleft, eright); :}
								|	recursion_error
									{: :}					
								;

recursion_error					::= REC:r epsilon
									{: Error.expect("Recursion", " id.e", rleft, rright, "id.e", "id: \u03C4.e" ); :}
								|	REC:r IDENTIFIER:i epsilon
									{: Error.expect("Recursion", ".e", rleft, iright, ".e", ": \u03C4.e" ); :}
								|	REC:r IDENTIFIER COLON:c epsilon
									{: Error.expect("Recursion", " \u03C4.e", rleft, cright, "\u03C4.e" ); :}
								|	REC:r IDENTIFIER COLON type:t epsilon
									{: Error.expect("Recursion", ".e", rleft, tright, ".e" ); :}
								|	REC:r IDENTIFIER COLON type DOT:d epsilon
									{: Error.expect("Recursion", "e", rleft, dright, "e" ); :}
								|	REC:r IDENTIFIER DOT:d epsilon
									{: Error.expect("Recursion", "e", rleft, dright, "e" ); :}
								// Missing identifier
								|	REC:r DOT
									{: Error.expect("Recursion", " id", rleft, rright, "id" ); :}
								|	REC:r COLON
									{: Error.expect("Recursion", " id", rleft, rright, "id" ); :}
								// Missing dot
								|	REC:r IDENTIFIER:id seq_expr
									{: Error.expect("Recursion", ".", rleft, idright, "." ); :}
								|	REC:r IDENTIFIER COLON type:tau seq_expr
									{: Error.expect("Recursion", ".", rleft, tauright, "." ); :}
								// Missing colon
								|	REC:r IDENTIFIER:id type
									{: Error.expect("Recursion", ": ", rleft, idright, ":" ); :}
								// Missing type
								|	REC:r IDENTIFIER COLON:c DOT
									{: Error.expect("Recursion", " \u03C4", rleft, cright, "\u03C4" ); :}
								// Missing identifier and dot
								|	REC:r seq_expr:e
									{: Error.expect("Recursion", " id.", rleft, rright, "id." ); :}
								// Missing identifier and colon
								|	REC:r type
									{: Error.expect("Recursion", " id: ", rleft, rright, "id:" ); :}
								// Missing type and dot
								|	REC:r IDENTIFIER COLON:c seq_expr:e
									{: Error.expect("Recursion", " \u03C4.", rleft, cright, "\u03C4." ); :}			
								;

let_rec							::= LET:l REC IDENTIFIER:id EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new LetRec(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
								|	LET:l REC IDENTIFIER:id COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new LetRec(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
								|	let_rec_error
									{: :}				
								;

let_rec_error					::= LET:l REC:r epsilon
									{: Error.expect("Let-Rec", " id = e1 in e2", lleft, rright, "id = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER:i epsilon
									{: Error.expect("Let-Rec", " = e1 in e2", lleft, iright, "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l REC IDENTIFIER COLON:c epsilon
									{: Error.expect("Let-Rec", " \u03C4 = e1 in e2", lleft, cright, "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}	
								|	LET:l REC IDENTIFIER COLON type:t epsilon
									{: Error.expect("Let-Rec", " = e1 in e2", lleft, tright, "= e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l REC IDENTIFIER COLON type EQUAL:e epsilon
									{: Error.expect("Let-Rec", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type EQUAL seq_expr:e epsilon
									{: Error.expect("Let-Rec", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type EQUAL seq_expr IN:i epsilon
									{: Error.expect("Let-Rec", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL:e epsilon
									{: Error.expect("Let-Rec", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL seq_expr:e epsilon
									{: Error.expect("Let-Rec", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL seq_expr IN:i epsilon
									{: Error.expect("Let-Rec", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								// Missing identifier
								|	LET:l REC:r EQUAL
									{: Error.expect("Let-Rec", " id ", lleft, rright, "id" ); :}
								|	LET:l REC:r COLON
									{: Error.expect("Let-Rec", " id ", lleft, rright, "id" ); :}
								// Missing equal							
								|	LET:l REC IDENTIFIER COLON type:tau seq_expr
									{: Error.expect("Let-Rec", " = ", lleft, tauright, "=" ); :}
								// Missing colon
								|	LET:l REC IDENTIFIER:id type
									{: Error.expect("Let-Rec", ": ", lleft, idright, ":" ); :}
								// Missing type
								|	LET:l REC IDENTIFIER COLON:c EQUAL
									{: Error.expect("Let-Rec", " \u03C4 ", lleft, cright, "\u03C4" ); :}
								// Missing e1
								|	LET:l REC IDENTIFIER EQUAL:e IN
									{: Error.expect("Let-Rec", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type EQUAL:e IN
									{: Error.expect("Let-Rec", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								// Missing equal and e1
								|	LET:l REC IDENTIFIER:id IN
									{: Error.expect("Let-Rec", " = e1 ", lleft, idright, "= e<sub>1</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type:tau IN
									{: Error.expect("Let-Rec", " = e1 ", lleft, tauright, "= e<sub>1</sub>" ); :}
								// Missing identifier and colon
								|	LET:l REC:r type
									{: Error.expect("Let-Rec", " id: ", lleft, rright, "id:" ); :}
								// Missing type and equal
								|	LET:l REC IDENTIFIER COLON:c seq_expr
									{: Error.expect("Let-Rec", " \u03C4 = ", lleft, cright, "\u03C4 =" ); :}
								// Missing identifier, equal and e1
								|	LET:l REC:r IN
									{: Error.expect("Let-Rec", " id = e1 ", lleft, rright, "id = e<sub>1</sub>" ); :}
								// Missing type, equal and e1
								|	LET:l REC IDENTIFIER COLON:c IN
									{: Error.expect("Let-Rec", " \u03C4 = e1 ", lleft, cright, "\u03C4 = e<sub>1</sub>" ); :}
								// Missing identifier and equal
								|	LET:l REC:r seq_expr
									{: Error.expect("Let-Rec", " id = ", lleft, rright, "id =" ); :}
								;

curried_let_rec					::=	LET:l REC IDENTIFIER:id curried_let_rec_list:itl EQUAL seq_expr:e1 IN seq_expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].getId();
									     types[n + 1] = itl[n].getTau();
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	LET:l REC IDENTIFIER:id curried_let_rec_list:itl COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].getId();
									     types[n + 1] = itl[n].getTau();
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   types[0] = tau;
									   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	curried_let_rec_error
									{: :}
								;

curried_let_rec_error			::= LET:l REC IDENTIFIER curried_let_rec_list:c epsilon
									{: Error.expect("Curried-Let-Rec", " = e1 in e2", lleft, cright, "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON:c epsilon
									{: Error.expect("Curried-Let-Rec", " \u03C4 = e1 in e2", lleft, cright, "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type:t epsilon
									{: Error.expect("Curried-Let-Rec", " = e1 in e2", lleft, tright, "= e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL:e epsilon
									{: Error.expect("Curried-Let-Rec", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL seq_expr:e epsilon
									{: Error.expect("Curried-Let-Rec", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL seq_expr IN:i epsilon
									{: Error.expect("Curried-Let-Rec", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL:e epsilon
									{: Error.expect("Curried-Let-Rec", " e1 in e2", lleft, eright, "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL seq_expr:e epsilon
									{: Error.expect("Curried-Let-Rec", " in e2", lleft, eright, "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL seq_expr IN:i epsilon
									{: Error.expect("Curried-Let-Rec", " e2", lleft, iright, "e<sub>2</sub>" ); :}
								// Missing e1
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL:e IN
									{: Error.expect("Curried-Let-Rec", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL:e IN
									{: Error.expect("Curried-Let-Rec", " e1 ", lleft, eright, "e<sub>1</sub>" ); :}									
								// Missing colon
								|	LET:l REC IDENTIFIER curried_let_rec_list:cll type
									{: Error.expect("Curried-Let-Rec", ": ", lleft, cllright, ":" ); :}								
								// Missing type
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON:c EQUAL
									{: Error.expect("Curried-Let-Rec", " \u03C4 ", lleft, cright, "\u03C4" ); :}
								// Missing equal
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type:tau seq_expr
									{: Error.expect("Curried-Let-Rec", " = ", lleft, tauright, "=" ); :}
								// Missing equal and e1
								|	LET:l REC IDENTIFIER curried_let_rec_list:cll IN
									{: Error.expect("Curried-Let-Rec", " = e1 ", lleft, cllright, "= e<sub>1</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type:tau IN
									{: Error.expect("Curried-Let-Rec", " = e1 ", lleft, tauright, "= e<sub>1</sub>" ); :}
								// Missing type and equal
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON:c seq_expr
									{: Error.expect("Curried-Let-Rec", " \u03C4 = ", lleft, cright, "\u03C4 =" ); :}
								// Missing type, equal and e1	
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON:c IN
									{: Error.expect("Curried-Let-Rec", " \u03C4 = e1 ", lleft, cright, "\u03C4 = e<sub>1</sub>" ); :}
								;

curried_let_rec_list			::= curried_let_rec_list:l curried_let_rec_pair:p
									{: 
									   RESULT = new IdentifierTypePair[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = p;
									:}
								|	curried_let_rec_pair:p
									{: RESULT = new IdentifierTypePair[] { p }; :}
								;

curried_let_rec_pair			::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), tau); :}
								|	IDENTIFIER:id
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), null); :}
								|	curried_let_rec_pair_error
									{: :}
								;

curried_let_rec_pair_error		::= LPAREN:l epsilon
									{: Error.expect("Curried-Let-Rec", "id: \u03C4)", lleft, lright, "id: \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER:i epsilon
									{: Error.expect("Curried-Let-Rec", ": \u03C4)", lleft, iright, ": \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON:c epsilon
									{: Error.expect("Curried-Let-Rec", " \u03C4)", lleft, cright, "\u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON type:t epsilon
									{: Error.expect("Curried-Let-Rec", ")", lleft, tright, ")" ); :}
								// Missing type
								|	LPAREN:l IDENTIFIER COLON:c RPAREN
									{: Error.expect("Curried-Let-Rec", " \u03C4", lleft, cright, "\u03C4" ); :}
								;

object_expr						::= OBJECT:o LPAREN SELF:id RPAREN END:end
									{:
									   Expression [] e = new Expression [0];
						  			   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), null, new Row (e), oleft, endright);
						  			:}
								|   OBJECT:o LPAREN SELF:id COLON type:tau RPAREN END:end
									{: 
									   Expression [] e = new Expression [0];
								       RESULT = new ObjectExpr (new Identifier (id,idleft,idright), tau, new Row (e), oleft, endright);
								    :}
								|	OBJECT:o LPAREN SELF:id RPAREN row:r END:end
									{:
									   MultipleIdentifier.check(r);
						   			   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), null, r, oleft, endright);
						   			:}
								|	OBJECT:o LPAREN SELF:id COLON type:tau RPAREN row:r END:end
									{:
									   MultipleIdentifier.check(r);
						   			   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), tau, r, oleft, endright);
						   			:}
								|	object_expr_error
									{: :}
								;

object_expr_error				::= OBJECT:o epsilon
									{: Error.expect("Object", " (self) end", oleft, oright, "(self) r end", "(self: \u03C4) r end"); :}
								|	OBJECT:o LPAREN:l epsilon
									{: Error.expect("Object", "self) end", oleft, lright, "self) r end", "self: \u03C4) r end"); :}
								|	OBJECT:o LPAREN SELF:s epsilon
									{: Error.expect("Object", ") end", oleft, sright, ") r end", ": \u03C4) r end"); :}
								|	OBJECT:o LPAREN SELF COLON:c epsilon
									{: Error.expect("Object", " \u03C4) end", oleft, cright, "\u03C4) r end"); :}
								|	OBJECT:o LPAREN SELF COLON type:t epsilon
									{: Error.expect("Object", ") end", oleft, tright, ") r end"); :}
								|	OBJECT:o LPAREN SELF COLON type RPAREN:r epsilon
									{: Error.expect("Object", " end", oleft, rright, "r end"); :}
								|	OBJECT:o LPAREN SELF COLON type RPAREN row:r epsilon
									{: Error.expect("Object", " end", oleft, rright, "end", "r end"); :}	
								|	OBJECT:o LPAREN SELF RPAREN:r epsilon
									{: Error.expect("Object", " end", oleft, rright, "r end"); :}	
								|	OBJECT:o LPAREN SELF RPAREN row:r epsilon
									{: Error.expect("Object", " end", oleft, rright, "end", "r end"); :}
								// Missing type
								|   OBJECT:o LPAREN SELF COLON:c RPAREN
									{: Error.expect("Object", " \u03C4", oleft, cright, "\u03C4" ); :}
								// Missing left bracket
								|	OBJECT:o SELF
									{: Error.expect("Object", " (", oleft, oright, "(" ); :}
								// Missing right bracket
								|	OBJECT:o LPAREN SELF COLON type:t END
									{: Error.expect("Object", ") ", oleft, tright, ")" ); :}
								|	OBJECT:o LPAREN SELF COLON type:t row
									{: Error.expect("Object", ") ", oleft, tright, ")" ); :}
								|	OBJECT:o LPAREN SELF:s END
									{: Error.expect("Object", ") ", oleft, sright, ")" ); :}
								|	OBJECT:o LPAREN SELF:s row
									{: Error.expect("Object", ") ", oleft, sright, ")" ); :}
								// Missing self
								|	OBJECT:o LPAREN:l RPAREN
									{: Error.expect("Object", "self", oleft, lright, "self" ); :}
								;

duplication						::= DUPLBEGIN:b duplication_list:l DUPLEND:e
									{: 
									   Expression [] tmpE = new Expression [l.length];
									   Identifier [] tmpI = new Identifier [l.length];
									   for ( int i = 0 ; i < l.length ; i++ )
									   {
									     tmpE [i] = l [i].getE();
									     tmpI [i] = l [i].getId();
									     tmpI [i].setSet (Identifier.Set.ATTRIBUTE );
									   }
									   Duplication d = new Duplication (tmpI, tmpE, bleft, eright);
									   MultipleIdentifier.check(d);
									   RESULT = d;
									:}
								|	DUPLBEGIN:b DUPLEND:e
									{: 
									   Expression [] tmpE = new Expression [0];
									   Identifier [] tmpI = new Identifier [0];
									   RESULT = new Duplication (tmpI, tmpE, bleft, eright);
									:}
								|	 duplication_error
									{: :}
								;

duplication_error				::= DUPLBEGIN:d epsilon
									{: Error.expect("Duplication", " a = e >}", dleft, dright , "a<sub>1</sub> = e<sub>1</sub>; ... ; a<sub>n</sub> = e<sub>n</sub> >}"); :}
								|	DUPLBEGIN:d duplication_list:dl epsilon
									{: Error.expect("Duplication", " >}", dleft, dlright , ">}"); :}	
								;

duplication_list				::= duplication_list:l SEMI duplication_pair:p
									{: 
									   IdentifierExpressionPair [] list = new IdentifierExpressionPair [l.length+1];
									   System.arraycopy(l, 0, list, 0, l.length);
									   list [l.length] = p;
									   RESULT = list;
									:}
								|	duplication_pair:p
									{: 
									   IdentifierExpressionPair [] list = new IdentifierExpressionPair [1];
									   list [0] = p;
									   RESULT = list;
									:}
								|	duplication_list_error
									{: :}
								;

duplication_list_error			::= duplication_list:d SEMI:s epsilon
									{: Error.expect("Duplication", " an = en >}", dleft, sright, "... a<sub>n</sub> = e<sub>n</sub> >}"); :}
								;

duplication_pair				::= IDENTIFIER:id EQUAL expr:e
									{: RESULT = new IdentifierExpressionPair (new Identifier (id,idleft,idright), e); :}
								|	duplication_pair_error
									{: :}
								;

duplication_pair_error			::= IDENTIFIER:i epsilon
									{: Error.expect("Duplication", " = e >}", ileft, iright, "= e; ... ; a<sub>n</sub> = e<sub>n</sub> >}"); :}
								|	IDENTIFIER:i EQUAL:e epsilon
									{: Error.expect("Duplication", " e >}", ileft, eright, "e; ... ; a<sub>n</sub> = e<sub>n</sub> >}"); :}
								;

send							::= simple_expr:e HASHKEY IDENTIFIER:id
									{:
									   Identifier idM = new Identifier (id,idleft,idright) ;
									   idM.setSet (Identifier.Set.MESSAGE );
									   RESULT = new Send ( e, idM, eleft, idright) ;
									:}
								|	send_error
									{: :}
								;

send_error						::= simple_expr:s HASHKEY:h epsilon
									{: Error.expect("Send", " m", sleft, hright, "m"); :}	
								;

row								::= attribute:a
									{:
									   Expression [] e = new Expression [1];
									   e [0] = a;
									   RESULT = new Row (e, aleft, aright);
									:}
								|	attribute:a row:r
									{:
									   Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
									   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    								   e [0] = a ;
									   RESULT = new Row (e, aleft, rright);
									:}
								|	method:m
									{:
									   Expression [] e = new Expression [1];
									   e [0] = m;
									   RESULT = new Row (e, mleft, mright);
									:}
								|	method:m row:r
									{:
									   Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    								   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    								   e [0] = m ;
									   RESULT = new Row (e, mleft, rright);
									:}
								|	curried_method:cm
									{:
									   Expression [] e = new Expression [1];
									   e [0] = cm;
									   RESULT = new Row (e, cmleft, cmright);
									:}
								|	curried_method:cm row:r
									{:
									   Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    								   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    								   e [0] = cm ;
									   RESULT = new Row (e, cmleft, rright);
									:}
								;

attribute						::=	ATTRIBUTE:a IDENTIFIER:id EQUAL expr:e SEMI:s
									{:
									   Identifier idA = new Identifier (id,idleft,idright) ;
									   idA.setSet (Identifier.Set.ATTRIBUTE );
									   RESULT = new Attribute (idA, e, aleft, sright);
									:}
								|	attribute_error
									{: :}
								;

attribute_error					::= ATTRIBUTE:a epsilon
									{: Error.expect("Attribute", " a = e ;", aleft, aright, "a = e ;"); :}
								|	ATTRIBUTE:a IDENTIFIER:i epsilon
									{: Error.expect("Attribute", " = e ;", aleft, iright, "= e ;"); :}
								|	ATTRIBUTE:a IDENTIFIER EQUAL:e epsilon
									{: Error.expect("Attribute", " e ;", aleft, eright, "e ;"); :}
								|	ATTRIBUTE:a IDENTIFIER EQUAL expr:e epsilon
									{: Error.expect("Attribute", " ;", aleft, eright, ";"); :}
								// Missing identifier
								|	ATTRIBUTE:a EQUAL
									{: Error.expect("Attribute", " a ", aleft, aright, "a"); :}
								// Missing equal
								|	ATTRIBUTE:a IDENTIFIER:id expr
									{: Error.expect("Attribute", " = ", aleft, idright, "="); :}
								// Missing expression
								|	ATTRIBUTE:a IDENTIFIER EQUAL:e SEMI
									{: Error.expect("Attribute", " e ", aleft, eright, "e"); :}
								// Missing identifier and equal
								|	ATTRIBUTE:a expr
									{: Error.expect("Attribute", " a = ", aleft, aright, "a ="); :}
								// Missing equal and expression	
								|	ATTRIBUTE:a IDENTIFIER:id SEMI
									{: Error.expect("Attribute", " = e ", aleft, idright, "= e"); :}
								// Missing identifier, equal and expression
								|	ATTRIBUTE:a SEMI
									{: Error.expect("Attribute", " a = e ", aleft, aright, "a = e"); :}
								;

method							::=	METHOD:m IDENTIFIER:id EQUAL expr:e SEMI:s
									{:
									   Identifier idM = new Identifier (id,idleft,idright) ;
									   idM.setSet (Identifier.Set.MESSAGE );
									   RESULT = new Method (idM, null, e, mleft, sright);
									:}
								|	METHOD:m IDENTIFIER:id COLON type:tau EQUAL expr:e SEMI:s
									{:
									   Identifier idM = new Identifier (id,idleft,idright) ;
									   idM.setSet (Identifier.Set.MESSAGE );
									   RESULT = new Method (idM, tau, e, mleft, sright);
									:}
								|	method_error
									{: :}
								;

method_error					::=	METHOD:m epsilon
									{: Error.expect("Method", " m = e ;", mleft, mright, "m = e ;", "m: \u03C4 = e ;"); :}
								|	METHOD:m IDENTIFIER:i epsilon
									{: Error.expect("Method", " = e ;", mleft, iright, "= e ;", ": \u03C4 = e ;"); :}
								|	METHOD:m IDENTIFIER COLON:c epsilon
									{: Error.expect("Method", " \u03C4 = e ;", mleft, cright, "\u03C4 = e ;"); :}
								|	METHOD:m IDENTIFIER COLON type:t epsilon
									{: Error.expect("Method", " = e ;", mleft, tright, "= e ;"); :}
								|	METHOD:m IDENTIFIER COLON type EQUAL:e epsilon
									{: Error.expect("Method", " e ;", mleft, eright, "e ;"); :}
								|	METHOD:m IDENTIFIER COLON type EQUAL expr:e epsilon
									{: Error.expect("Method", " ;", mleft, eright, ";"); :}
								|	METHOD:m IDENTIFIER EQUAL:e epsilon
									{: Error.expect("Method", " e ;", mleft, eright, "e ;"); :}
								|	METHOD:m IDENTIFIER EQUAL expr:e epsilon
									{: Error.expect("Method", " ;", mleft, eright, ";"); :}
								// Missing identifier
								|	METHOD:m EQUAL
									{: Error.expect("Method", " m ", mleft, mright, "m"); :}
								|	METHOD:m COLON
									{: Error.expect("Method", " m", mleft, mright, "m" ); :}
								// Missing colon
								|	METHOD:m IDENTIFIER:id type
									{: Error.expect("Method", ": ", mleft, idright, ":" ); :}
								// Missing type
								|	METHOD:m IDENTIFIER COLON:c EQUAL
									{: Error.expect("Method", " \u03C4 ", mleft, cright, "\u03C4" ); :}
								// Missing equal
								|	METHOD:m IDENTIFIER COLON type:tau expr
									{: Error.expect("Method", " = ", mleft, tauright, "=" ); :}
								// Missing expression
								|	METHOD:m IDENTIFIER EQUAL:e SEMI
									{: Error.expect("Method", " e ", mleft, eright, "e" ); :}
								|	METHOD:m IDENTIFIER COLON type EQUAL:e SEMI
									{: Error.expect("Method", " e ", mleft, eright, "e" ); :}
								// Missing identifier and equal
								|	METHOD:m expr SEMI
									{: Error.expect("Method", " id = ", mleft, mright, "id =" ); :}
								// Missing equal and expression
								|	METHOD:m IDENTIFIER:id SEMI
									{: Error.expect("Method", " = e ", mleft, idright, "= e" ); :}
								|	METHOD:m IDENTIFIER COLON type:tau SEMI
									{: Error.expect("Method", " = e ", mleft, tauright, "= e" ); :}
								// Missing identifier and colon
								|	METHOD:m type
									{: Error.expect("Method", " m: ", mleft, mright, "m:" ); :}
								// Missing type and equal
								|	METHOD:m IDENTIFIER COLON:c expr
									{: Error.expect("Method", " \u03C4 = ", mleft, cright, "\u03C4 =" ); :}
								// Missing identifier, equal and expression
								|	METHOD:m SEMI
									{: Error.expect("Method", " m = e ", mleft, mright, "m = e"); :}
								// Missing type, equal and expression
								|	METHOD:m IDENTIFIER COLON:c SEMI
									{: Error.expect("Method", " \u03C4 = e ", mleft, cright, "\u03C4 = e"); :}
								;

curried_method					::=	METHOD:m IDENTIFIER:id curried_method_list:l EQUAL expr:e SEMI:s
									{:
									   Identifier[] identifiers = new Identifier[l.length + 1];
									   MonoType[] types = new MonoType[l.length + 1 ];
									   for (int n = 0; n < l.length; n++) 
									   {
									     identifiers[n + 1] = l[n].getId();
									     types[n + 1] = l[n].getTau();
									   }
									   Identifier idM = new Identifier (id,idleft,idright) ;
									   idM.setSet (Identifier.Set.MESSAGE );
									   identifiers [0] = idM ;
									   types [0] = null ;
									   RESULT = new CurriedMethod(identifiers, types, e, mleft, sright);
									:}
								|	METHOD:m IDENTIFIER:id curried_method_list:l COLON type:tau EQUAL expr:e SEMI:s
									{:
									   Identifier[] identifiers = new Identifier[l.length + 1];
									   MonoType[] types = new MonoType[l.length + 1 ];
									   for (int n = 0; n < l.length; n++) 
									   {
									     identifiers[n + 1] = l[n].getId();
									     types[n + 1] = l[n].getTau();
									   }
									   Identifier idM = new Identifier (id,idleft,idright) ;
									   idM.setSet (Identifier.Set.MESSAGE );
									   identifiers [0] = idM ;
									   types [0] = tau ;
									   RESULT = new CurriedMethod (identifiers, types, e, mleft, sright);
									:}
								|	curried_method_error
									{: :}
								;	   

curried_method_error			::= METHOD:m IDENTIFIER curried_method_list:c epsilon
									{: Error.expect("Curried-Method", " = e ;", mleft, cright, "= e ;", ": \u03C4 = e ;"); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON:c epsilon
									{: Error.expect("Curried-Method", " \u03C4 = e ;", mleft, cright, "\u03C4 = e ;"); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type:t epsilon
									{: Error.expect("Curried-Method", " = e ;", mleft, tright, "= e ;"); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type EQUAL:e epsilon
									{: Error.expect("Curried-Method", " e ;", mleft, eright, "e ;"); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type EQUAL expr:e epsilon
									{: Error.expect("Curried-Method", " ;", mleft, eright, ";"); :}
								|	METHOD:m IDENTIFIER curried_method_list EQUAL:e epsilon
									{: Error.expect("Curried-Method", " e ;", mleft, eright, "e ;"); :}
								|	METHOD:m IDENTIFIER curried_method_list EQUAL expr:e epsilon
									{: Error.expect("Curried-Method", " ;", mleft, eright, ";"); :}
								// Missing colon
								|	METHOD:m IDENTIFIER curried_method_list:l type
									{: Error.expect("Curried-Method", ": ", mleft, lright, ":"); :}									
								// Missing type
								|	METHOD:m IDENTIFIER curried_method_list COLON:c EQUAL
									{: Error.expect("Curried-Method", " \u03C4 ", mleft, cright, "\u03C4" ); :}
								// Missing equal
								|	METHOD:m IDENTIFIER curried_method_list:l expr
									{: Error.expect("Curried-Method", " = ", mleft, lright, "=" ); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type:tau expr
									{: Error.expect("Curried-Method", " = ", mleft, tauright, "=" ); :}
								// Missing expression
								|	METHOD:m IDENTIFIER curried_method_list EQUAL:e SEMI
									{: Error.expect("Curried-Method", " e ", mleft, eright, "e" ); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type EQUAL:e SEMI
									{: Error.expect("Curried-Method", " e ", mleft, eright, "e" ); :}
								// Missing equal and expression
								|	METHOD:m IDENTIFIER curried_method_list:l SEMI
									{: Error.expect("Curried-Method", " = e ", mleft, lright, "= e" ); :}
								|	METHOD:m IDENTIFIER curried_method_list COLON type:tau SEMI
									{: Error.expect("Curried-Method", " = e ", mleft, tauright, "= e" ); :}
								// Missing type and equal
								|	METHOD:m IDENTIFIER curried_method_list COLON:c expr
									{: Error.expect("Curried-Method", " \u03C4 = ", mleft, cright, "\u03C4 =" ); :}
								// Missing type, equal and expression
								|	METHOD:m IDENTIFIER curried_method_list COLON:c SEMI
									{: Error.expect("Curried-Method", " \u03C4 = e ", mleft, cright, "\u03C4 = e"); :}																							
								;

curried_method_list				::= curried_method_list:l curried_method_pair:p
									{: 
									   RESULT = new IdentifierTypePair[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = p;
									:}
								|	curried_method_pair:p
									{: RESULT = new IdentifierTypePair[] { p }; :}
								;

curried_method_pair				::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), tau); :}
								|	IDENTIFIER:id
									{: RESULT = new IdentifierTypePair(new Identifier (id,idleft,idright), null); :}
								|	curried_method_pair_error
									{: :}
								;

curried_method_pair_error		::= LPAREN:l epsilon
									{: Error.expect("Curried-Method", "id: \u03C4)", lleft, lright, "id: \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER:i epsilon
									{: Error.expect("Curried-Method", ": \u03C4)", lleft, iright, ": \u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON:c epsilon
									{: Error.expect("Curried-Method", " \u03C4)", lleft, cright, "\u03C4)" ); :}
								|	LPAREN:l IDENTIFIER COLON type:t epsilon
									{: Error.expect("Curried-Method", ")", lleft, tright, ")" ); :}
								// Missing type
								|	LPAREN:l IDENTIFIER COLON:c RPAREN
									{: Error.expect("Curried-Method", " \u03C4", lleft, cright, "\u03C4" ); :}
								;

class							::= CLASS:c LPAREN SELF:id RPAREN expr:e END:end
									{: RESULT = new Class (new Identifier (id,idleft,idright), e, cleft, endright); :}
								;

new								::= NEW:n expr:e
									{: RESULT = new New (e, nleft, eright); :}
								;

constant						::=	unit_constant:u
									{: RESULT = u; :}
								|	boolean_constant:b
									{: RESULT = b; :}
								|	integer_constant:i
									{: RESULT = i; :}
								|	not:n
									{: RESULT = n; :}
								;

unit_constant					::= PARENPAREN:u
									{: RESULT = new UnitConstant(uleft, uright); :}
								;

boolean_constant				::= TRUE:t
									{: RESULT = new BooleanConstant(true, tleft, tright); :}
								|	FALSE:f
									{: RESULT = new BooleanConstant(false, fleft, fright); :}
								;

integer_constant				::= NUMBER:n
									{: RESULT = new IntegerConstant(n.intValue(), nleft, nright); :}
								;

not								::= NOT:n
									{: RESULT = new Not(nleft, nright); :}
								;

operator						::=	arithmetic_operator:a
									{: RESULT = a; :}
								|	relational_operator:r
									{: RESULT = r; :}
								;

arithmetic_operator				::= PLUS:op		
									{: RESULT = ArithmeticOperator.newPlus(opleft, opright); :}
								|	MINUS:op		
									{: RESULT = ArithmeticOperator.newMinus(opleft, opright); :}
								|	STAR:op			
									{: RESULT = ArithmeticOperator.newMult(opleft, opright); :}
								|	SLASH:op			
									{: RESULT = ArithmeticOperator.newDiv(opleft, opright); :}
								|	MOD:op			
									{: RESULT = ArithmeticOperator.newMod(opleft, opright); :}
								;

relational_operator				::= EQUAL:op			
									{: RESULT = RelationalOperator.newEquals(opleft, opright); :}
								|	LESS:op			
									{: RESULT = RelationalOperator.newLowerThan(opleft, opright); :}
								|	GREATER:op		
									{: RESULT = RelationalOperator.newGreaterThan(opleft, opright); :}
								|	LESSEQUAL:op		
									{: RESULT = RelationalOperator.newLowerEqual(opleft, opright); :}
								|	GREATEREQUAL:op
									{: RESULT = RelationalOperator.newGreaterEqual(opleft, opright); :}
								;

simple_expr						::=	constant:c
									{: RESULT = c; :}
								|	identifier:id
									{: RESULT = id; :}
								|	LPAREN operator:o RPAREN
									{: RESULT = o; :}
								|	LPAREN seq_expr:e RPAREN
									{: RESULT = e; :}
								|	coercion:c
									{: RESULT = c; :}
								|	send:s
									{: RESULT = s; :}
								|	simple_expr_error
									{: :}
								;

simple_expr_error				::= LPAREN:l seq_expr:e epsilon
									{: Error.expect("Expression", ")", lleft, eright, ")"); :}
								|	LPAREN:l operator:o epsilon
									{: Error.expect("Operator", ")", lleft, oright, ")"); :}
								|	LPAREN:l epsilon
									{: Error.expect("Expression", "e)", lleft, lright, "... )"); :}
								;

simple_expr_list				::=	simple_expr:e
									{: RESULT = new Expression[] { e }; :}
								|	simple_expr_list:l simple_expr:e
									{:
									   RESULT = new Expression[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = e;
									:}
								;

epsilon							::= /* epsilon */
									{: :}	
								;


/*********
 * Types *
 *********/


type							::=	simple_type:t
									{: RESULT = t; :}
								|	arrow_type:a
									{: RESULT = a; :}
								;

simple_type						::=	LPAREN:l type:t RPAREN:r
									{: RESULT = t; :}
								|	boolean_type:b
									{: RESULT = b; :}
								|	integer_type:i
									{: RESULT = i; :}
								|	unit_type:u
									{: RESULT = u; :}
								|	type_variable:t
									{: RESULT = t; :}
								|	type_name:t
									{: RESULT = t; :}
								|	rec_type:r
									{: RESULT = r; :}
								|	object_type:t
									{: RESULT = t; :}
								|	simple_type_error
									{: :}
								;

simple_type_error				::= LPAREN:l epsilon
									{: Error.expect("Type", "\u03C4)", lleft, lright, "\u03C4)"); :}
								|	LPAREN:l type:t epsilon
									{: Error.expect("Type", ")", lleft, tright, ")"); :}
								;

arrow_type						::= type:t1 ARROW type:t2
									{: RESULT = new ArrowType(t1, t2, t1left, t2right); :}
								|	arrow_type_error
									{: :}
								;

arrow_type_error				::= type:t ARROW:a epsilon 
									{: Error.expect("Arrow-Type", " \u03C4", tleft, aright, "\u03C4<sub>2</sub>"); :}
								;

boolean_type					::= BOOL:b
									{: RESULT = new BooleanType(bleft, bright); :}
								;

integer_type					::= INT:i
									{: RESULT = new IntegerType(ileft, iright); :}
								;

unit_type						::= UNIT:u
									{: RESULT = new UnitType(uleft, uright); :}
								;

type_variable					::= TYPEVARIABLE:t
									{: RESULT = new TypeVariable(0, t, tleft, tright); :}
								;

type_name						::= IDENTIFIER:id
									{: RESULT = new TypeName(id, idleft, idright); :}
								;

rec_type						::= MU:m IDENTIFIER:id DOT type:t
									{: RESULT = new RecType(new TypeName(id, idleft, idright), t, mleft, tright); :}
								|	rec_type_error
									{: :}								
								;

rec_type_error					::= MU:m epsilon
									{: Error.expect("Rec-Type", " t.\u03C4", mleft, mright, "t.\u03C4"); :}
								|	MU:m IDENTIFIER:i epsilon
									{: Error.expect("Rec-Type", ".\u03C4", mleft, iright, ".\u03C4"); :}
								|	MU:m IDENTIFIER DOT:d epsilon
									{: Error.expect("Rec-Type", "\u03C4", mleft, dright, "\u03C4"); :}
								;

object_type						::= LESS:l row_type:r GREATER:g
									{: 
									   MultipleIdentifier.check(r);
									   RESULT = new ObjectType ( r, lleft, gright);
									:}
								|	LESS:l GREATER:g
									{:
									   Identifier [] m = new Identifier [0];
									   MonoType [] types = new MonoType [0];
									   RESULT = new ObjectType ( new RowType (m, types), lleft, gright);
									:}
								|	object_type_error
									{: :}
								;

object_type_error				::= LESS:l epsilon
									{: Error.expect("Object-Type", " m: \u03C4; >", lleft, lright, "m<sub>1</sub>: \u03C4; ... m<sub>n</sub>: \u03C4; >"); :}
								|	LESS:l row_type:r epsilon
									{: Error.expect("Object-Type", " >", lleft, rright, "... m<sub>n</sub>: \u03C4; >"); :}
								;

row_type						::= IDENTIFIER:id COLON type:tau SEMI:s
									{:
									   Identifier [] m = new Identifier [1];
									   m [0] = new Identifier (id,idleft,idright);
									   MonoType [] types = new MonoType [1];
									   types [0] = tau;
									   RESULT = new RowType (m, types, idleft, sright) ;
									:}
								|	IDENTIFIER:id COLON type:tau SEMI row_type:r
									{:
									   Identifier [] m = new Identifier [r.getIdentifiers().length + 1];
									   m [0] = new Identifier (id,idleft,idright);
									   System.arraycopy ( r.getIdentifiers() , 0 , m , 1 , r.getIdentifiers().length );
									   MonoType [] types = new MonoType [r.getTypes().length + 1];
									   types [0] = tau;
									   System.arraycopy ( r.getTypes() , 0 , types , 1 , r.getTypes().length );
									   RESULT = new RowType (m, types, idleft, rright) ;
									:}
								|	row_type_error
									{: :}
								;

row_type_error					::= IDENTIFIER:i epsilon
									{: Error.expect("Row-Type", ": \u03C4 ;", ileft, iright, ": \u03C4 ; ... m<sub>n</sub>: \u03C4 ;"); :}
								|	IDENTIFIER:i COLON:c epsilon
									{: Error.expect("Row-Type", " \u03C4 ;", ileft, cright, "\u03C4 ; ... m<sub>n</sub>: \u03C4 ;"); :}
								|	IDENTIFIER:i COLON type:t epsilon
									{: Error.expect("Row-Type", " ;", ileft, tright, "; ... m<sub>n</sub>: \u03C4 ;"); :}
								;