import de.unisiegen.tpml.core.expressions.*;
import de.unisiegen.tpml.core.types.*;


/* Helper class */
action code {:
  private static class IdTypePair 
  {
    public IdTypePair(Identifier id, MonoType tau) 
    { 
      this.id = id; 
      this.tau = tau; 
    }
    Identifier id;
    MonoType tau;
  }
:}


/* Binary operators */
terminal			PLUS, MINUS, STAR, SLASH, MOD;
terminal			EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;

/* Tuple operators */
terminal			FST, SND;

/* List operators */
terminal			CONS, IS_EMPTY, HD, TL;
terminal			COLONCOLON;

/* Logical operators */
terminal			AMPERAMPER, BARBAR;
terminal			NOT;

/* Syntactic tokens */
terminal			ARROW, COLON, COMMA, DOT;
terminal			SEMI, BELOW_SEMI;
terminal			LPAREN, RPAREN;
terminal			LBRACKET, RBRACKET;
terminal			PARENPAREN;
terminal			BRACKETBRACKET;
terminal			COLONEQUAL, EXCLAMATION;

/* Keywords */
terminal			LAMBDA, LET, REC, REF, IN, IF, THEN, ELSE, WHILE, DO;
terminal			TRUE, FALSE;

/* Types */
terminal			BOOL, INT, UNIT, LIST;

/* Special tokens */
terminal Integer	NUMBER;
terminal Integer	TYPEVARIABLE;
terminal String		IDENTIFIER;
terminal Integer[]	PROJECTION;
terminal			COMMENT;


/* Non-Terminals */
non terminal Expression		seq_expr;
non terminal Expression		expr;
non terminal Expression		simple_expr;
non terminal Expression[]	simple_expr_list;
non terminal Expression		constant;
non terminal Expression		operator;
non terminal Expression[]	expr_semi_list;		/* list of expressions separated by semicolon */
non terminal Expression[]	expr_comma_list;	/* list of expressions separated by comma */
non terminal IdTypePair[]	id_type_list;		/* list of identifiers and optionally types */
non terminal IdTypePair		id_type_pair;		/* (id:type) or id */
non terminal Identifier[]	id_comma_list;		/* list of identifiers separated by comma */
non terminal MonoType		type;
non terminal MonoType		simple_type;
non terminal MonoType[]		type_star_list;		/* list of types separated by star */


/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence nonassoc	IN;
precedence nonassoc	BELOW_SEMI;
precedence nonassoc	SEMI;				/* below EQUAL ({lbl = ...; lbl = ...}) */
precedence nonassoc LET, REC;			/* above SEMI (...; let ... in ...) */
precedence nonassoc DO;					/* below THEN (while ... do ...) */
precedence nonassoc THEN;				/* below ELSE (if ... then ...) */
precedence nonassoc ELSE;				/* (if ... then ... else ...) */

precedence right	COLONEQUAL;			/* expr (e := e := e) */

precedence right	ARROW;

precedence right	BARBAR;					/* expr (e || e || e) */
precedence right	AMPERAMPER;				/* expr (e && e && e) */

precedence left		EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence right	COLONCOLON;				/* expr (e :: e :: e) */
precedence left		PLUS, MINUS;
precedence left		STAR, SLASH, MOD;



/***************
 * Expressions *
 ***************/


seq_expr			::= expr:e
						{: RESULT = e; :}
						%prec BELOW_SEMI
					|	expr:e1 SEMI seq_expr:e2
						{: RESULT = new Sequence(e1, e2, e1left, e2right); :}
					;
					
					
expr				::=	simple_expr:e
						{: RESULT = e; :}
				
					/* Applications */
					|	simple_expr:e simple_expr_list:l
						{: for (int n = 0; n < l.length; ++n) 
						   {
						     e = new Application(e, l[n],
						       e.getParserStartOffset ( ) , 
						       l[n].getParserEndOffset ( ) );
						   }
						   RESULT = e; :}

					/* Infix Operations */
					|	expr:e1 COLONEQUAL:op expr:e2
						{: RESULT = new InfixOperation(new Assign(opleft,opright), e1, e2, e1left, e2right); :}

					|	expr:e1 PLUS:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newPlus(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 MINUS:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMinus(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 STAR:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMult(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 SLASH:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newDiv(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 MOD:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMod(opleft, opright), e1, e2, e1left, e2right); :}

					|	expr:e1 EQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newEquals(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 LESS:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerThan(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 GREATER:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterThan(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 LESSEQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerEqual(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 GREATEREQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterEqual(opleft, opright), e1, e2, e1left, e2right); :}

					|	expr:e1 COLONCOLON:op expr:e2
						{: RESULT = new InfixOperation(new BinaryCons(opleft,opright), e1, e2, e1left, e2right); :}

					/* Logical operators */
					|	expr:e1 AMPERAMPER expr:e2
						{: RESULT = new And(e1, e2,e1left,e2right); :}
					|	expr:e1 BARBAR expr:e2
						{: RESULT = new Or(e1, e2, e1left, e2right); :}

					/* Conditions */
					|	IF:i expr:e0 THEN expr:e1 ELSE expr:e2
						{: RESULT = new Condition(e0, e1, e2, ileft, e2right); :}
					|	IF:i seq_expr:e0 THEN seq_expr:e1
						{: RESULT = new Condition1(e0, e1, ileft, e1right); :}

					/* Lambda Abstraction */
					|	LAMBDA:l IDENTIFIER:id DOT seq_expr:e
						{: RESULT = new Lambda(new Identifier(id,idleft,idright), null, e, lleft, eright); :}
					|	LAMBDA:l IDENTIFIER:id COLON type:tau DOT seq_expr:e
						{: RESULT = new Lambda(new Identifier(id,idleft,idright), tau, e, lleft, eright); :}
					|	LAMBDA:l LPAREN id_comma_list:il RPAREN DOT seq_expr:e
						{: RESULT = new MultiLambda(il, null, e, lleft, eright); :}
					|	LAMBDA:l LPAREN id_comma_list:il RPAREN COLON type:tau DOT seq_expr:e
						{: RESULT = new MultiLambda(il, tau, e, lleft, eright); :}

					/* Let */
					|	LET:l IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier(id,idleft,idright), null, e1, e2, lleft, e2right); :}
					|	LET:l IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier(id,idleft,idright), tau, e1, e2, lleft, e2right); :}
					|	LET:l IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id,idleft,idright);
						   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right); :}
					|	LET:l IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id,idleft,idright);
						   types[0] = tau;
						   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right); :}
					|	LET:l LPAREN id_comma_list:il RPAREN EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new MultiLet(il, null, e1, e2, lleft, e2right); :}
					|	LET:l LPAREN id_comma_list:il RPAREN COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new MultiLet(il, tau, e1, e2, lleft, e2right); :}

					/* Recursion */				
					|	REC:r IDENTIFIER:id DOT seq_expr:e
						{: RESULT = new Recursion(new Identifier(id,idleft,idright), null, e, rleft, eright); :}
					|	REC:r IDENTIFIER:id COLON type:tau DOT seq_expr:e
						{: RESULT = new Recursion(new Identifier(id,idleft,idright), tau, e, rleft, eright); :}
					|	LET:l REC IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(new Identifier(id,idleft,idright), null, e1, e2, lleft, e2right); :}
					|	LET:l REC IDENTIFIER:id COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new LetRec(new Identifier(id,idleft,idright), tau, e1, e2, lleft, e2right); :}
					|	LET:l REC IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id,idleft,idright);
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right); :}
					|	LET:l REC IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id,idleft,idright);
						   types[0] = tau;
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right); :}
						   
					/* Loops */
					|	WHILE:w seq_expr:e1 DO seq_expr:e2
						{: RESULT = new While(e1, e2, wleft, e2right); :}
					;


simple_expr			::=	constant:c
						{: RESULT = c; :}
					|	IDENTIFIER:id
						{: RESULT = new Identifier(id,idleft,idright); :}
					|	LPAREN operator:o RPAREN
						{: RESULT = o; :}
					|	LPAREN seq_expr:e RPAREN
						{: RESULT = e; :}
					|	LPAREN:l expr_comma_list:el RPAREN:r
						{: RESULT = new Tuple(el, lleft, rright); :}
					|	LBRACKET:l expr_semi_list:el RBRACKET:r
						{: RESULT = new List(el, lleft, rright); :}
					;


/* for applications */
simple_expr_list	::=	simple_expr:e
						{: RESULT = new Expression[] { e }; :}
					|	simple_expr_list:l simple_expr:e
						{: RESULT = new Expression[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = e; :}
					;


constant			::=	PARENPAREN:c
						{: RESULT = new UnitConstant(cleft, cright); :}
					|	TRUE:c
						{: RESULT = new BooleanConstant(true, cleft, cright); :}
					|	FALSE:c
						{: RESULT = new BooleanConstant(false, cleft, cright); :}
					|	NUMBER:n
						{: RESULT = new IntegerConstant(n.intValue(), nleft, nright); :}
					|	NOT:c
						{: RESULT = new Not(cleft, cright); :}
					|	BRACKETBRACKET:c
						{: RESULT = new EmptyList(cleft, cright); :}
					|	PROJECTION:proj
						{: RESULT = new Projection(proj[0], proj[1], proj[2], proj[3], 
												     proj[4], proj[5], projleft, projright); :}
					|	FST:c
						{: RESULT = new Fst(cleft, cright); :}
					|	SND:c
						{: RESULT = new Snd(cleft, cright); :}
					|	CONS:c
						{: RESULT = new UnaryCons(cleft, cright); :}
					|	IS_EMPTY:c
						{: RESULT = new IsEmpty(cleft, cright); :}
					|	HD:c
						{: RESULT = new Hd(cleft, cright); :}
					|	TL:c
						{: RESULT = new Tl(cleft, cright); :}
					|	EXCLAMATION:e
						{: RESULT = new Deref(eleft, eright); :}
					|	REF:c
						{: RESULT = new Ref(cleft, cright); :}
					;


operator			::=	PLUS:op
						{: RESULT = ArithmeticOperator.newPlus(opleft, opright); :}
					|	MINUS:op
						{: RESULT = ArithmeticOperator.newMinus(opleft, opright); :}
					|	STAR:op
						{: RESULT = ArithmeticOperator.newMult(opleft, opright); :}
					|	SLASH:op
						{: RESULT = ArithmeticOperator.newDiv(opleft, opright); :}
					|	MOD:op
						{: RESULT = ArithmeticOperator.newMod(opleft, opright); :}
					|	EQUAL:op
						{: RESULT = RelationalOperator.newEquals(opleft, opright); :}
					|	LESS:op
						{: RESULT = RelationalOperator.newLowerThan(opleft, opright); :}
					|	GREATER:op
						{: RESULT = RelationalOperator.newGreaterThan(opleft, opright); :}
					|	LESSEQUAL:op
						{: RESULT = RelationalOperator.newLowerEqual(opleft, opright); :}
					|	GREATEREQUAL:op
						{: RESULT = RelationalOperator.newGreaterEqual(opleft, opright); :}	
					|	COLONCOLON:op
						{: RESULT = new BinaryCons(opleft, opright); :}
					|	COLONEQUAL:op
						{: RESULT = new Assign(opleft, opright); :}
					;


expr_semi_list		::=	expr:e
						{: RESULT = new Expression[] { e }; :}
					|	expr_semi_list:el SEMI expr:e
						{: RESULT = new Expression[el.length + 1];
						   System.arraycopy(el, 0, RESULT, 0, el.length);
						   RESULT[el.length] = e; :}
					;


expr_comma_list		::=	expr_comma_list:el COMMA seq_expr:e
						{: RESULT = new Expression[el.length + 1];
						   System.arraycopy(el, 0, RESULT, 0, el.length);
						   RESULT[el.length] = e; :}
					|	seq_expr:e1 COMMA seq_expr:e2
						{: RESULT = new Expression[] { e1, e2 }; :}
					;
				
				
id_type_list		::= id_type_list:l id_type_pair:itp
						{: RESULT = new IdTypePair[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = itp; :}
					|	id_type_pair:itp
						{: RESULT = new IdTypePair[] { itp }; :}
					;
					

id_type_pair		::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
						{: RESULT = new IdTypePair(new Identifier(id,idleft,idright), tau); :}
					|	IDENTIFIER:id
						{: RESULT = new IdTypePair(new Identifier(id,idleft,idright), null); :}
					;
					
					
id_comma_list		::=	id_comma_list:l COMMA IDENTIFIER:id
						{: RESULT = new Identifier[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = new Identifier(id,idleft,idright); :}
					|	IDENTIFIER:id
						{: RESULT = new Identifier[] { new Identifier(id,idleft,idright) }; :}
					;

					
					
/*********
 * Types *
 *********/


type				::=	simple_type:t
						{: RESULT = t; :}
					|	type:tau REF:r
						{: RESULT = new RefType(tau, tauleft, rright); :}
					|	type:t1 ARROW type:t2
						{: RESULT = new ArrowType(t1, t2, t1left, t2right); :}
					|	type_star_list:tl
						{: RESULT = new TupleType(tl, tlleft, tlright); :}
					|	type:t LIST:l
						{: RESULT = new ListType(t, tleft, lright); :}
					;


simple_type			::=	LPAREN type:t RPAREN
						{: RESULT = t; :}
					|	BOOL:b
						{: RESULT = new BooleanType(bleft, bright); :}
					|	INT:i
						{: RESULT = new IntegerType(ileft, iright); :}
					|	UNIT:u
						{: RESULT = new UnitType(uleft, uright); :}
					|	TYPEVARIABLE:tvar
						{: RESULT = new TypeVariable(0, tvar, tvarleft, tvarright); :}
					;


type_star_list		::= type_star_list:tl STAR type:t
						{: RESULT = new MonoType[tl.length + 1];
						   System.arraycopy(tl, 0, RESULT, 0, tl.length);
						   RESULT[tl.length] = t; :}
					|	type:t1 STAR type:t2
						{: RESULT = new MonoType[] { t1, t2 }; :}
					;