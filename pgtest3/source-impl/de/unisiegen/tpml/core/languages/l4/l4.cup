import de.unisiegen.tpml.core.expressions.*;
import de.unisiegen.tpml.core.types.*;
import de.unisiegen.tpml.core.exceptions.LanguageParserMultiException;
import de.unisiegen.tpml.core.exceptions.LanguageParserWarningException;
import de.unisiegen.tpml.core.languages.LanguageParserException;
import de.unisiegen.tpml.core.Messages ;
import java.text.MessageFormat;
import java.util.ArrayList;


/* Helper classes */
action code 
{:
  private static class IdTypePair 
  {
    Identifier id;
    MonoType type;
    
    public IdTypePair(Identifier pId, MonoType pType) 
    { 
      this.id = pId;
      this.type = pType; 
    }
  }
  
  private static class IdExprPair 
  {
    Identifier id;
    Expression expression;
    
    public IdExprPair(Identifier pId, Expression pExpression)
    { 
      this.id = pId; 
      this.expression = pExpression;
    }
  }
 
  private static class Error
  {
    public static void expect(int pLeft, int pRight, String pSymbol, String ... pTokenSequence)
    {
      String or = Messages.getString ( "Parser.15" ) ;
      String result = "" ;
      for ( int i = 0; i < pTokenSequence.length ; i++)
      {
        if ( i == 0 )
        {
          result += "\"" + pTokenSequence [i] + "\"" ;
        }
        else if ( i == pTokenSequence.length - 1 )
        {
          result += " " + or + " \"" + pTokenSequence [i]+ "\"";
        }
        else
        {
          result += ", \"" + pTokenSequence [i]+ "\"";
        }
      }
      throw new LanguageParserWarningException (  
        MessageFormat.format ( "<html>" + Messages.getString ( "Parser.14" ) + "</html>", 
          result, pSymbol), pLeft, pRight);
    }
  }
  
  private static class Duplicated
  {
    public static void check(Row pRow)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Expression [ ] rowExpressions = pRow.getExpressions ( ) ;
      for ( int i = 0 ; i < rowExpressions.length ; i ++ )
      {
        if ( rowExpressions[i] instanceof Attribute )
        {
          negativeIdentifiers.clear();
          Attribute attribute1 = (Attribute) rowExpressions[i] ;
          for ( int j = i+1 ; j < rowExpressions.length ; j++ )
          {
            if ( rowExpressions[j] instanceof Attribute )
    	    {
    	      Attribute attribute2 = (Attribute) rowExpressions[j] ;
    	      if ( attribute1.getId().equals(attribute2.getId()))
    	      {
    	        negativeIdentifiers.add(attribute2.getId());
    	      }
    	    }
    	  }
    	  negativeIdentifiers.add ( attribute1.getId() ) ;
    	  LanguageParserMultiException.throwExceptionRow ( negativeIdentifiers ) ;
        }
      }
    }
    
    
    public static void check(Duplication pDuplication)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pDuplication.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionDuplication ( negativeIdentifiers ) ;
      }
    }
    
    
    public static void check(RowType pRowType)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pRowType.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionRowType ( negativeIdentifiers ) ;
      }
    }
  }
:}


/* Binary operators */
terminal			PLUS;
terminal			MINUS;
terminal			STAR;
terminal			SLASH;
terminal			MOD;
terminal			EQUAL;
terminal			LESS;
terminal			GREATER;
terminal			LESSEQUAL;
terminal			GREATEREQUAL;

/* Tuple operators */
terminal			FST;
terminal			SND;

/* List operators */
terminal			CONS;
terminal			IS_EMPTY;
terminal			HD;
terminal			TL;
terminal			COLONCOLON;

/* Logical operators */
terminal			AMPERAMPER;
terminal			BARBAR;
terminal			NOT;

/* Syntactic tokens */
terminal			ARROW, COLON, COMMA, DOT;
terminal			SEMI, BELOW_SEMI;
terminal			LPAREN, RPAREN;
terminal			LBRACKET, RBRACKET;
terminal			PARENPAREN;
terminal			BRACKETBRACKET;
terminal			COLONEQUAL, EXCLAMATION;

/* Keywords */
terminal			LAMBDA;
terminal			LET;
terminal			REC;
terminal			IN;
terminal			IF;
terminal			THEN;
terminal			ELSE;
terminal			TRUE;
terminal			FALSE;
terminal			REF;
terminal			WHILE;
terminal			DO;

/* Types */
terminal			BOOL;
terminal			INT;
terminal			UNIT;
terminal			MU;
terminal			LIST;

/* Special tokens */
terminal Integer	NUMBER;
terminal Integer	TYPEVARIABLE;
terminal String		IDENTIFIER;
terminal			COMMENT;
terminal Integer[]	PROJECTION;

/* Expression non terminals */
non terminal Expression				expr;
non terminal Expression				simple_expr_l4;
non terminal Expression[]			simple_expr_list;
non terminal Constant				constant;
non terminal BinaryOperator			operator;
non terminal ArithmeticOperator		arithmetic_operator;
non terminal RelationalOperator		relational_operator;
non terminal Identifier				identifier;
non terminal Expression				application;
non terminal InfixOperation 		infix_operation;
non terminal InfixOperation 		infix_operation_plus;
non terminal InfixOperation 		infix_operation_minus;
non terminal InfixOperation 		infix_operation_mult;
non terminal InfixOperation 		infix_operation_div;
non terminal InfixOperation 		infix_operation_mod;
non terminal InfixOperation 		infix_operation_equal;
non terminal InfixOperation 		infix_operation_less;
non terminal InfixOperation 		infix_operation_greater;
non terminal InfixOperation 		infix_operation_less_equal;
non terminal InfixOperation 		infix_operation_greater_equal;
non terminal InfixOperation 		infix_operation_binary_cons;
non terminal InfixOperation 		infix_operation_assign;
non terminal And					and;
non terminal Or						or;
non terminal Condition				condition_l4;
non terminal Lambda					lambda_l4;
non terminal Let					let;
non terminal CurriedLet				curried_let;
non terminal Recursion				recursion_l4;
non terminal LetRec					let_rec;
non terminal CurriedLetRec			curried_let_rec;
non terminal UnitConstant			unit_constant;
non terminal BooleanConstant		boolean_constant;
non terminal IntegerConstant		integer_constant;
non terminal Not					not;
non terminal BinaryCons				binary_cons;
non terminal Fst					fst;
non terminal Snd					snd;
non terminal UnaryCons				unary_cons;
non terminal IsEmpty				is_empty;
non terminal Hd						hd;
non terminal Tl						tl;
non terminal EmptyList				empty_list;
non terminal Projection				projection;
non terminal Tuple					tuple;
non terminal List					list;
non terminal MultiLambda			multi_lambda_l4;
non terminal MultiLet				multi_let_l4;
non terminal Expression				seq_expr;
non terminal Condition1				condition1;
non terminal Assign					assign;
non terminal Deref					deref;
non terminal Ref					ref;
non terminal While					while;

/* Type non terminals */
non terminal MonoType				type;
non terminal MonoType				simple_type;
non terminal BooleanType			boolean_type;
non terminal IntegerType			integer_type;
non terminal UnitType				unit_type;
non terminal TypeVariable			type_variable;
non terminal ArrowType				arrow_type;
non terminal TupleType				tuple_type;
non terminal ListType				list_type;
non terminal RefType				ref_type;
non terminal TypeName				type_name;
non terminal RecType				rec_type;

/* Helper non terminals */
non terminal IdTypePair[]			curried_let_list;
non terminal IdTypePair				curried_let_pair;
non terminal IdTypePair[]			curried_let_rec_list;
non terminal IdTypePair				curried_let_rec_pair;
non terminal Expression[]			tuple_list_l4;
non terminal Expression[]			list_list;
non terminal Identifier[]			multi_lambda_list;
non terminal Identifier[]			multi_let_list;
non terminal MonoType[]				tuple_type_list;

/* Error non terminals */
non terminal 		epsilon;
non terminal 		and_error;
non terminal 		or_error;
non terminal 		condition_error_l4;
non terminal 		let_error;
non terminal 		recursion_error_l4;
non terminal 		let_rec_error;
non terminal 		curried_let_error;
non terminal 		curried_let_pair_error;
non terminal 		curried_let_rec_error;
non terminal 		curried_let_rec_pair_error;
non terminal 		lambda_error_l4;
non terminal 		multi_let_error_l4;
non terminal 		multi_let_list_error;
non terminal 		multi_lambda_error_l4;
non terminal 		multi_lambda_list_error;
non terminal 		simple_expr_error_l4;
non terminal 		infix_operation_plus_error;
non terminal  		infix_operation_minus_error;
non terminal  		infix_operation_mult_error;
non terminal  		infix_operation_div_error;
non terminal  		infix_operation_mod_error;
non terminal  		infix_operation_equal_error;
non terminal  		infix_operation_less_error;
non terminal  		infix_operation_greater_error;
non terminal  		infix_operation_less_equal_error;
non terminal  		infix_operation_greater_equal_error;
non terminal  		infix_operation_binary_cons_error;
non terminal		infix_operation_assign_error;
non terminal 		simple_type_error;
non terminal 		arrow_type_error;
non terminal		tuple_type_list_error;
non terminal		tuple_error;
non terminal		tuple_list_l4_error;
non terminal		list_error;
non terminal		list_list_error;
non terminal		while_error;
non terminal		rec_type_error;

/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence nonassoc	IN;
precedence nonassoc	BELOW_SEMI;
precedence nonassoc	SEMI;				/* below EQUAL ({lbl = ...; lbl = ...}) */
precedence nonassoc LET, REC;			/* above SEMI (...; let ... in ...) */
precedence nonassoc DO;					/* below THEN (while ... do ...) */
precedence nonassoc THEN;				/* below ELSE (if ... then ...) */
precedence nonassoc ELSE;				/* (if ... then ... else ...) */
precedence right	COLONEQUAL;			/* expr (e := e := e) */
precedence right	ARROW;
precedence right	BARBAR;					/* expr (e || e || e) */
precedence right	AMPERAMPER;				/* expr (e && e && e) */
precedence left		EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence right	COLONCOLON;				/* expr (e :: e :: e) */
precedence left		PLUS, MINUS;
precedence left		STAR, SLASH, MOD;

				
/***************
 * Expressions *
 ***************/


seq_expr						::= expr:e
									{: RESULT = e; :}
									%prec BELOW_SEMI
								|	expr:e1 SEMI seq_expr:e2
									{: RESULT = new Sequence(e1, e2, e1left, e2right); :}
								;

expr							::=	simple_expr_l4:e
									{: RESULT = e; :}
								|   application:a
									{: RESULT = a; :}
								|   infix_operation:i
									{: RESULT = i; :}
								|	and:a
									{: RESULT = a; :}
								|	or:o
									{: RESULT = o; :}
								|	condition_l4:c
									{: RESULT = c; :}
								|	lambda_l4:l
									{: RESULT = l; :}
								|	let:l
									{: RESULT = l; :}
								|	curried_let:c
									{: RESULT = c; :}
								|	recursion_l4:r
									{: RESULT = r; :}
								|	let_rec:l
									{: RESULT = l; :}
								|   curried_let_rec:c
									{: RESULT = c; :}
								|	multi_lambda_l4:m
									{: RESULT = m; :}
								|	multi_let_l4:m
									{: RESULT = m; :}
								|	condition1:c
									{: RESULT = c; :}
								|	while:w
									{: RESULT = w; :}
								;

identifier						::= IDENTIFIER:id
									{: RESULT = new Identifier (id,idleft,idright); :}
								;

application						::= simple_expr_l4:e simple_expr_list:l
									{:
									   for (int n = 0; n < l.length; ++n) 
						  			   {
						    			 e = new Application(e, l[n],
						      			   e.getParserStartOffset ( ) , 
						       				 l[n].getParserEndOffset ( ) );
						   			   }
						   			   RESULT = e; 
						   			:}
								;

infix_operation					::= infix_operation_plus:i
									{: RESULT = i ; :}
								|	infix_operation_minus:i
									{: RESULT = i ; :}
								|	infix_operation_mult:i
									{: RESULT = i ; :}
								|	infix_operation_div:i
									{: RESULT = i ; :}
								|	infix_operation_mod:i
									{: RESULT = i ; :}
								|	infix_operation_equal:i
									{: RESULT = i ; :}
								|	infix_operation_less:i
									{: RESULT = i ; :}
								|	infix_operation_greater:i
									{: RESULT = i ; :}
								|	infix_operation_less_equal:i
									{: RESULT = i ; :}
								|	infix_operation_greater_equal:i
									{: RESULT = i ; :}
								|	infix_operation_binary_cons:i
									{: RESULT = i ; :}
								|	infix_operation_assign:i
									{: RESULT = i ; :}
								;

infix_operation_plus			::= expr:e1 PLUS:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newPlus(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_plus_error
									{: :}
								;

infix_operation_plus_error		::= expr:e1 PLUS:p epsilon
									{: Error.expect(e1left, pright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_minus			::= expr:e1 MINUS:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMinus(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_minus_error
									{: :}
								;

infix_operation_minus_error		::= expr:e1 MINUS:m epsilon
									{: Error.expect(e1left, mright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_mult			::=	expr:e1 STAR:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMult(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_mult_error
									{: :}
								;

infix_operation_mult_error		::= expr:e1 STAR:s epsilon
									{: Error.expect(e1left, sright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_div				::=	expr:e1 SLASH:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newDiv(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_div_error
									{: :}
								;

infix_operation_div_error		::= expr:e1 SLASH:s epsilon
									{: Error.expect(e1left, sright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_mod				::=	expr:e1 MOD:op expr:e2
									{: RESULT = new InfixOperation(ArithmeticOperator.newMod(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_mod_error
									{: :}
								;

infix_operation_mod_error		::= expr:e1 MOD:m epsilon
									{: Error.expect(e1left, mright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_equal			::=	expr:e1 EQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newEquals(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_equal_error
									{: :}
								;

infix_operation_equal_error		::= expr:e1 EQUAL:e epsilon
									{: Error.expect(e1left, eright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_less			::=	expr:e1 LESS:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newLowerThan(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_less_error
									{: :}
								;

infix_operation_less_error		::= expr:e1 LESS:l epsilon
									{: Error.expect(e1left, lright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;
						
infix_operation_greater			::=	expr:e1 GREATER:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newGreaterThan(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_greater_error
									{: :}
								;

infix_operation_greater_error	::= expr:e1 GREATER:g epsilon
									{: Error.expect(e1left, gright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_less_equal		::=	expr:e1 LESSEQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newLowerEqual(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_less_equal_error
									{: :}
								;

infix_operation_less_equal_error	::= expr:e1 LESSEQUAL:l epsilon
									{: Error.expect(e1left, lright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_greater_equal	::=	expr:e1 GREATEREQUAL:op expr:e2
									{: RESULT = new InfixOperation(RelationalOperator.newGreaterEqual(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_greater_equal_error
									{: :}
								;

infix_operation_greater_equal_error	::= expr:e1 GREATEREQUAL:g epsilon
									{: Error.expect(e1left, gright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

infix_operation_binary_cons		::=	expr:e1 COLONCOLON:op expr:e2
									{: RESULT = new InfixOperation(new BinaryCons(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_binary_cons_error
									{: :}
								;

infix_operation_binary_cons_error	::= expr:e1 COLONCOLON:c epsilon
									{: Error.expect(e1left, cright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;


infix_operation_assign			::= expr:e1 COLONEQUAL:op expr:e2
									{: RESULT = new InfixOperation(new Assign(opleft, opright), e1, e2, e1left, e2right); :}
								|	infix_operation_assign_error
									{: :}
								;

infix_operation_assign_error	::= expr:e1 COLONEQUAL:c epsilon
									{: Error.expect(e1left, cright, "Infix-Operation", "e<sub>2</sub>" ); :}
								;

and								::= expr:e1 AMPERAMPER expr:e2
									{: RESULT = new And(e1, e2,e1left,e2right); :}
								|	and_error
									{: :}
								;

and_error						::= expr:e1 AMPERAMPER:a epsilon
									{: Error.expect(e1left, aright, "And", "e<sub>2</sub>" ); :}
								;

or								::= expr:e1 BARBAR expr:e2
									{: RESULT = new Or(e1, e2, e1left, e2right); :}
								|	or_error
									{: :}
								;

or_error						::= expr:e1 BARBAR:b epsilon
									{: Error.expect(e1left, bright, "Or", "e<sub>2</sub>" ); :}
								;

condition_l4					::= IF:i seq_expr:e0 THEN seq_expr:e1 ELSE seq_expr:e2
									{: RESULT = new Condition(e0, e1, e2, ileft, e2right); :}
								|	condition_error_l4
									{: :}
								;

condition_error_l4				::= IF:i epsilon
									{: Error.expect(ileft, iright, "Condition", "e<sub>0</sub> then e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr:e0 epsilon
									{: Error.expect(ileft, e0right, "Condition", "then e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr THEN:t epsilon
									{: Error.expect(ileft, tright, "Condition", "e<sub>1</sub> else e<sub>2</sub>" ); :}
								|	IF:i seq_expr THEN seq_expr ELSE:e epsilon
									{: Error.expect(ileft, eright, "Condition", "e<sub>2</sub>" ); :}
								;

condition1						::=	IF:i seq_expr:e0 THEN seq_expr:e1
									{: RESULT = new Condition1(e0, e1, ileft, e1right); :}
								;

lambda_l4						::= LAMBDA:l IDENTIFIER:id DOT seq_expr:e
									{: RESULT = new Lambda(new Identifier (id,idleft,idright), null, e, lleft, eright); :}
								|	LAMBDA:l IDENTIFIER:id COLON type:tau DOT seq_expr:e
									{: RESULT = new Lambda(new Identifier (id,idleft,idright), tau, e, lleft, eright); :}
								|	lambda_error_l4
									{: :}
								;

lambda_error_l4					::= LAMBDA:l epsilon
									{: Error.expect(lleft, lright, "Lambda", "id.e", "id: \u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER:i epsilon
									{: Error.expect(lleft, iright, "Lambda", ".e", ": \u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER COLON:c epsilon
									{: Error.expect(lleft, cright, "Lambda", "\u03C4.e" ); :}
								|	LAMBDA:l IDENTIFIER COLON type:t epsilon
									{: Error.expect(lleft, tright, "Lambda", ".e" ); :}
								|	LAMBDA:l IDENTIFIER COLON type DOT:d epsilon
									{: Error.expect(lleft, dright, "Lambda", "e" ); :}
								|	LAMBDA:l IDENTIFIER DOT:d epsilon
									{: Error.expect(lleft, dright, "Lambda", "e" ); :}
								;

let								::= LET:l IDENTIFIER:id EQUAL expr:e1 IN expr:e2
									{: RESULT = new Let(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
								|	LET:l IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
									{: RESULT = new Let(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
								|	let_error
									{: :}
								;

let_error						::= LET:l epsilon
									{: Error.expect(lleft, lright, "Let", "id = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER:i epsilon
									{: Error.expect(lleft, iright, "Let", "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l IDENTIFIER COLON:c epsilon
									{: Error.expect(lleft, cright, "Let", "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}	
								|	LET:l IDENTIFIER COLON type:t epsilon
									{: Error.expect(lleft, tright, "Let", "= e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l IDENTIFIER COLON type EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER COLON type EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Let", "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER COLON type EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Let", "e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Let", "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Let", "e<sub>2</sub>" ); :}
								;

curried_let						::= LET:l IDENTIFIER:id curried_let_list:itl EQUAL expr:e1 IN expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].id;
									     types[n + 1] = itl[n].type;
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	LET:l IDENTIFIER:id curried_let_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].id;
									     types[n + 1] = itl[n].type;
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   types[0] = tau;
									   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	curried_let_error
									{: :}
								;

curried_let_error				::= LET:l IDENTIFIER curried_let_list:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let", "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let", "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type:t epsilon
									{: Error.expect(lleft, tright, "Curried-Let", "= e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let", "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list COLON type EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let", "e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let", "in e<sub>2</sub>" ); :}
								|	LET:l IDENTIFIER curried_let_list EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let", "e<sub>2</sub>" ); :}
								;

curried_let_list				::= curried_let_list:l curried_let_pair:p
									{: 
									   RESULT = new IdTypePair[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = p;
									:}
								|	curried_let_pair:p
									{: RESULT = new IdTypePair[] { p }; :}
								;

curried_let_pair				::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
									{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), tau); :}
								|	IDENTIFIER:id
									{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), null); :}
								|	curried_let_pair_error
									{: :}
								;

curried_let_pair_error			::= LPAREN:l epsilon
									{: Error.expect(lleft, lright, "Curried-Let", "id: \u03C4) = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let", ": \u03C4) = e<sub>1</sub> in e<sub>2</sub>", ": \u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER COLON:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let", "\u03C4) = e<sub>1</sub> in e<sub>2</sub>", "\u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER COLON type:t epsilon
									{: Error.expect(lleft, tright, "Curried-Let", ") = e<sub>1</sub> in e<sub>2</sub>", "): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								;

recursion_l4					::= REC:r IDENTIFIER:id DOT seq_expr:e
									{: RESULT = new Recursion(new Identifier (id,idleft,idright), null, e, rleft, eright); :}
								|	REC:r IDENTIFIER:id COLON type:tau DOT seq_expr:e
									{: RESULT = new Recursion(new Identifier (id,idleft,idright), tau, e, rleft, eright); :}
								|	recursion_error_l4
									{: :}					
								;

recursion_error_l4				::= REC:r epsilon
									{: Error.expect(rleft, rright, "Recursion", "id.e", "id: \u03C4.e" ); :}
								|	REC:r IDENTIFIER:i epsilon
									{: Error.expect(rleft, iright, "Recursion", ".e", ": \u03C4.e" ); :}
								|	REC:r IDENTIFIER COLON:c epsilon
									{: Error.expect(rleft, cright, "Recursion", "\u03C4.e" ); :}
								|	REC:r IDENTIFIER COLON type:t epsilon
									{: Error.expect(rleft, tright, "Recursion", ".e" ); :}
								|	REC:r IDENTIFIER COLON type DOT:d epsilon
									{: Error.expect(rleft, dright, "Recursion", "e" ); :}
								|	REC:r IDENTIFIER DOT:d epsilon
									{: Error.expect(rleft, dright, "Recursion", "e" ); :}
								;

let_rec							::= LET:l REC IDENTIFIER:id EQUAL expr:e1 IN expr:e2
									{: RESULT = new LetRec(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
								|	LET:l REC IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
									{: RESULT = new LetRec(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
								|	let_rec_error
									{: :}				
								;

let_rec_error					::= LET:l REC:r epsilon
									{: Error.expect(lleft, rright, "Let-Rec", "id = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER:i epsilon
									{: Error.expect(lleft, iright, "Let-Rec", "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l REC IDENTIFIER COLON:c epsilon
									{: Error.expect(lleft, cright, "Let-Rec", "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}	
								|	LET:l REC IDENTIFIER COLON type:t epsilon
									{: Error.expect(lleft, tright, "Let-Rec", "= e<sub>1</sub> in e<sub>2</sub>" ); :}			
								|	LET:l REC IDENTIFIER COLON type EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Let-Rec", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Let-Rec", "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER COLON type EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Let-Rec", "e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Let-Rec", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Let-Rec", "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Let-Rec", "e<sub>2</sub>" ); :}
								;

curried_let_rec					::=	LET:l REC IDENTIFIER:id curried_let_rec_list:itl EQUAL expr:e1 IN expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].id;
									     types[n + 1] = itl[n].type;
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	LET:l REC IDENTIFIER:id curried_let_rec_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
									{:
									   Identifier[] identifiers = new Identifier[itl.length + 1];
									   MonoType[] types = new MonoType[itl.length + 1];
									   for (int n = 0; n < itl.length; ++n) 
									   {
									     identifiers[n + 1] = itl[n].id;
									     types[n + 1] = itl[n].type;
									   }
									   identifiers[0] = new Identifier (id,idleft,idright);
									   types[0] = tau;
									   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right);
									:}
								|	curried_let_rec_error
									{: :}
								;

curried_let_rec_error			::= LET:l REC IDENTIFIER curried_let_rec_list:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let-Rec", "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let-Rec", "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type:t epsilon
									{: Error.expect(lleft, tright, "Curried-Let-Rec", "= e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let-Rec", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let-Rec", "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list COLON type EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let-Rec", "e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let-Rec", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL expr:e epsilon
									{: Error.expect(lleft, eright, "Curried-Let-Rec", "in e<sub>2</sub>" ); :}
								|	LET:l REC IDENTIFIER curried_let_rec_list EQUAL expr IN:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let-Rec", "e<sub>2</sub>" ); :}
								;

curried_let_rec_list			::= curried_let_rec_list:l curried_let_rec_pair:p
									{: 
									   RESULT = new IdTypePair[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = p;
									:}
								|	curried_let_rec_pair:p
									{: RESULT = new IdTypePair[] { p }; :}
								;

curried_let_rec_pair			::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
									{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), tau); :}
								|	IDENTIFIER:id
									{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), null); :}
								|	curried_let_rec_pair_error
									{: :}
								;

curried_let_rec_pair_error		::= LPAREN:l epsilon
									{: Error.expect(lleft, lright, "Curried-Let-Rec", "id: \u03C4) = e<sub>1</sub> in e<sub>2</sub>", "id: \u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER:i epsilon
									{: Error.expect(lleft, iright, "Curried-Let-Rec", ": \u03C4) = e<sub>1</sub> in e<sub>2</sub>", ": \u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER COLON:c epsilon
									{: Error.expect(lleft, cright, "Curried-Let-Rec", "\u03C4) = e<sub>1</sub> in e<sub>2</sub>", "\u03C4): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								|	LPAREN:l IDENTIFIER COLON type:t epsilon
									{: Error.expect(lleft, tright, "Curried-Let-Rec", ") = e<sub>1</sub> in e<sub>2</sub>", "): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								;

multi_lambda_l4					::= LAMBDA:l LPAREN multi_lambda_list:il RPAREN DOT seq_expr:e
									{: RESULT = new MultiLambda(il, null, e, lleft, eright); :}
								|	LAMBDA:l LPAREN multi_lambda_list:il RPAREN COLON type:tau DOT seq_expr:e
									{: RESULT = new MultiLambda(il, tau, e, lleft, eright); :}
								|	multi_lambda_error_l4
									{: :}
								;

multi_lambda_error_l4			::= LAMBDA:l LPAREN:lp epsilon
									{: Error.expect(lleft, lpright, "Multi-Lambda", "id<sub>1</sub>, ... ,id<sub>n</sub>).e", "id<sub>1</sub>, ... ,id<sub>n</sub>): \u03C4.e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list:m epsilon
									{: Error.expect(lleft, mright, "Multi-Lambda", ").e", "): \u03C4.e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list RPAREN:r epsilon
									{: Error.expect(lleft, rright, "Multi-Lambda", ".e", ": \u03C4.e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list RPAREN COLON:c epsilon
									{: Error.expect(lleft, cright, "Multi-Lambda", "\u03C4.e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list RPAREN COLON type:t epsilon
									{: Error.expect(lleft, tright, "Multi-Lambda", ".e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list RPAREN COLON type DOT:d epsilon
									{: Error.expect(lleft, dright, "Multi-Lambda", "e" ); :}
								|	LAMBDA:l LPAREN multi_lambda_list RPAREN DOT:d epsilon
									{: Error.expect(lleft, dright, "Multi-Lambda", "e" ); :}
								;

multi_lambda_list				::=	multi_lambda_list:l COMMA IDENTIFIER:id
									{:
									   RESULT = new Identifier[l.length + 1];
						   			   System.arraycopy(l, 0, RESULT, 0, l.length);
						   			   RESULT[l.length] = new Identifier(id,idleft,idright);
						   			:}
								|	IDENTIFIER:id
									{: RESULT = new Identifier[] { new Identifier(id,idleft,idright) }; :}
						   		|	multi_lambda_list_error
						   			{: :}
								;

multi_lambda_list_error			::=	multi_lambda_list:m COMMA:c epsilon
									{: Error.expect(mleft, cright, "Multi-Lambda", "id<sub>i</sub>, ... ,id<sub>n</sub>).e", "id<sub>i</sub>, ... ,id<sub>n</sub>): \u03C4.e"); :}
								;

multi_let_l4					::= LET:l LPAREN multi_let_list:il RPAREN EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new MultiLet(il, null, e1, e2, lleft, e2right); :}
								|	LET:l LPAREN multi_let_list:il RPAREN COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
									{: RESULT = new MultiLet(il, tau, e1, e2, lleft, e2right); :}
								|	multi_let_error_l4
									{: :}
								;

multi_let_error_l4				::= LET:l LPAREN multi_let_list:m epsilon
									{: Error.expect(lleft, mright, "Multi-Let", ") = e<sub>1</sub> in e<sub>2</sub>", "): \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN:r epsilon
									{: Error.expect(lleft, rright, "Multi-Let", "= e<sub>1</sub> in e<sub>2</sub>", ": \u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN COLON:c epsilon
									{: Error.expect(lleft, cright, "Multi-Let", "\u03C4 = e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN COLON type:t epsilon
									{: Error.expect(lleft, tright, "Multi-Let", "= e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN COLON type EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Multi-Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN COLON type EQUAL seq_expr:e epsilon
									{: Error.expect(lleft, eright, "Multi-Let", "in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN COLON type EQUAL seq_expr IN:i epsilon
									{: Error.expect(lleft, iright, "Multi-Let", "e<sub>2</sub>" ); :}									
								|	LET:l LPAREN multi_let_list RPAREN EQUAL:e epsilon
									{: Error.expect(lleft, eright, "Multi-Let", "e<sub>1</sub> in e<sub>2</sub>" ); :}
								|	LET:l LPAREN multi_let_list RPAREN EQUAL seq_expr:e epsilon
									{: Error.expect(lleft, eright, "Multi-Let", "in e<sub>2</sub>" ); :}	
								|	LET:l LPAREN multi_let_list RPAREN EQUAL seq_expr IN:i epsilon
									{: Error.expect(lleft, iright, "Multi-Let", "e<sub>2</sub>" ); :}
								;

multi_let_list					::=	multi_let_list:l COMMA IDENTIFIER:id
									{:
									   RESULT = new Identifier[l.length + 1];
						   			   System.arraycopy(l, 0, RESULT, 0, l.length);
						   			   RESULT[l.length] = new Identifier(id,idleft,idright);
						   			:}
								|	IDENTIFIER:id
									{: RESULT = new Identifier[] { new Identifier(id,idleft,idright) }; :}
								|	multi_let_list_error
						   			{: :}
								;

multi_let_list_error			::=	multi_let_list:m COMMA:c epsilon
									{: Error.expect(mleft, cright, "Multi-Let", "id<sub>i</sub>, ... ,id<sub>n</sub>) = e<sub>1</sub> in e<sub>2</sub>", "id<sub>i</sub>, ... ,id<sub>n</sub>): \u03C4 = e<sub>1</sub> in e<sub>2</sub>"); :}
								;

while							::=	WHILE:w seq_expr:e1 DO seq_expr:e2
									{: RESULT = new While(e1, e2, wleft, e2right); :}
								|	while_error
									{: :}
								;

while_error						::= WHILE:w epsilon
									{: Error.expect(wleft, wright, "While", "e<sub>1</sub> do e<sub>2</sub>" ); :}
								|	WHILE:w seq_expr:e1 epsilon
									{: Error.expect(wleft, e1right, "While", "do e<sub>2</sub>" ); :}
								|	WHILE:w seq_expr DO:d epsilon
									{: Error.expect(wleft, dright, "While", "e<sub>2</sub>" ); :}
								;

constant						::=	unit_constant:u
									{: RESULT = u; :}
								|	boolean_constant:b
									{: RESULT = b; :}
								|	integer_constant:i
									{: RESULT = i; :}
								|	not:n
									{: RESULT = n; :}
								|	fst:f
									{: RESULT = f; :}
								|	snd:s
									{: RESULT = s; :}
								|	unary_cons:u
									{: RESULT = u; :}
								|	is_empty:i
									{: RESULT = i; :}
								|	hd:h
									{: RESULT = h; :}
								|	tl:t
									{: RESULT = t; :}
								|	empty_list:e
									{: RESULT = e; :}
								|	projection:p
									{: RESULT = p; :}
								|	deref:d
									{: RESULT = d; :}
								|	ref:r
									{: RESULT = r; :}
								;

unit_constant					::= PARENPAREN:u
									{: RESULT = new UnitConstant(uleft, uright); :}
								;

boolean_constant				::= TRUE:t
									{: RESULT = new BooleanConstant(true, tleft, tright); :}
								|	FALSE:f
									{: RESULT = new BooleanConstant(false, fleft, fright); :}
								;

integer_constant				::= NUMBER:n
									{: RESULT = new IntegerConstant(n.intValue(), nleft, nright); :}
								;

not								::= NOT:n
									{: RESULT = new Not(nleft, nright); :}
								;

fst								::= FST:f
									{: RESULT = new Fst(fleft, fright); :}
								;

snd								::= SND:s
									{: RESULT = new Snd(sleft, sright); :}
								;

unary_cons						::= CONS:c
									{: RESULT = new UnaryCons(cleft, cright); :}
								;

is_empty						::= IS_EMPTY:i
									{: RESULT = new IsEmpty(ileft, iright); :}
								;

hd								::= HD:h
									{: RESULT = new Hd(hleft, hright); :}
								;

tl								::= TL:t
									{: RESULT = new Tl(tleft, tright); :}
								;

empty_list						::=	BRACKETBRACKET:b
								    {: RESULT = new EmptyList(bleft, bright); :}
								;

projection						::=	PROJECTION:p
									{: RESULT = new Projection(p[0], p[1], p[2], p[3], p[4], p[5], pleft, pright); :}
								;

deref							::=	EXCLAMATION:e
									{: RESULT = new Deref(eleft, eright); :}
								;

ref								::=	REF:r
									{: RESULT = new Ref(rleft, rright); :}
								;

operator						::=	arithmetic_operator:a
									{: RESULT = a; :}
								|	relational_operator:r
									{: RESULT = r; :}
								|	binary_cons:b
									{: RESULT = b; :}
								|	assign:a
									{: RESULT = a; :}
								;

arithmetic_operator				::= PLUS:op		
									{: RESULT = ArithmeticOperator.newPlus(opleft, opright); :}
								|	MINUS:op		
									{: RESULT = ArithmeticOperator.newMinus(opleft, opright); :}
								|	STAR:op			
									{: RESULT = ArithmeticOperator.newMult(opleft, opright); :}
								|	SLASH:op			
									{: RESULT = ArithmeticOperator.newDiv(opleft, opright); :}
								|	MOD:op			
									{: RESULT = ArithmeticOperator.newMod(opleft, opright); :}
								;

relational_operator				::= EQUAL:op			
									{: RESULT = RelationalOperator.newEquals(opleft, opright); :}
								|	LESS:op			
									{: RESULT = RelationalOperator.newLowerThan(opleft, opright); :}
								|	GREATER:op		
									{: RESULT = RelationalOperator.newGreaterThan(opleft, opright); :}
								|	LESSEQUAL:op		
									{: RESULT = RelationalOperator.newLowerEqual(opleft, opright); :}
								|	GREATEREQUAL:op
									{: RESULT = RelationalOperator.newGreaterEqual(opleft, opright); :}
								;

binary_cons						::=	COLONCOLON:op
					    			{: RESULT = new BinaryCons(opleft, opright); :}
					    		;

assign							::=	COLONEQUAL:op
									{: RESULT = new Assign(opleft, opright); :}
								;

tuple							::=	LPAREN:l tuple_list_l4:e RPAREN:r
									{: RESULT = new Tuple(e, lleft, rright); :}
								|	tuple_error
									{: :}
								;

tuple_error						::= LPAREN:l tuple_list_l4:t epsilon
									{: Error.expect(lleft, tright, "Tuple", ")"); :}
								;

tuple_list_l4					::=	tuple_list_l4:el COMMA seq_expr:e
									{:
									   RESULT = new Expression[el.length + 1];
						   			   System.arraycopy(el, 0, RESULT, 0, el.length);
						   			   RESULT[el.length] = e;
						   			:}
								|	seq_expr:e1 COMMA seq_expr:e2
									{: RESULT = new Expression[] { e1, e2 }; :}
								|	tuple_list_l4_error
									{: :}
								;

tuple_list_l4_error				::=	tuple_list_l4:t COMMA:c epsilon
									{: Error.expect(tleft, cright, "Tuple", "e<sub>i</sub>, ... ,e<sub>n</sub>)"); :}
								|	seq_expr:e COMMA:c epsilon
									{: Error.expect(eleft, cright, "Tuple", "e<sub>i</sub>, ... ,e<sub>n</sub>)"); :}
								;

list							::=	LBRACKET:l list_list:e RBRACKET:r
									{: RESULT = new List(e, lleft, rright); :}
								|	list_error
									{: :}
								;

list_error						::= LBRACKET:l epsilon
									{: Error.expect(lleft, lright, "List", "e<sub>1</sub>; ... ;e<sub>n</sub>]"); :}
								|	LBRACKET:l list_list:li epsilon
									{: Error.expect(lleft, liright, "List", "]"); :}
								;

list_list						::=	expr:e
									{: RESULT = new Expression[] { e }; :}
								|	list_list:el SEMI expr:e
									{:
									   RESULT = new Expression[el.length + 1];
									   System.arraycopy(el, 0, RESULT, 0, el.length);
						   			   RESULT[el.length] = e;
						   			:}
						   		|	list_list_error
						   			{: :}
								;

list_list_error					::=	list_list:l SEMI:s epsilon
									{: Error.expect(lleft, sright, "List", "e<sub>i</sub>; ... ;e<sub>n</sub>]"); :}
								;

simple_expr_l4					::=	constant:c
									{: RESULT = c; :}
								|	identifier:id
									{: RESULT = id; :}
								|	LPAREN operator:o RPAREN
									{: RESULT = o; :}
								|	LPAREN seq_expr:e RPAREN
									{: RESULT = e; :}
								|	tuple:t
									{: RESULT = t; :}									
								|	list:l
									{: RESULT = l; :}
								|	simple_expr_error_l4
									{: :}								
								;

simple_expr_error_l4			::= LPAREN:l seq_expr:e epsilon
									{: Error.expect(lleft, eright, "Expression", ")"); :}
								|	LPAREN:l operator:o epsilon
									{: Error.expect(lleft, oright, "Operator", ")"); :}
								|	LPAREN:l epsilon
									{: Error.expect(lleft, lright, "Expression", "... )"); :}
								;

simple_expr_list				::=	simple_expr_l4:e
									{: RESULT = new Expression[] { e }; :}
								|	simple_expr_list:l simple_expr_l4:e
									{:
									   RESULT = new Expression[l.length + 1];
									   System.arraycopy(l, 0, RESULT, 0, l.length);
									   RESULT[l.length] = e;
									:}
								;

epsilon							::= /* epsilon */
									{: :}	
								;


/*********
 * Types *
 *********/


type							::=	simple_type:t
									{: RESULT = t; :}
								|	arrow_type:a
									{: RESULT = a; :}
								|	tuple_type:t
									{: RESULT = t; :}
								|	list_type:l
									{: RESULT = l; :}
								|	ref_type:r
									{: RESULT = r; :}
								;

simple_type						::=	LPAREN:l type:t RPAREN:r
									{: RESULT = t; :}
								|	boolean_type:b
									{: RESULT = b; :}
								|	integer_type:i
									{: RESULT = i; :}
								|	unit_type:u
									{: RESULT = u; :}
								|	type_variable:t
									{: RESULT = t; :}
								|	type_name:t
									{: RESULT = t; :}
								|	rec_type:r
									{: RESULT = r; :}
								|	simple_type_error
									{: :}
								;

simple_type_error				::= LPAREN:l epsilon
									{: Error.expect(lleft, lright, "Type", "\u03C4)"); :}
								|	LPAREN:l type:t epsilon
									{: Error.expect(lleft, tright, "Type", ")"); :}
								;

arrow_type						::= type:t1 ARROW type:t2
									{: RESULT = new ArrowType(t1, t2, t1left, t2right); :}
								|	arrow_type_error
									{: :}
								;

arrow_type_error				::= type:t ARROW:a epsilon 
									{: Error.expect(tleft, aright, "Arrow-Type", "\u03C4<sub>2</sub>"); :}
								;

boolean_type					::= BOOL:b
									{: RESULT = new BooleanType(bleft, bright); :}
								;

integer_type					::= INT:i
									{: RESULT = new IntegerType(ileft, iright); :}
								;

unit_type						::= UNIT:u
									{: RESULT = new UnitType(uleft, uright); :}
								;

type_variable					::= TYPEVARIABLE:t
									{: RESULT = new TypeVariable(0, t, tleft, tright); :}
								;

type_name						::= IDENTIFIER:id
									{: RESULT = new TypeName(id, idleft, idright); :}
								;

rec_type						::= MU:m IDENTIFIER:id DOT type:t
									{: RESULT = new RecType(new TypeName(id, idleft, idright), t, mleft, tright); :}
								|	rec_type_error
									{: :}								
								;

rec_type_error					::= MU:m epsilon
									{: Error.expect(mleft, mright, "Rec-Type", "t.\u03C4"); :}
								|	MU:m IDENTIFIER:i epsilon
									{: Error.expect(mleft, iright, "Rec-Type", ".\u03C4"); :}
								|	MU:m IDENTIFIER DOT:d epsilon
									{: Error.expect(mleft, dright, "Rec-Type", "\u03C4"); :}
								;

tuple_type						::= tuple_type_list:t
									{: RESULT = new TupleType(t, tleft, tright); :}
								;

tuple_type_list					::= tuple_type_list:tl STAR type:t
									{:
									   RESULT = new MonoType[tl.length + 1];
									   System.arraycopy(tl, 0, RESULT, 0, tl.length);
									   RESULT[tl.length] = t;
									:}
								|	type:t1 STAR type:t2
									{: RESULT = new MonoType[] { t1, t2 }; :}
								|	tuple_type_list STAR tuple_type_list_error
									{: :}
								|	tuple_type_list_error
									{: :}
								;

tuple_type_list_error			::= type:t STAR:s epsilon
									{: Error.expect(tleft, sright, "Tuple-Type", "\u03C4"); :}
								;

list_type						::=	type:t LIST:l
									{: RESULT = new ListType(t, tleft, lright); :}
								;

ref_type						::=	type:t REF
									{: RESULT = new RefType(t); :}
								;