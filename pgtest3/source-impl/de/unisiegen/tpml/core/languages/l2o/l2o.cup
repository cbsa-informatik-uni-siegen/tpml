import de.unisiegen.tpml.core.expressions.*;
import de.unisiegen.tpml.core.types.*;
import java.util.ArrayList;
import de.unisiegen.tpml.core.languages.LanguageParserException;

/* Helper classes */
action code 
{:
  private static class IdTypePair 
  {
    Identifier id;
    MonoType tau;
    
    public IdTypePair(Identifier id, MonoType tau) 
    { 
      this.id = id;
      this.tau = tau; 
    }
  }
  
  private static class IdExprPair 
  {
    Identifier id;
    Expression e;
    
    public IdExprPair(Identifier id, Expression e)
    { 
      this.id = id; 
      this.e = e;
    }
  }
:}


/* Binary operators */
terminal			PLUS;
terminal			MINUS;
terminal			STAR;
terminal			SLASH;
terminal			MOD;
terminal			EQUAL;
terminal			LESS;
terminal			GREATER;
terminal			LESSEQUAL;
terminal			GREATEREQUAL;

/* Logical operators */
terminal			AMPERAMPER;
terminal			BARBAR;
terminal			NOT;

/* Syntactic tokens */
terminal			ARROW;
terminal			COLON;
terminal			DOT;
terminal			LPAREN;
terminal			RPAREN;
terminal			PARENPAREN;

/* Keywords */
terminal			LAMBDA;
terminal			LET;
terminal			REC;
terminal			IN;
terminal			IF;
terminal			THEN;
terminal			ELSE;
terminal			TRUE;
terminal			FALSE;

/* Object */
terminal			OBJECT ;
terminal			SELF ;
terminal			END ;
terminal			HASHKEY ;
terminal			ATTRIBUTE ;
terminal			METHOD ;
terminal			SEMI ;
terminal			DUPLBEGIN ;
terminal			DUPLEND ;

/* Types */
terminal			BOOL;
terminal			INT;
terminal			UNIT;

/* Special tokens */
terminal Integer	NUMBER;
terminal Integer	TYPEVARIABLE;
terminal String		IDENTIFIER;
terminal			COMMENT;


/* Non-Terminals */
non terminal Expression			expr;
non terminal Expression			simple_expr;
non terminal Expression[]		simple_expr_list;
non terminal Expression			constant;
non terminal Expression			operator;

/* Expression non terminals */
non terminal Identifier			identifier;
non terminal Expression			application;
non terminal InfixOperation 	infix_operation;
non terminal And				and;
non terminal Or					or;
non terminal Condition			condition;
non terminal Lambda				lambda;
non terminal Let				let;
non terminal CurriedLet			curried_let;
non terminal Recursion			recursion;
non terminal LetRec				let_rec;
non terminal CurriedLetRec		curried_let_rec;
non terminal ObjectExpr			object_expr;
non terminal Duplication		duplication;
non terminal Send				send;
non terminal Row				row;
non terminal Attribute			attribute;
non terminal Method				method;
non terminal CurriedMethod		curried_method;

/* Type non terminals */
non terminal MonoType			type;
non terminal MonoType			simple_type;
non terminal ObjectType			object_type;
non terminal RowType			row_type;

/* Helper non terminals */
non terminal IdExprPair[]		id_expr_list;
non terminal IdTypePair[]		id_type_list;
non terminal IdTypePair			id_type_pair;

/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence right	ARROW;

precedence right	BARBAR;					/* expr (e || e || e) */
precedence right	AMPERAMPER;				/* expr (e && e && e) */

precedence left		EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence left		PLUS, MINUS;
precedence left		STAR, SLASH, MOD;



/***************
 * Expressions *
 ***************/



expr				::=	simple_expr:e
						{: RESULT = e; :}
					|	object_expr:o
						{: RESULT = o; :}
					|   duplication:d
						{: RESULT = d; :}
					|   application:a
						{: RESULT = a; :}
					|   infix_operation:i
						{: RESULT = i; :}
					|	and:a
						{: RESULT = a; :}
					|	or:o
						{: RESULT = o; :}
					|	condition:c
						{: RESULT = c; :}
					|	lambda:l
						{: RESULT = l; :}
					|	let:l
						{: RESULT = l; :}
					|	curried_let:c
						{: RESULT = c; :}
					|	recursion:r
						{: RESULT = r; :}
					|	let_rec:l
						{: RESULT = l; :}
					|   curried_let_rec:c
						{: RESULT = c; :}
					;

simple_expr			::=	constant:c
						{: RESULT = c; :}
					|	identifier:id
						{: RESULT = id; :}
					|	send:s
						{: RESULT = s; :}
					|	LPAREN operator:o RPAREN
						{: RESULT = o; :}
					|	LPAREN expr:e RPAREN
						{: RESULT = e; :}
					;

identifier			::= IDENTIFIER:id
						{: RESULT = new Identifier(id); :}
					|	SELF:s
						{: RESULT = new SelfIdentifier(); :}
					;

application			::= simple_expr:e simple_expr_list:l
						{: for (int n = 0; n < l.length; ++n) 
						{
						  e = new Application(e, l[n]);
					    }
						RESULT = e; :}
					;

infix_operation		::= expr:e1 PLUS expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newPlus(), e1, e2); :}
					|	expr:e1 MINUS expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMinus(), e1, e2); :}
					|	expr:e1 STAR expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMult(), e1, e2); :}
					|	expr:e1 SLASH expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newDiv(), e1, e2); :}
					|	expr:e1 MOD expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMod(), e1, e2); :}
					|	expr:e1 EQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newEquals(), e1, e2); :}
					|	expr:e1 LESS expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerThan(), e1, e2); :}
					|	expr:e1 GREATER expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterThan(), e1, e2); :}
					|	expr:e1 LESSEQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerEqual(), e1, e2); :}
					|	expr:e1 GREATEREQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterEqual(), e1, e2); :}
					;

and					::= expr:e1 AMPERAMPER expr:e2
						{: RESULT = new And(e1, e2); :}
					;

or					::= expr:e1 BARBAR expr:e2
						{: RESULT = new Or(e1, e2); :}
					;

condition			::= IF expr:e0 THEN expr:e1 ELSE expr:e2
						{: RESULT = new Condition(e0, e1, e2); :}
					;

lambda				::= LAMBDA IDENTIFIER:id DOT expr:e
						{: RESULT = new Lambda(new Identifier(id), null, e); :}
					|	LAMBDA IDENTIFIER:id COLON type:tau DOT expr:e
						{: RESULT = new Lambda(new Identifier(id), tau, e); :}
					;

let					::= LET IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier(id), null, e1, e2); :}
					|	LET IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier(id), tau, e1, e2); :}
					;

curried_let			::= LET IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id);
						   RESULT = new CurriedLet(identifiers, types, e1, e2); :}
					|	LET IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id);
						   types[0] = tau;
						   RESULT = new CurriedLet(identifiers, types, e1, e2); :}
					;

recursion			::= REC IDENTIFIER:id DOT expr:e
						{: RESULT = new Recursion(new Identifier(id), null, e); :}
					|	REC IDENTIFIER:id COLON type:tau DOT expr:e
						{: RESULT = new Recursion(new Identifier(id), tau, e); :}
					;

let_rec				::= LET REC IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(new Identifier(id), null, e1, e2); :}
					|	LET REC IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(new Identifier(id), tau, e1, e2); :}
					;

curried_let_rec		::= LET REC IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id);
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2); :}
					|	LET REC IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier(id);
						   types[0] = tau;
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2); :}
					;

object_expr			::= OBJECT LPAREN SELF:l RPAREN END
						{: Expression [] e = new Expression [0];
						   RESULT = new ObjectExpr (null, new Row (e)); :}
					|   OBJECT LPAREN SELF:l COLON type:tau RPAREN END
						{: Expression [] e = new Expression [0];
						   RESULT = new ObjectExpr (tau, new Row (e)); :}
					|	OBJECT LPAREN SELF:l RPAREN row:r END
						{: RESULT = new ObjectExpr (null, r); :}
					|	OBJECT LPAREN SELF:l COLON type:tau RPAREN row:r END
						{: RESULT = new ObjectExpr (tau, r); :}
					;
					
duplication			::= DUPLBEGIN id_expr_list:iel DUPLEND
						{: Expression [] tmpE = new Expression [iel.length];
						   Identifier [] tmpI = new Identifier [iel.length];
						   for ( int i = 0 ; i < iel.length ; i++ )
						   {
						     tmpE [i] = iel [i].e;
						     tmpI [i] = iel [i].id;
						   }
						   RESULT = new Duplication ( tmpI , tmpE ); :}
					|	DUPLBEGIN DUPLEND
						{: Expression [] tmpE = new Expression [0];
						   Identifier [] tmpI = new Identifier [0];
						   RESULT = new Duplication ( tmpI , tmpE ); :}
					;

send				::= simple_expr:e HASHKEY IDENTIFIER:id
						{: RESULT = new Send ( e , new Identifier(id) ) ; :}
					;
					
row					::= attribute:a
						{: Expression [] e = new Expression [1];
						   e [0] = a;
						   RESULT = new Row (e); :}
					|	attribute:a row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    					   for ( int i = 0 ; i < r.getExpressions().length ; i ++ )
    					   {
    					     if ( r.getExpressions(i) instanceof Attribute )
    					     {
    					       Attribute attribute = (Attribute) r.getExpressions(i) ;
    					       if ( attribute.getId().equals(a.getId()))
    					       {
    					         throw new LanguageParserException ( "Es existiert bereits ein Attribut mit Identifier \"" 
                                   + attribute.getId ( ) + "\"" , 0 , 0 ) ; 
    					       }
    					     }
    					   }
    					   
    					   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = a ;
						   RESULT = new Row (e); :}
					|	method:m
						{: Expression [] e = new Expression [1];
						   e [0] = m;
						   RESULT = new Row (e); :}
					|	method:m row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    					   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = m ;
						   RESULT = new Row (e); :}
					|	curried_method:cm
						{: Expression [] e = new Expression [1];
						   e [0] = cm;
						   RESULT = new Row (e); :}
					|	curried_method:cm row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    					   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = cm ;
						   RESULT = new Row (e); :}
					;

attribute			::=	ATTRIBUTE IDENTIFIER:id EQUAL expr:e SEMI
						{: RESULT = new Attribute (new Identifier(id) , null , e ); :}
					|	ATTRIBUTE IDENTIFIER:id COLON type:tau EQUAL expr:e SEMI
						{: RESULT = new Attribute (new Identifier(id) , tau , e ); :}
					;

method				::=	METHOD IDENTIFIER:id EQUAL expr:e SEMI
						{: RESULT = new Method (new Identifier(id) , null, e ); :}
					|	METHOD IDENTIFIER:id COLON type:tau EQUAL expr:e SEMI
						{: RESULT = new Method (new Identifier(id) ,tau, e ); :}
					;

curried_method		::=	METHOD IDENTIFIER:id id_type_list:itl EQUAL expr:e SEMI
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1 ];
						   for (int n = 0; n < itl.length; n++) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers [0] = new Identifier(id) ;
						   types [0] = null ;
						   RESULT = new CurriedMethod ( identifiers , types , e ); :}
					|	METHOD IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e SEMI
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1 ];
						   for (int n = 0; n < itl.length; n++) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers [0] = new Identifier(id) ;
						   types [0] = tau ;
						   RESULT = new CurriedMethod ( identifiers , types , e ); :}
					;	   

id_expr_list		::= IDENTIFIER:id EQUAL expr:e
						{: IdExprPair [] list = new IdExprPair [1];
						   list [0] = new IdExprPair (new Identifier(id), e);
						   RESULT = list; :}
					|	IDENTIFIER:id EQUAL expr:e SEMI id_expr_list:iel
						{: IdExprPair [] list = new IdExprPair [iel.length+1];
						   System.arraycopy(iel, 0, list, 1, iel.length);
						   list [0] = new IdExprPair (new Identifier(id), e);
						   RESULT = list; :}
					;

simple_expr_list	::=	simple_expr:e
						{: RESULT = new Expression[] { e }; :}
					|	simple_expr_list:l simple_expr:e
						{: RESULT = new Expression[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = e; :}
					;

constant			::=	PARENPAREN		{: RESULT = new UnitConstant(); :}
					|	TRUE			{: RESULT = new BooleanConstant(true); :}
					|	FALSE			{: RESULT = new BooleanConstant(false); :}
					|	NUMBER:n		{: RESULT = new IntegerConstant(n.intValue()); :}
					|	NOT				{: RESULT = new Not(); :}
					;

operator			::=	PLUS			{: RESULT = ArithmeticOperator.newPlus(); :}
					|	MINUS			{: RESULT = ArithmeticOperator.newMinus(); :}
					|	STAR			{: RESULT = ArithmeticOperator.newMult(); :}
					|	SLASH			{: RESULT = ArithmeticOperator.newDiv(); :}
					|	MOD				{: RESULT = ArithmeticOperator.newMod(); :}
					|	EQUAL			{: RESULT = RelationalOperator.newEquals(); :}
					|	LESS			{: RESULT = RelationalOperator.newLowerThan(); :}
					|	GREATER			{: RESULT = RelationalOperator.newGreaterThan(); :}
					|	LESSEQUAL		{: RESULT = RelationalOperator.newLowerEqual(); :}
					|	GREATEREQUAL	{: RESULT = RelationalOperator.newGreaterEqual(); :}
					;

id_type_list		::= id_type_list:l id_type_pair:itp
						{: RESULT = new IdTypePair[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = itp; :}
					|	id_type_pair:itp
						{: RESULT = new IdTypePair[] { itp }; :}
					;

id_type_pair		::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
						{: RESULT = new IdTypePair(new Identifier(id), tau); :}
					|	IDENTIFIER:id
						{: RESULT = new IdTypePair(new Identifier(id), null); :}
					;
				

/*********
 * Types *
 *********/


type				::=	simple_type:t			{: RESULT = t; :}
					|	type:t1 ARROW type:t2	{: RESULT = new ArrowType(t1, t2); :}
					;

simple_type			::=	LPAREN type:t RPAREN	{: RESULT = t; :}
					|	BOOL					{: RESULT = new BooleanType(); :}
					|	INT						{: RESULT = new IntegerType(); :}
					|	UNIT					{: RESULT = new UnitType(); :}
					|	TYPEVARIABLE:tvar		{: RESULT = new TypeVariable(0, tvar); :}
					|	object_type:t			{: RESULT = t; :}
					;

object_type			::= LESS row_type:r GREATER
						{: RESULT = new ObjectType ( r ); :}
					;

row_type			::= IDENTIFIER:id COLON type:tau SEMI
						{: Identifier [] m = new Identifier [1];
						   m [0] = new Identifier(id);
						   MonoType [] types = new MonoType [1];
						   types [0] = tau;
						   RESULT = new RowType (m,types) ; :}
					|	IDENTIFIER:id COLON type:tau SEMI row_type:r
						{: Identifier [] m = new Identifier [r.getIdentifiers().length + 1];
						   m [0] = new Identifier(id);
						   System.arraycopy ( r.getIdentifiers() , 0 , m , 1 , r.getIdentifiers().length );
						   MonoType [] types = new MonoType [r.getTypes().length + 1];
						   types [0] = tau;
						   System.arraycopy ( r.getTypes() , 0 , types , 1 , r.getTypes().length );
						   RESULT = new RowType (m,types) ; :}
					;