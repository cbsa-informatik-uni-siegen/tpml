import de.unisiegen.tpml.core.expressions.*;
import de.unisiegen.tpml.core.types.*;
import de.unisiegen.tpml.core.exceptions.LanguageParserMultiException;
import de.unisiegen.tpml.core.languages.LanguageParserException;
import de.unisiegen.tpml.core.Messages ;
import java.text.MessageFormat;
import java.util.ArrayList;


/* Helper classes */
action code 
{:
  private static class IdTypePair 
  {
    Identifier id;
    MonoType tau;
    
    public IdTypePair(Identifier pId, MonoType pTau) 
    { 
      this.id = pId;
      this.tau = pTau; 
    }
  }
  
  private static class IdExprPair 
  {
    Identifier id;
    Expression expression;
    
    public IdExprPair(Identifier pId, Expression pExpression)
    { 
      this.id = pId; 
      this.expression = pExpression;
    }
  }
 
  private static class Error
  {
    public static void expectedTokenSequence(String ... pTokenSequence)
    {
      expectedTokenSequence (0, 0, pTokenSequence);
    }
    
    public static void expectedTokenSequence(int pLeft, int pRight , String ... pTokenSequence)
    {
      String or = Messages.getString ( "Parser.15" ) ;
      String result = "" ;
      for ( int i = 0; i < pTokenSequence.length ; i++)
      {
        if ( i == 0 )
        {
          result += "\"" + pTokenSequence [i] + "\"" ;
        }
        else if ( i == pTokenSequence.length - 1 )
        {
          result += " " + or + " \"" + pTokenSequence [i]+ "\"";
        }
        else
        {
          result += ", \"" + pTokenSequence [i]+ "\"";
        }
      }
      throw new LanguageParserException (  
        MessageFormat.format ( Messages.getString ( "Parser.14" ) , 
          result ) , pLeft, pRight);
    }
  }
  
  private static class Duplicated
  {
    public static void check(Row pRow)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Expression [ ] rowExpressions = pRow.getExpressions ( ) ;
      for ( int i = 0 ; i < rowExpressions.length ; i ++ )
      {
        if ( rowExpressions[i] instanceof Attribute )
        {
          negativeIdentifiers.clear();
          Attribute attribute1 = (Attribute) rowExpressions[i] ;
          for ( int j = i+1 ; j < rowExpressions.length ; j++ )
          {
            if ( rowExpressions[j] instanceof Attribute )
    	    {
    	      Attribute attribute2 = (Attribute) rowExpressions[j] ;
    	      if ( attribute1.getId().equals(attribute2.getId()))
    	      {
    	        negativeIdentifiers.add(attribute2.getId());
    	      }
    	    }
    	  }
    	  negativeIdentifiers.add ( attribute1.getId() ) ;
    	  LanguageParserMultiException.throwExceptionRow ( negativeIdentifiers ) ;
        }
      }
    }
    
    
    public static void check(Duplication pDuplication)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pDuplication.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionDuplication ( negativeIdentifiers ) ;
      }
    }
    
    
    public static void check(RowType pRowType)
    {
	  ArrayList <Identifier> negativeIdentifiers = new ArrayList <Identifier> ();
	  Identifier [] identifier = pRowType.getIdentifiers() ;
      for ( int i = 0 ; i < identifier.length ; i ++ )
      {
        negativeIdentifiers.clear();
        for ( int j = i+1 ; j < identifier.length ; j++ )
        {
          if ( identifier [i].equals(identifier[j]) )
    	  {
  	        negativeIdentifiers.add(identifier[j]);
    	  }
    	}
    	negativeIdentifiers.add ( identifier [i] ) ;
    	LanguageParserMultiException.throwExceptionRowType ( negativeIdentifiers ) ;
      }
    }
  }
:}


/* Binary operators */
terminal			PLUS;
terminal			MINUS;
terminal			STAR;
terminal			SLASH;
terminal			MOD;
terminal			EQUAL;
terminal			LESS;
terminal			GREATER;
terminal			LESSEQUAL;
terminal			GREATEREQUAL;

/* Logical operators */
terminal			AMPERAMPER;
terminal			BARBAR;
terminal			NOT;

/* Syntactic tokens */
terminal			ARROW;
terminal			COLON;
terminal			DOT;
terminal			LPAREN;
terminal			RPAREN;
terminal			PARENPAREN;

/* Keywords */
terminal			LAMBDA;
terminal			LET;
terminal			REC;
terminal			IN;
terminal			IF;
terminal			THEN;
terminal			ELSE;
terminal			TRUE;
terminal			FALSE;

/* Object */
terminal			OBJECT ;

terminal			END ;
terminal			HASHKEY ;
terminal			ATTRIBUTE ;
terminal			METHOD ;
terminal			SEMI ;
terminal			DUPLBEGIN ;
terminal			DUPLEND ;

/* Types */
terminal			BOOL;
terminal			INT;
terminal			UNIT;

/* Special tokens */
terminal Integer		NUMBER;
terminal Integer		TYPEVARIABLE;
terminal String			IDENTIFIER;
terminal String			SELF ;
terminal				COMMENT;


/* Non-Terminals */
non terminal Expression			expr;
non terminal Expression			simple_expr;
non terminal Expression[]		simple_expr_list;
non terminal Expression			constant;
non terminal Expression			operator;

/* Expression non terminals */
non terminal Identifier			identifier;
non terminal Expression			application;
non terminal InfixOperation 	infix_operation;
non terminal And				and;
non terminal Or					or;
non terminal Condition			condition;
non terminal Lambda				lambda;
non terminal Let				let;
non terminal CurriedLet			curried_let;
non terminal Recursion			recursion;
non terminal LetRec				let_rec;
non terminal CurriedLetRec		curried_let_rec;
non terminal ObjectExpr			object_expr;
non terminal Duplication		duplication;
non terminal Send				send;
non terminal Row				row;
non terminal Attribute			attribute;
non terminal Method				method;
non terminal CurriedMethod		curried_method;

/* Type non terminals */
non terminal MonoType			type;
non terminal MonoType			simple_type;
non terminal ObjectType			object_type;
non terminal RowType			row_type;

/* Helper non terminals */
non terminal IdExprPair[]		id_expr_list;
non terminal IdTypePair[]		id_type_list;
non terminal IdTypePair			id_type_pair;

/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence right	ARROW;

precedence right	BARBAR;					/* expr (e || e || e) */
precedence right	AMPERAMPER;				/* expr (e && e && e) */

precedence left		EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence left		PLUS, MINUS;
precedence left		STAR, SLASH, MOD;



/***************
 * Expressions *
 ***************/



expr				::=	simple_expr:e
						{: RESULT = e; :}
					|	object_expr:o
						{: RESULT = o; :}
					|   duplication:d
						{: RESULT = d; :}
					|   application:a
						{: RESULT = a; :}
					|   infix_operation:i
						{: RESULT = i; :}
					|	and:a
						{: RESULT = a; :}
					|	or:o
						{: RESULT = o; :}
					|	condition:c
						{: RESULT = c; :}
					|	lambda:l
						{: RESULT = l; :}
					|	let:l
						{: RESULT = l; :}
					|	curried_let:c
						{: RESULT = c; :}
					|	recursion:r
						{: RESULT = r; :}
					|	let_rec:l
						{: RESULT = l; :}
					|   curried_let_rec:c
						{: RESULT = c; :}
					;

simple_expr			::=	constant:c
						{: RESULT = c; :}
					|	identifier:id
						{: RESULT = id; :}
					|	send:s
						{: RESULT = s; :}
					|	LPAREN operator:o RPAREN
						{: RESULT = o; :}
					|	LPAREN expr:e RPAREN
						{: RESULT = e; :}
					;

identifier			::= IDENTIFIER:id
						{: RESULT = new Identifier (id,idleft,idright); :}
					|	SELF:s
						{: RESULT = new Identifier (s,sleft,sright); :}
					;

application			::= simple_expr:e simple_expr_list:l
						{: for (int n = 0; n < l.length; ++n) 
						   {
						     e = new Application(e, l[n],
						       e.getParserStartOffset ( ) , 
						       l[n].getParserEndOffset ( ) );
						   }
						   RESULT = e; :}
					;

infix_operation		::= expr:e1 PLUS:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newPlus(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 MINUS:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMinus(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 STAR:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMult(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 SLASH:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newDiv(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 MOD:op expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.newMod(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 EQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newEquals(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 LESS:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerThan(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 GREATER:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterThan(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 LESSEQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newLowerEqual(opleft, opright), e1, e2, e1left, e2right); :}
					|	expr:e1 GREATEREQUAL:op expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.newGreaterEqual(opleft, opright), e1, e2, e1left, e2right); :}
					;

and					::= expr:e1 AMPERAMPER expr:e2
						{: RESULT = new And(e1, e2,e1left,e2right); :}
					;

or					::= expr:e1 BARBAR expr:e2
						{: RESULT = new Or(e1, e2, e1left, e2right); :}
					;

condition			::= IF:i expr:e0 THEN expr:e1 ELSE expr:e2
						{: RESULT = new Condition(e0, e1, e2, ileft, e2right); :}
					;

lambda				::= LAMBDA:l IDENTIFIER:id DOT expr:e
						{: RESULT = new Lambda(new Identifier (id,idleft,idright), null, e, lleft, eright); :}
					|	LAMBDA:l IDENTIFIER:id COLON type:tau DOT expr:e
						{: RESULT = new Lambda(new Identifier (id,idleft,idright), tau, e, lleft, eright); :}
					;

let					::= LET:l IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
					|	LET:l IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
						{: RESULT = new Let(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
					;

curried_let			::= LET:l IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier (id,idleft,idright);
						   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right); :}
					|	LET:l IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier (id,idleft,idright);
						   types[0] = tau;
						   RESULT = new CurriedLet(identifiers, types, e1, e2, lleft, e2right); :}
					;

recursion			::= REC:r IDENTIFIER:id DOT expr:e
						{: RESULT = new Recursion(new Identifier (id,idleft,idright), null, e, rleft, eright); :}
					|	REC:r IDENTIFIER:id COLON type:tau DOT expr:e
						{: RESULT = new Recursion(new Identifier (id,idleft,idright), tau, e, rleft, eright); :}
					;

let_rec				::= LET:l REC IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(new Identifier (id,idleft,idright), null, e1, e2, lleft, e2right); :}
					|	LET:l REC IDENTIFIER:id COLON type:tau EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(new Identifier (id,idleft,idright), tau, e1, e2, lleft, e2right); :}
					;

curried_let_rec		::= LET:l REC IDENTIFIER:id id_type_list:itl EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier (id,idleft,idright);
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right); :}
					|	LET:l REC IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e1 IN expr:e2
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1];
						   for (int n = 0; n < itl.length; ++n) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   identifiers[0] = new Identifier (id,idleft,idright);
						   types[0] = tau;
						   RESULT = new CurriedLetRec(identifiers, types, e1, e2, lleft, e2right); :}
					;

object_expr			::= OBJECT:o LPAREN SELF:id RPAREN END:end
						{: Expression [] e = new Expression [0];
						   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), null, new Row (e), oleft, endright); :}
					|   OBJECT:o LPAREN SELF:id COLON type:tau RPAREN END:end
						{: Expression [] e = new Expression [0];
						   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), tau, new Row (e), oleft, endright); :}
					|	OBJECT:o LPAREN SELF:id RPAREN row:r END:end
						{: Duplicated.check(r);
						   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), null, r, oleft, endright); :}
					|	OBJECT:o LPAREN SELF:id COLON type:tau RPAREN row:r END:end
						{: Duplicated.check(r);
						   RESULT = new ObjectExpr (new Identifier (id,idleft,idright), tau, r, oleft, endright); :}
					/* Error without type*/
					|	OBJECT LPAREN SELF RPAREN row
						{: Error.expectedTokenSequence("end"); :}					
					|	OBJECT LPAREN SELF RPAREN
						{: Error.expectedTokenSequence("r end"); :}
					/* Error with and without type*/
					|	OBJECT LPAREN SELF
						{: Error.expectedTokenSequence(") r end", ": \u03C4) r end"); :}
					|	OBJECT LPAREN
						{: Error.expectedTokenSequence("self) r end", "self: \u03C4) r end"); :}
					|	OBJECT
						{: Error.expectedTokenSequence("(self) r end", "(self: \u03C4) r end"); :}
					/* Error with type*/
					|	OBJECT LPAREN SELF COLON type RPAREN row
						{: Error.expectedTokenSequence("end"); :}		
					|	OBJECT LPAREN SELF COLON type RPAREN
						{: Error.expectedTokenSequence("r end"); :}				
					|	OBJECT LPAREN SELF COLON type
						{: Error.expectedTokenSequence(") r end"); :}						
					|	OBJECT LPAREN SELF COLON
						{: Error.expectedTokenSequence("\u03C4) r end"); :}
					;
					
duplication			::= DUPLBEGIN:b id_expr_list:iel DUPLEND:e
						{: Expression [] tmpE = new Expression [iel.length];
						   Identifier [] tmpI = new Identifier [iel.length];
						   for ( int i = 0 ; i < iel.length ; i++ )
						   {
						     tmpE [i] = iel [i].expression;
						     tmpI [i] = iel [i].id;
						     tmpI [i].setSet (Identifier.Set.ATTRIBUTE );
						   }
						   Duplication d = new Duplication (tmpI, tmpE, bleft, eright);
						   Duplicated.check(d);
						   RESULT = d; :}
					|	DUPLBEGIN:b DUPLEND:e
						{: Expression [] tmpE = new Expression [0];
						   Identifier [] tmpI = new Identifier [0];
						   RESULT = new Duplication (tmpI, tmpE, bleft, eright); :}
					;

send				::= simple_expr:e HASHKEY IDENTIFIER:id
						{: Identifier idM = new Identifier (id,idleft,idright) ;
						   idM.setSet (Identifier.Set.MESSAGE );
						   RESULT = new Send ( e, idM, eleft, idright) ; :}
					/* Error */
					|	simple_expr:e HASHKEY
						{: Error.expectedTokenSequence("id"); :}	
					;
					
row					::= attribute:a
						{: Expression [] e = new Expression [1];
						   e [0] = a;
						   RESULT = new Row (e, aleft, aright); :}
					|	attribute:a row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
						   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = a ;
						   RESULT = new Row (e, aleft, rright); :}
					|	method:m
						{: Expression [] e = new Expression [1];
						   e [0] = m;
						   RESULT = new Row (e, mleft, mright); :}
					|	method:m row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    					   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = m ;
						   RESULT = new Row (e, mleft, rright); :}
					|	curried_method:cm
						{: Expression [] e = new Expression [1];
						   e [0] = cm;
						   RESULT = new Row (e, cmleft, cmright); :}
					|	curried_method:cm row:r
						{: Expression [ ] e = new Expression [ r.getExpressions().length + 1 ] ;
    					   System.arraycopy ( r.getExpressions() , 0 , e , 1 , r.getExpressions().length ) ;
    					   e [0] = cm ;
						   RESULT = new Row (e, cmleft, rright); :}
					;

attribute			::=	ATTRIBUTE:a IDENTIFIER:id EQUAL expr:e SEMI:s
						{: Identifier idA = new Identifier (id,idleft,idright) ;
						   idA.setSet (Identifier.Set.ATTRIBUTE );
						   RESULT = new Attribute (idA, null, e, aleft, sright); :}
					|	ATTRIBUTE:a IDENTIFIER:id COLON type:tau EQUAL expr:e SEMI:s
						{: Identifier idA = new Identifier (id,idleft,idright) ;
						   idA.setSet (Identifier.Set.ATTRIBUTE );
						   RESULT = new Attribute (idA, tau, e, aleft, sright); :}
					;

method				::=	METHOD:m IDENTIFIER:id EQUAL expr:e SEMI:s
						{: Identifier idM = new Identifier (id,idleft,idright) ;
						   idM.setSet (Identifier.Set.MESSAGE );
						   RESULT = new Method (idM, null, e, mleft, sright); :}
					|	METHOD:m IDENTIFIER:id COLON type:tau EQUAL expr:e SEMI:s
						{: Identifier idM = new Identifier (id,idleft,idright) ;
						   idM.setSet (Identifier.Set.MESSAGE );
						   RESULT = new Method (idM, tau, e, mleft, sright); :}
					;

curried_method		::=	METHOD:m IDENTIFIER:id id_type_list:itl EQUAL expr:e SEMI:s
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1 ];
						   for (int n = 0; n < itl.length; n++) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   Identifier idM = new Identifier (id,idleft,idright) ;
						   idM.setSet (Identifier.Set.MESSAGE );
						   identifiers [0] = idM ;
						   types [0] = null ;
						   RESULT = new CurriedMethod(identifiers, types, e, mleft, sright); :}
					|	METHOD:m IDENTIFIER:id id_type_list:itl COLON type:tau EQUAL expr:e SEMI:s
						{: Identifier[] identifiers = new Identifier[itl.length + 1];
						   MonoType[] types = new MonoType[itl.length + 1 ];
						   for (int n = 0; n < itl.length; n++) 
						   {
						     identifiers[n + 1] = itl[n].id;
						     types[n + 1] = itl[n].tau;
						   }
						   Identifier idM = new Identifier (id,idleft,idright) ;
						   idM.setSet (Identifier.Set.MESSAGE );
						   identifiers [0] = idM ;
						   types [0] = tau ;
						   RESULT = new CurriedMethod (identifiers, types, e, mleft, sright); :}
					;	   

id_expr_list		::= IDENTIFIER:id EQUAL expr:e
						{: IdExprPair [] list = new IdExprPair [1];
						   list [0] = new IdExprPair (new Identifier (id,idleft,idright), e);
						   RESULT = list; :}
					|	IDENTIFIER:id EQUAL expr:e SEMI id_expr_list:iel
						{: IdExprPair [] list = new IdExprPair [iel.length+1];
						   System.arraycopy(iel, 0, list, 1, iel.length);
						   list [0] = new IdExprPair (new Identifier (id,idleft,idright), e);
						   RESULT = list; :}
					;

simple_expr_list	::=	simple_expr:e
						{: RESULT = new Expression[] { e }; :}
					|	simple_expr_list:l simple_expr:e
						{: RESULT = new Expression[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = e; :}
					;

constant			::=	PARENPAREN:c
						{: RESULT = new UnitConstant(cleft, cright); :}
					|	TRUE:c
						{: RESULT = new BooleanConstant(true, cleft, cright); :}
					|	FALSE:c
						{: RESULT = new BooleanConstant(false, cleft, cright); :}
					|	NUMBER:n
						{: RESULT = new IntegerConstant(n.intValue(), nleft, nright); :}
					|	NOT:c
						{: RESULT = new Not(cleft, cright); :}
					;

operator			::=	PLUS:op		
						{: RESULT = ArithmeticOperator.newPlus(opleft, opright); :}
					|	MINUS:op		
						{: RESULT = ArithmeticOperator.newMinus(opleft, opright); :}
					|	STAR:op			
						{: RESULT = ArithmeticOperator.newMult(opleft, opright); :}
					|	SLASH:op			
						{: RESULT = ArithmeticOperator.newDiv(opleft, opright); :}
					|	MOD:op			
						{: RESULT = ArithmeticOperator.newMod(opleft, opright); :}
					|	EQUAL:op			
						{: RESULT = RelationalOperator.newEquals(opleft, opright); :}
					|	LESS:op			
						{: RESULT = RelationalOperator.newLowerThan(opleft, opright); :}
					|	GREATER:op		
						{: RESULT = RelationalOperator.newGreaterThan(opleft, opright); :}
					|	LESSEQUAL:op		
						{: RESULT = RelationalOperator.newLowerEqual(opleft, opright); :}
					|	GREATEREQUAL:op
						{: RESULT = RelationalOperator.newGreaterEqual(opleft, opright); :}
					;


id_type_list		::= id_type_list:l id_type_pair:itp
						{: RESULT = new IdTypePair[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = itp; :}
					|	id_type_pair:itp
						{: RESULT = new IdTypePair[] { itp }; :}
					;

id_type_pair		::= LPAREN IDENTIFIER:id COLON type:tau RPAREN
						{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), tau); :}
					|	IDENTIFIER:id
						{: RESULT = new IdTypePair(new Identifier (id,idleft,idright), null); :}
					;
				

/*********
 * Types *
 *********/


type				::=	simple_type:t
						{: RESULT = t; :}
					|	type:t1 ARROW type:t2
						{: RESULT = new ArrowType(t1, t2, t1left, t2right); :}
					;

simple_type			::=	LPAREN:l type:t RPAREN:r
						{: RESULT = t; :}
					|	BOOL:b
						{: RESULT = new BooleanType(bleft, bright); :}
					|	INT:i
						{: RESULT = new IntegerType(ileft, iright); :}
					|	UNIT:u
						{: RESULT = new UnitType(uleft, uright); :}
					|	TYPEVARIABLE:tvar
						{: RESULT = new TypeVariable(0, tvar, tvarleft, tvarright); :}
					|	object_type:t
						{: RESULT = t; :}
					;

object_type			::= LESS:l row_type:r GREATER:g
						{: Duplicated.check(r);
						   RESULT = new ObjectType ( r, lleft, gright); :}
					|	LESS:l GREATER:g
						{: Identifier [] m = new Identifier [0];
						   MonoType [] types = new MonoType [0];
						   RESULT = new ObjectType ( new RowType (m, types), lleft, gright); :}
					;

row_type			::= IDENTIFIER:id COLON type:tau SEMI:s
						{: Identifier [] m = new Identifier [1];
						   m [0] = new Identifier (id,idleft,idright);
						   MonoType [] types = new MonoType [1];
						   types [0] = tau;
						   RESULT = new RowType (m, types, idleft, sright) ; :}
					|	IDENTIFIER:id COLON type:tau SEMI row_type:r
						{: Identifier [] m = new Identifier [r.getIdentifiers().length + 1];
						   m [0] = new Identifier (id,idleft,idright);
						   System.arraycopy ( r.getIdentifiers() , 0 , m , 1 , r.getIdentifiers().length );
						   MonoType [] types = new MonoType [r.getTypes().length + 1];
						   types [0] = tau;
						   System.arraycopy ( r.getTypes() , 0 , types , 1 , r.getTypes().length );
						   RESULT = new RowType (m, types, idleft, rright) ; :}
					;