#ProofRuleException
ProofRuleException.0=Cannot apply {0} to {1}

# General strings
AbstractLanguage.0=The language {0} does not include a type system
ProofGuessException.0=Cannot guess next proof step for [{0}]
InterpreterModel.0=The evaluation got stuck

# Interpreter strings
AbstractInterpreterProofModel.0=The evaluation seems to diverge, canceled automatic completion

# Parser strings
Parser.0=Unexpected end of file
Parser.1=Syntax error on token "{0}"
Parser.2=The row consist of attributes with the same identifier "{0}"
Parser.3=No disjunct sets of {0}-Identifier "{1}"
Parser.4=The duplication consist of identifiers with the same name "{0}"
Parser.5=The row-type consist of mnethods names with the same identifier "{0}"
Parser.6=Integer constant "{0}" too large
Parser.7=Unexpected end of comment
Parser.8=Unexpected end of projection, arity expected
Parser.9=Unexpected end of projection, underline expected
Parser.10=Unexpected end of projection, index expected
Parser.11=Unexpected character "{0}" in projection, arity expected
Parser.12=Unexpected character "{0}" in projection, underline expected
Parser.13=Unexpected character "{0}" in projection, index expected
Parser.14=Token sequence {0} expected
Parser.15=or

# Exceptions
Exception.0=The substitution is not defined because of free attribute- or self-identifiers
Exception.1=The identifier of the duplication is not an attribute-identifier in the row 
Exception.2=The arity "{0}" of a projection must be greater than 0
Exception.3=The index "{0}" of a projection must be greater than 0
Exception.4=The index "{0}" of a projection must be less or equal than the arity "{1}"

# BigStep strings
BigStep.0=The node is already completed

# TypeChecker strings
UnificationException.0=Cannot unify {0}

# L0 strings
L0BigStepProofRuleSet.0=(BETA-V) can only be applied if the operand is already a value
L0BigStepProofRuleSet.1=(VAL) can only be applied to values
L0Language.0=The simplest possible programming language with only \u03BB-abstraction, identifiers and applications.
L0Language.1=Pure untyped \u03BB calculus

# L0CBN strings
LxCBNBigStepProofRuleSet.0=(APP-LEFT) can only be applied if e1 is not already a value
LxCBNBigStepProofRuleSet.1=(APP-RIGHT) can only be applied if e1 is already a value
LxCBNBigStepProofRuleSet.2=(APP-RIGHT) can only be applied if e1 is not a instance of Lambda
L0CBNLanguage.0=The language L0CBN has the same functions like the language L0, but uses a Call by Name semantic.
L0CBNLanguage.1=Language L0 with Call by Name semantic

# L1 strings
L1BigStepProofRuleSet.0=(OP) cannot be used here, use (CONS) instead
L1Language.0=The simply typed \u03BB calculus extends the pure untyped \u03BB calculus with a simple type system, the let-binding, conditional execution and constants. It also allows to use operators in infix expressions.
L1Language.1=Simply typed \u03BB calculus

# L1CBN strings
L1CBNLanguage.0=The language L1CBN has the same functions like the language L1, but uses a Call by Name semantic.
L1CBNLanguage.1=Language L1 with Call by Name semantic

# L2 strings
L2Language.0=The language L2 combines the simply typed \u03BB calculus with recursive expressions.
L2Language.1=Applied \u03BB calculus with recursion

# L2CBN strings
L2CBNLanguage.0=The language L2CBN has the same functions like the language L2, but uses a Call by Name semantic.
L2CBNLanguage.1=Language L2 with Call by Name semantic

# L2O strings
L2OLanguage.0=The language L2O extends L2 with objects
L2OLanguage.1=Applied \u03BB calculus with objects

# L3 strings
L3BigStepProofRuleSet.0=(HD) can only be applied if the operand is already a value
L3BigStepProofRuleSet.1=(HD) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.2=(IS-EMPTY-FALSE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.3=(IS-EMPTY-FALSE) and (IS-EMPTY-TRUE) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.4=(IS-EMPTY-TRUE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.5=(TL) can only be applied if the operand is already a value
L3BigStepProofRuleSet.6=(TL) can only be applied if the operand is either a list or an application of cons to a pair
L3Language.0=The language L3 adds support for lists and tuples and provides a polymorphic type system.
L3Language.1=Applied \u03BB calculus with polymorphic type system

# L4 strings
L4Language.0=The language L4 extends L3 with imperative concepts, including syntactic sugar for sequential execution and loops.
L4Language.1=Applied \u03BB calculus with imperative concepts