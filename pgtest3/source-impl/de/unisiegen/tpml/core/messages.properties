#Exception
IllegalArgumentException.0=The node {1} is already completed
IllegalArgumentException.1=The node {1} is invalid for the model

#ProofRuleException
ProofRuleException.0=Cannot apply {0} to {1}
ProofRuleException.1=The first child "{0}" of the row is not a method
ProofRuleException.2=The first child "{0}" of the row is not an attribute
ProofRuleException.3=The row has no child expressions
ProofRuleException.4=The row "{0}" has one or more child expressions
ProofRuleException.5=The object "{0}" has a wrong type

#SubTypingException
SubTypingException.0=Subtype {0}  don't has all methods of Supertype {1}
SubTypingException.1=This won't help you
SubTypingException.2=To often applied the "TRANS" rule
SubTypingException.3=Types of SubType {0} and SuperType {1} not equal
SubTypingException.4=Subtype {0}  has not  all mehtods of supertype {1}
SubTypingException.5=Types are not equal
SubTypingException.6=The length of {0} and {1} are not equal

# General strings
AbstractLanguage.0=The language {0} does not include a type system
ProofGuessException.0=Cannot guess next proof step for [{0}]
InterpreterModel.0=The evaluation got stuck

# Interpreter strings
AbstractInterpreterProofModel.0=The evaluation seems to diverge, canceled automatic completion

# Parser strings
Parser.0=Unexpected end of file
Parser.1=Syntax error on token "{0}"
Parser.2=The row consist of attributes with the same identifier "{0}"
Parser.3=No disjunct sets of {0}-Identifier "{1}"
Parser.4=The duplication consist of identifiers with the same name "{0}"
Parser.5=The row-type consist of method names with the same identifier "{0}"
Parser.6=Integer constant "{0}" too large
Parser.7=Unexpected end of comment
Parser.8=Unexpected end of projection, arity expected
Parser.9=Unexpected end of projection, underline expected
Parser.10=Unexpected end of projection, index expected
Parser.11=Unexpected character "{0}" in projection, arity expected
Parser.12=Unexpected character "{0}" in projection, underline expected
Parser.13=Unexpected character "{0}" in projection, index expected
Parser.14=Token sequence {0} expected to complete "{1}"
Parser.15=or
Parser.16=Token "{0}" expected

# Exceptions
Exception.0=The substitution is not defined because of free attribute- or self-identifiers
Exception.1=The identifier of the duplication is not an attribute-identifier in the row
Exception.2=The arity "{0}" of a projection must be greater than 0
Exception.3=The index "{0}" of a projection must be greater than 0
Exception.4=The arity "{0}" of a projection must be greater or equal to the index "{1}"
Exception.5=The index "{0}" of a projection must be less or equal to the arity "{1}"
Exception.6=The type name "{0}" can not be equal to the tau of the rec type

# BigStep strings
BigStep.0=The node is already completed

# TypeChecker strings
UnificationException.0=Cannot unify {0}
UnificationException.1=Recursive types are not supported. Can not unify "{0} = {1}"

# L0 strings
L0BigStepProofRuleSet.0=(BETA-V) can only be applied if the operand is already a value
L0BigStepProofRuleSet.1=(VAL) can only be applied to values
L0Language.0=The simplest possible programming language with only \u03BB-abstraction, identifiers and applications.
L0Language.1=Pure untyped \u03BB calculus

# L0CBN strings
LxCBNBigStepProofRuleSet.0=(APP-LEFT) can only be applied if e1 is not already a value
LxCBNBigStepProofRuleSet.1=(APP-RIGHT) can only be applied if e1 is already a value
LxCBNBigStepProofRuleSet.2=(APP-RIGHT) can only be applied if e1 is not a instance of Lambda
L0CBNLanguage.0=The language L0CBN has the same functions like the language L0, but uses a Call by Name semantic.
L0CBNLanguage.1=Language L0 with Call by Name semantic

# L1 strings
L1BigStepProofRuleSet.0=(OP) cannot be used here, use (CONS) instead
L1Language.0=The simply typed \u03BB calculus extends the pure untyped \u03BB calculus with a simple type system, the let-binding, conditional execution and constants. It also allows to use operators in infix expressions.
L1Language.1=Simply typed \u03BB calculus

# L1CBN strings
L1CBNLanguage.0=The language L1CBN has the same functions like the language L1, but uses a Call by Name semantic.
L1CBNLanguage.1=Language L1 with Call by Name semantic

# L2 strings
L2Language.0=The language L2 combines the simply typed \u03BB calculus with recursive expressions.
L2Language.1=Applied \u03BB calculus with recursion

# L2CBN strings
L2CBNLanguage.0=The language L2CBN has the same functions like the language L2, but uses a Call by Name semantic.
L2CBNLanguage.1=Language L2 with Call by Name semantic

# L2O strings
L2OLanguage.0=The language L2O extends L2 with objects
L2OLanguage.1=Applied \u03BB calculus with objects

# L3 strings
L3BigStepProofRuleSet.0=(HD) can only be applied if the operand is already a value
L3BigStepProofRuleSet.1=(HD) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.2=(IS-EMPTY-FALSE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.3=(IS-EMPTY-FALSE) and (IS-EMPTY-TRUE) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.4=(IS-EMPTY-TRUE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.5=(TL) can only be applied if the operand is already a value
L3BigStepProofRuleSet.6=(TL) can only be applied if the operand is either a list or an application of cons to a pair
L3Language.0=The language L3 adds support for lists and tuples and provides a polymorphic type system.
L3Language.1=Applied \u03BB calculus with polymorphic type system

# L4 strings
L4Language.0=The language L4 extends L3 with imperative concepts, including syntactic sugar for sequential execution and loops.
L4Language.1=Applied \u03BB calculus with imperative concepts