#Exception
IllegalArgumentException.0=The node {1} is already completed
IllegalArgumentException.1=The node {1} is invalid for the model

#ProofRuleException
ProofRuleException.0=Cannot apply {0} to {1}
ProofRuleException.1=The first child "{0}" of the row is not a method
ProofRuleException.2=The first child "{0}" of the row is not an attribute
ProofRuleException.3=The row has no child expressions
ProofRuleException.4=The row "{0}" has one or more child expressions
ProofRuleException.5=The object "{0}" has a wrong type
ProofRuleException.6=The row type "{0}" has methods with the same identifier, but different types

#SubTypingException
SubTypingException.0=Subtype {0}  don't has all methods of Supertype {1}
SubTypingException.1=This won't help you
SubTypingException.2=To often applied the "TRANS" rule
SubTypingException.3=Types of SubType {0} and SuperType {1} not equal
SubTypingException.4=Subtype {0}  has not  all mehtods of supertype {1}
SubTypingException.5=Types are not equal
SubTypingException.6=The length of {0} and {1} are not equal

#MinimalTypingException
MinimalTypingException.0=Boolean Type expected. Could not update {0}
MinimalTypingException.1=e1 must be instance of ArrowType. Can not update {0}
MinimalTypingException.2=Please enter type for {0}
MinimalTypingException.3={0} is no subtype of {1}
MinimalTypingException.4=Type Error. Could not update {0}
MinimalTypingException.5=Types not seen before
MinimalTypingException.6=Type of m is not in phi. Could not update {0}
MinimalTypingException.7=Types are not equal. Could not update {0}
MinimalTypingException.8=Type is not empty
MinimalTypingException.9={0} is free in this Expression

# General strings
AbstractLanguage.0=The language {0} does not include a type system
ProofGuessException.0=Cannot guess next proof step for "{0}"
ProofGuessException.1=Cannot guess next proof step
InterpreterModel.0=The evaluation got stuck

# Interpreter strings
AbstractInterpreterProofModel.0=The evaluation seems to diverge, canceled automatic completion

# Scanner strings
Scanner.0=If you want to multiply, enter "( *)"

# Parser strings
Parser.0=Unexpected end of file
Parser.1=Syntax error on token "{0}"
Parser.2=The row consist of attributes with the same identifier "{0}"
Parser.3=No disjunct sets of {0}-Identifier "{1}"
Parser.4=The duplication consist of identifiers with the same name "{0}"
Parser.5=The row-type consist of method names with the same identifier "{0}"
Parser.6=Integer constant "{0}" too large
Parser.7=Unexpected end of comment
Parser.8=Unexpected end of projection, arity expected
Parser.9=Unexpected end of projection, underline expected
Parser.10=Unexpected end of projection, index expected
Parser.11=Unexpected character "{0}" in projection, arity expected
Parser.12=Unexpected character "{0}" in projection, underline expected
Parser.13=Unexpected character "{0}" in projection, index expected
Parser.14=Token sequence {0} expected to complete {1}
Parser.15=or
Parser.16=Token "{0}" expected
Parser.17=Click for automatic completion
Parser.18=One of the types of the coercion contains type variables
Parser.19=The body consist of attributes with the same identifier "{0}"

# Exceptions
Exception.0=The substitution is not defined because of free attribute- or self-identifiers
Exception.1=The identifier of the duplication is not an attribute-identifier in the row
Exception.2=The arity "{0}" of a projection must be greater than 0
Exception.3=The index "{0}" of a projection must be greater than 0
Exception.4=The arity "{0}" of a projection must be greater or equal to the index "{1}"
Exception.5=The index "{0}" of a projection must be less or equal to the arity "{1}"
Exception.6=The type name "{0}" can not be equal to the tau of the rec type
Exception.7=The tau of the rec type "{0}" can not be an instance of rec type
Exception.8=The language {0} does not include a big stepper
Exception.9=The language {0} does not include a minimal typing system
Exception.10=The language {0} does not include a sub typing system
Exception.11=The language {0} does not include a sub typing rec system
Exception.12=The language {0} does not include a type system
L2CLanguage.13=The language {0} does not include a type inference system
Exception.14=The language {0} does not include a small stepper

# BigStep strings
BigStep.0=The node is already completed

# TypeChecker strings
UnificationException.0=Cannot unify "{0} = {1}"
UnificationException.1=Type-Inference for recursive types is not supported. Cannot unify "{0} = {1}"
UnificationException.2=Cannot unify "{0} = {1}", because of the different number of methods
UnificationException.3=Cannot unify "{0} = {1}", because of the different methods
UnificationException.4=Cannot unify "{0} = {1}", because of the different number of types

# L0 strings
L0BigStepProofRuleSet.0=(BETA-V) can only be applied if the operand is already a value
L0BigStepProofRuleSet.1=(VAL) can only be applied to values
L0Language.0=The simplest possible programming language with only \u03BB-abstraction, identifiers and applications.
L0Language.1=Pure untyped \u03BB calculus

# L0CBN strings
LxCBNBigStepProofRuleSet.0=(APP-LEFT) can only be applied if e1 is not already a value
LxCBNBigStepProofRuleSet.1=(APP-RIGHT) can only be applied if e1 is already a value
LxCBNBigStepProofRuleSet.2=(APP-RIGHT) can only be applied if e1 is not a instance of Lambda
L0CBNLanguage.0=The language L0CBN has the same functions like the language L0, but uses a Call by Name semantic.
L0CBNLanguage.1=Language L0 with Call by Name semantic

# L1 strings
L1BigStepProofRuleSet.0=(OP) cannot be used here, use (CONS) instead
L1Language.0=The simply typed \u03BB calculus extends the pure untyped \u03BB calculus with a simple type system, the let-binding, conditional execution and constants. It also allows to use operators in infix expressions.
L1Language.1=Simply typed \u03BB calculus

# L1CBN strings
L1CBNLanguage.0=The language L1CBN has the same functions like the language L1, but uses a Call by Name semantic.
L1CBNLanguage.1=Language L1 with Call by Name semantic

#L1SubType strings
L1SubTypeLanguage.0=The Language L1SubType bases on L1 and allows to check the subtype relation for two types. 
L1SubTypeLanguage.1=Subtyping Language with the Types of L1

# L2 strings
L2Language.0=The language L2 combines the simply typed \u03BB calculus with recursive expressions.
L2Language.1=Applied \u03BB calculus with recursion

#L2SubType strings
L2SubTypeLanguage.0=The Language L1SubType has the same functions like the language L1SubType, but with the types of L2. 
L2SubTypeLanguage.1=Subtyping Language with the Types of L2

# L2CBN strings
L2CBNLanguage.0=The language L2CBN has the same functions like the language L2, but uses a Call by Name semantic.
L2CBNLanguage.1=Language L2 with Call by Name semantic

# L2O strings
L2OLanguage.0=The language L2O extends L2 with objects.
L2OLanguage.1=Applied \u03BB calculus with objects

#L2OSubType strings
L2OSubTypeLanguage.0=The Language L2OSubType has the same functions like the language L1SubType, but with the types of L2O. 
L2OSubTypeLanguage.1=Subtyping Language with the Types of L2O

# L2C strings
L2CLanguage.0=The language L2C extends L2O with classes.
L2CLanguage.1=Applied \u03BB calculus with classes

#L2CSubType strings
L2CSubTypeLanguage.0=The Language L2CSubType has the same functions like the language L1SubType, but with the types of L2C. 
L2CSubTypeLanguage.1=Subtyping Language with the Types of L2C


# L3 strings
L3BigStepProofRuleSet.0=(HD) can only be applied if the operand is already a value
L3BigStepProofRuleSet.1=(HD) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.2=(IS-EMPTY-FALSE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.3=(IS-EMPTY-FALSE) and (IS-EMPTY-TRUE) can only be applied if the operand is either a list or an application of cons to a pair
L3BigStepProofRuleSet.4=(IS-EMPTY-TRUE) can only be applied if the operand is already a value
L3BigStepProofRuleSet.5=(TL) can only be applied if the operand is already a value
L3BigStepProofRuleSet.6=(TL) can only be applied if the operand is either a list or an application of cons to a pair
L3Language.0=The language L3 adds support for lists and tuples and provides a polymorphic type system.
L3Language.1=Applied \u03BB calculus with polymorphic type system
L3SmallStepProofRuleSet.0=The e1 has to be an instance of Tuple

#L3SubType strings
L3SubTypeLanguage.0=The Language L3SubType has the same functions like the language L1SubType, but with the types of L3. 
L3SubTypeLanguage.1=Subtyping Language with the Types of L3

# L4 strings
L4Language.0=The language L4 extends L3 with imperative concepts, including syntactic sugar for sequential execution and loops.
L4Language.1=Applied \u03BB calculus with imperative concepts

#L4SubType strings
L4SubTypeLanguage.0=The Language L4SubType has the same functions like the language L1SubType, but with the types of L4. 
L4SubTypeLanguage.1=Subtyping Language with the Types of L4