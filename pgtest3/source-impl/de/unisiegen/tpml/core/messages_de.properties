#Exception
IllegalArgumentException.0=Auf den Knoten {1} wurde bereits eine Regel angewendet
IllegalArgumentException.1=Der Knoten {1} ist nicht zulässig für das Model

#ProofRuleException
ProofRuleException.0=Kann {0} nicht auf {1} anwenden
ProofRuleException.1=Das erste Kind "{0}" der Reihe ist keine Methode
ProofRuleException.2=Das erste Kind "{0}" der Reihe ist kein Attribut
ProofRuleException.3=Die Reihe hat keine Kind-Expressions
ProofRuleException.4=Die Reihe "{0}" hat ein oder mehr Kind-Expressions
ProofRuleException.5=Das Objekt "{0}" hat einen falschen Typ
ProofRuleException.6=Der Reihen-Typ "{0}" hat Methoden mit gleichem Namen, aber unterschiedlichen Typen

#SubTypingException
SubTypingException.0=SubType {0} hat nicht alle Methoden des Obertyps {1}
SubTypingException.1=Operation nicht sinnvoll
SubTypingException.2=Die Regel  "TRANS" wurde zu oft angewendet
SubTypingException.3=Typen des Subtypen {0} und des Obertypen  {1}  stimmen nicht über ein
SubTypingException.4=Subtyp {0}  hat nicht alle Methoden des Obertypen  {1}
SubTypingException.5=Die Typen sind nicht gleich
SubTypingException.6=Die Längen von {0} und {1} sind nicht gleich

# General strings
AbstractLanguage.0=Die Sprache {0} enth\u00e4lt kein Typsystem
ProofGuessException.0=Die n\u00e4chste Regel f\u00fcr den Knoten "{0}" konnte nicht bestimmt werden
ProofGuessException.1=Die n\u00e4chste Regel f\u00fcr den Knoten konnte nicht bestimmt werden
InterpreterModel.0=Die Auswertung ist steckengeblieben

# Interpreter strings
AbstractInterpreterProofModel.0=Die Auswertung scheint zu divergieren, automatische Vervollst\u00e4ndigung abgebrochen

# Parser strings
Parser.0=Unerwartetes Dateiende
Parser.1=Syntaxfehler bei Symbol "{0}"
Parser.2=Die Reihe besteht aus Attributen mit dem gleichen Identifier "{0}"
Parser.3=Keine disjunkten Mengen bei {0}-Identifier "{1}"
Parser.4=Die Duplication besteht aus Identifiern mit dem gleichen Namen "{0}"
Parser.5=Der Reihen-Typ besteht aus Methoden Namen mit dem gleichen Identifier "{0}"
Parser.6=Integer Konstante "{0}" ist zu gro\u00DF
Parser.7=Unerwartetes Ende des Kommentars
Parser.8=Unerwartetes Ende der Projektion, Stelligkeit erwartet
Parser.9=Unerwartetes Ende der Projektion, Unterstrich erwartet
Parser.10=Unerwartetes Ende der Projektion, Index erwartet
Parser.11=Unerwartetes Zeichen "{0}" in der Projektion, Stelligkeit erwartet
Parser.12=Unerwartetes Zeichen "{0}" in der Projektion, Unterstrich erwartet
Parser.13=Unerwartetes Zeichen "{0}" in der Projektion, Index erwartet
Parser.14=Symbolfolge {0} erwartet, um "{1}" zu vervollst\u00E4ndigen
Parser.15=oder
Parser.16=Symbol "{0}" erwartet

# Exceptions
Exception.0=Die Substitution ist aufgrund von freien Attribut- oder Self-Identifiern nicht definiert
Exception.1=Ein Identifier der Duplikation ist kein Attribut-Identifier in der Reihe
Exception.2=Die Stelligkeit "{0}" der Projektion muss gr\u00F6\u00DFer als 0 sein
Exception.3=Der Index "{0}" der Projektion muss gr\u00F6\u00DFer als 0 sein
Exception.4=Die Stelligkeit "{0}" der Projektion muss gr\u00F6\u00DFer oder gleich dem Index "{1}" sein
Exception.5=Der Index "{0}" der Projektion muss kleiner oder gleich der Stelligkeit "{1}" sein
Exception.6=Der Type-Name darf nicht gleich dem Tau des Rec-Types sein 
Exception.7=Das Tau des Rec-Types "{0}" darf keine Instanz von Rec-Type sein 

# BigStep strings
BigStep.0=Der Knoten ist bereits vollst\u00E4ndig

# TypeChecker strings
UnificationException.0=Kann "{0} = {1}" nicht unifizieren
UnificationException.1=Type-Inference für rekursive Typen wird nicht unterstützt. Kann "{0} = {1}" nicht unifizieren
UnificationException.2=Kann "{0} = {1}" nicht unifizieren, da die Anzahl der Methoden unterschiedlich ist
UnificationException.3=Kann "{0} = {1}" nicht unifizieren, da die Methoden sich unterscheiden
UnificationException.4=Kann "{0} = {1}" nicht unifizieren, da die Anzahl der Typen unterschiedlich ist

# L0 strings
L0BigStepProofRuleSet.0=(BETA-V) kann nur angewandt werden, wenn der Operand bereits ein Wert ist
L0BigStepProofRuleSet.1=(VAL) kann nur auf Werte angewandt werden
L0Language.0=Die einfachste denkbare Programmiersprache bestehend aus \u03BB-Abstraktionen, Bezeichnern und Applikationen.
L0Language.1=Reiner ungetypter \u03BB Kalk\u00fcl

# L0CBN strings
LxCBNBigStepProofRuleSet.0=(APP-LEFT) kann nur angewandt werden, wenn e1 noch kein Value ist
LxCBNBigStepProofRuleSet.1=(APP-RIGHT) kann nur angewandt werden, wenn e1 schon ein Value ist
LxCBNBigStepProofRuleSet.2=(APP-RIGHT) kann nur angewandt werden, wenn v1 kein Lambda ist 
L0CBNLanguage.0=Die Sprache L0CBN bietet die selben Funktionen wie die Sprache L0, benutzt aber eine Call by Name Semantik.
L0CBNLanguage.1=Die Sprache L0 mit Call by Name Semantik

# L1 strings
L1BigStepProofRuleSet.0=(OP) kann hier nicht angewandt werden, verwenden Sie stattdessen (CONS) 
L1Language.0=Der einfache getypte \u03BB Kalk\u00fcl erweitert den einfachen ungetypten \u03BB Kalk\u00fcl um ein einfaches Typsystem, den Bindungsmechanismus let, bedingte Ausf\u00fchrung und Konstanten. Die Sprache erlaubt dar\u00fcber hinaus Operatoren in Infix-Schreibweise zu benutzen.
L1Language.1=Einfach getypter \u03BB Kalk\u00fcl

# L1CBN strings
L1CBNLanguage.0=Die Sprache L1CBN bietet die selben Funktionen wie die Sprache L1, benutzt aber eine Call by Name Semantik.
L1CBNLanguage.1=Die Sprache L1 mit Call by Name Semantik

# L2 strings
L2Language.0=Die Sprache L2 kombiniert den einfach getypten \u03BB Kalk\u00fcl mit rekursiven Ausdr\u00fccken. 
L2Language.1=Angewandter \u03BB Kalk\u00fcl mit Rekursion

# L2CBN strings
L2CBNLanguage.0=Die Sprache L2CBN bietet die selben Funktionen wie die Sprache L2, benutzt aber eine Call by Name Semantik.
L2CBNLanguage.1=Die Sprache L2 mit Call by Name Semantik

# L2O strings
L2OLanguage.0=Die Sprache L2O erweitert L2 um Objekte.
L2OLanguage.1=Angewandter \u03BB Kalk\u00fcl mit Objekten

# L3 strings
L3BigStepProofRuleSet.0=(HD) kann nur angewandt werden, wenn der Operand bereits ein Wert ist
L3BigStepProofRuleSet.1=(HD) kann nur auf Listen oder Applikationen von cons auf Paare angewandt werden
L3BigStepProofRuleSet.2=(IS-EMPTY-FALSE) kann nur angewandt werden, wenn der Operand bereits ein Wert ist
L3BigStepProofRuleSet.3=(IS-EMPTY-FALSE) und (IS-EMPTY-TRUE) k\u00f6nn nur auf Listen oder Applikationen von cons auf Paare angewandt werden
L3BigStepProofRuleSet.4=(IS-EMPTY-TRUE) kann nur angewandt werden, wenn der Operand bereits ein Wert ist
L3BigStepProofRuleSet.5=(TL) kann nur angewandt werden, wenn der Operand bereits ein Wert ist
L3BigStepProofRuleSet.6=(TL) kann nur auf Listen oder Applikationen von cons auf Paare angewandt werden
L3Language.0=Die Sprache L3 beinhaltet Listen und Tupel und verf\u00fcgt dar\u00fcber hinaus \u00fcber ein polymorphes Typsystem.
L3Language.1=Angewandter \u03BB Kalk\u00fcl mit polymorphen Typsystem

# L4 strings
L4Language.0=Die Sprache L4 erweitert L3 um imperative Konzepte, einschliesslich syntaktischem Zucker f\u00fcr sequentielle Ausf\u00fchrung und Schleifen.
L4Language.1=Angewandter \u03BB Kalk\u00fcl mit imperativen Konzepten