%%
%% Subtyping
%%


\chapter{Subtyping}
\label{kapitel:Subtyping}


Im vorangegangen Kapitel wurde eine einfache objekt-orientierte Programmiersprache eingef\"uhrt,
basierend auf den Grundlagen einer einfach getypten, funktionalen Programmiersprache. In diesem
Kapitel betrachten wir die Erweiterung dieser Programmiersprache um ein fundamentales,
objekt-orientiertes Konzept: \define{Subtyping}.

Subtyping ist eines der Schl\"usselkonzepte der objekt-orientierten Denkweise, obwohl es in den
meisten g\"angigen Programmiersprachen nicht in Reinform, sondern nur gekoppelt an andere Konzepte
wie \define{Vererbung} auftritt. In der Literatur, insbesondere im Bereich der Softwaretechnik,
wird Subtyping oft als {\em subtype polymorphism} oder einfach {\em polymorphism} bezeichnet, obwohl
diese Bezeichnung eigentlich falsch ist, da es sich beim Subtyping lediglich eine um m\"ogliche Form
der Polymorphie handelt\footnote{\cite[S. 340f]{Pierce02} beschreibt unterschiedliche Formen
von Polymorphie.}.

Wir werden in diesem Kapitel Subtyping als eigenst\"andiges Konzept untersuchen. Dazu \"ubertragen wir
die in \cite[S. 182ff]{Pierce02} f\"ur eine funktionale Programmiersprache mit Records beschriebenen
\"Uberlegungen auf die im vorherigen Kapitel eingef\"uhrte Programmiersprache \Lot.


%%%%%%%%%%%%%%%%
%% Motivation %%
%%%%%%%%%%%%%%%%

\section{Motivation}


%%%%%%%%%%%%%%%%%%%%%%%%
%% Die Subtyprelation %%
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Die Subtyprelation}

\begin{definition}[Subtyping Regeln] \label{definition:Subtyping:Subtyping_Regeln}
  Die Subtyprelation $\le$ ist die kleinste Relation auf $\setType \times \setType$, die
  sich mit den folgenden Regeln herleiten l\"a"st. \\[5mm]
  \begin{tabular}{ll}
    \RN{S-Refl}       & $\tau \le \tau$  \\[1mm]
    \RN{S-Trans}      & $\RULE{\tau_1 \le \tau_2 \quad \tau_2 \le \tau_3}
                              {\tau_1 \le \tau_3}$ \\[4mm]
    \RN{S-Arrow}      & $\RULE{\tau_1' \le \tau_1 \quad \tau_2 \le \tau_2'}
                              {\typeArrow{\tau_1}{\tau_2} \le \typeArrow{\tau_1'}{\tau_2'}}$ \\[4mm]
    \RN{S-Obj-Width}  & $\typeObject{m_1:\tau_1;\ldots;m_{n+k}:\tau_{n+k}}
                         \le \typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}$ \\[1mm]
    \RN{S-Obj-Depth}  & $\RULE{\tau_i \le \tau_i' \text{ f\"ur } i=1,\ldots,n}
                              {\typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}
                               \le \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}}$
  \end{tabular} \\[7mm]
\end{definition}

Betrachtet man diese Definition der Subtyping-Regeln, so ist unmittelbar ersichtlich, dass die Subtyprelation
selbst reflexiv und transitiv ist. Wir wollen nun zeigen, dass die Subtyprelation eine partielle Ordnung auf
der Menge der Typen ist. Dazu zeigen wir zun\"achst, dass die Relation auch antisymmetrisch ist.

\begin{lemma} \label{lemma:Subtyping:Antisymmetrie}
  $\forall \tau_1,\tau_2 \in \setType: \tau_1 \le \tau_2 \wedge \tau_2 \le \tau_1\,\Rightarrow\,\tau_1 = \tau_2$
\end{lemma}

\begin{beweis}
  Wir f\"uhren den Beweis mittels Induktion \"uber die L\"ange der Herleitung von $\tau_1 \le \tau_2$ und
  Fallunterscheidung nach der zuletzt angewandten Regel.
  \PROOFCASEbeg
    \item $\tau_1 \le \tau_2$ mit Regel \RN{S-Refl}. Dann folgt unmittelbar $\tau_1 = \tau_2$.

    \item $\tau_1 \le \tau_2$ mit Regel \RN{S-Trans}. Dann existiert ein $\tau_3\in\setType$ mit $\tau_1 \le \tau_3$
          und $\tau_3 \le \tau_2$. Aus $\tau_2 \le \tau_1$ und $\tau_1 \le \tau_3$ folgt mit Regel \RN{S-Trans}
          $\tau_2 \le \tau_3$, und mit $\tau_3 \le \tau_2$ folgt nach Induktionsvoraussetzung $\tau_2 = \tau_3$.
          Analog folgt $\tau_3 \le \tau_1$ aus $\tau_3 \le \tau_2$ und $\tau_2 \le \tau_1$, und mit $\tau_1 \le \tau_3$
          gilt nach Induktionsvoraussetzung $\tau_1 \le \tau_3$. Zusammenfassend folgt als $\tau_1 = \tau_3 = \tau_2$.

    \item $\tau_1 \le \tau_2$ mit Regel \RN{S-Arrow} kann nur mit $\tau_1 = \typeArrow{\tau_1'}{\tau_1''}$
          und $\tau_2 = \typeArrow{\tau_2'}{\tau_2''}$ aus Pr\"amissen der Form $\tau_2' \le \tau_1'$ und
          $\tau_1'' \le \tau_2''$ folgen. $\tau_2 \le \tau_1$ kann also nur mit den Regeln \RN{S-Refl},
          \RN{S-Trans} und \RN{S-Arrow} hergeleitet werden:
          \begin{enumerate}
            \item $\tau_2 \le \tau_1$ mit \RN{S-Refl}. Dann folgt unmittelbar $\tau_2 = \tau_1$.

            \item $\tau_2 \le \tau_1$ mit \RN{S-Trans}. Dann existiert nach Voraussetzung ein $\tau_3\in\setType$
                  mit $\tau_2 \le \tau_3$ und $\tau_3 \le \tau_1$. Aus $\tau_1 \le \tau_2$ und $\tau_2 \le \tau_3$
                  folgt mit Regel \RN{S-Trans} $\tau_1 \le \tau_3$, und nach Induktionsvoraussetzung somit
                  $\tau_1 = \tau_3$. Analog folgt aus $\tau_3 \le \tau_1$ und $\tau_1 \le \tau_2$ dann $\tau_3 \le \tau_2$
                  und mit Induktionsvoraussetzung $\tau_3 = \tau_2$. Zusammenfassend gilt also $\tau_1 = \tau_3 = \tau_2$.

            \item $\tau_2 \le \tau_1$ mit \RN{S-Arrow} kann ausschliesslich aus Pr\"amissen der Form
                  $\tau_1' \le \tau_2'$ und $\tau_2'' \le \tau_1''$ entstanden sein. Mit Induktionsvoraussetzung
                  folgt $\tau_1' = \tau_2'$ und $\tau_1'' = \tau_2''$, also insbesondere
                  $\typeArrow{\tau_1'}{\tau_1''} = \typeArrow{\tau_2'}{\tau_2''}$.
          \end{enumerate}

    \item $\tau_1 \le \tau_2$ mit Regel \RN{S-Obj-Width}. Dann ist
          $\tau_1 = \typeObject{m_1:\tau_1';\ldots;m_{n+k}:\tau_{n+k}'}$ und
          $\tau_2 = \typeObject{m_1:\tau_1';\ldots;m_{n}:\tau_{n}'}$ mit $n,k\in\setN$. Also ist $\tau_2 \le \tau_1$
          nur mit den Regeln \RN{S-Refl}, \RN{S-Trans}, \RN{S-Obj-Depth} und \RN{S-Obj-Width} herleitbar:
          \begin{enumerate}
            \item $\tau_2 \le \tau_1$ mit \RN{S-Refl} oder \RN{S-Trans} folgt analog zum vorhergehenden Fall.

            \item $\tau_2 \le \tau_1$ mit \RN{S-Obj-Depth} oder \RN{S-Obj-Width} kann nur mit $k = 0$ folgen,
                  also ist $\tau_2 = \tau_1$.
          \end{enumerate}

    \item $\tau_1 \le \tau_2$ mit Regel \RN{S-Obj-Depth} kann nur mit
          $\tau_1 = \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$ und
          $\tau_2 = \typeObject{m_1:\tau_1'';\ldots;m_n:\tau_n''}$ aus Pr\"amissen der Form $\tau_i' \le \tau_i''$
          f\"ur $i=1,\ldots,n$ folgen. Also kann $\tau_2 \le \tau_1$ ausschliesslich mit den Regel \RN{S-Refl},
          \RN{S-Trans}, \RN{S-Obj-Depth} und \RN{S-Obj-Width} hergeleitet werden:
          \begin{enumerate}
            \item $\tau_2 \le \tau_1$ mit \RN{S-Refl} oder \RN{S-Trans} folgt analog zum vorhergehenden Fall.

            \item $\typeObject{m_1:\tau_1'';\ldots;m_n:\tau_n''} \le \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$ mit
                  Regel \RN{S-Obj-Depth} kann nur aus $\tau_i'' \le \tau_i'$ f\"ur $i=1,\ldots,n$ folgen. Nach
                  Induktionsvoraussetzung gilt $\tau_i' = \tau_i''$ f\"ur $i=1,\ldots,n$ und es folgt $\tau_1 = \tau_2$.

            \item $\typeObject{m_1:\tau_1'';\ldots;m_n:\tau_n''} \le \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$ mit
                  Regel \RN{S-Obj-Width} kann nur mit $\tau_i'' = \tau_i'$ f\"ur $i=1,\ldots,n$ folgen. Also ist
                  $\tau_1 = \tau_2$.
          \end{enumerate}
  \PROOFCASEend
\end{beweis}

Damit ist nun klar, dass die Relation $\le$ auch antisymmetrisch ist, und wir k\"onnen die eigentlich interessante
Aussage als Proposition formulieren.

\begin{proposition}
  $(\setType, \le)$ ist eine partielle Ordnung.
\end{proposition}

\begin{beweis}
  Eine partielle Ordnung ist reflexiv, transitiv und antisymmetrisch.
  Reflexivit\"at und Transitivit\"at folgen unmittelbar aus der Definition des
  Regelwerks, und wegen Lemma~\ref{lemma:Subtyping:Antisymmetrie} folgt die
  Antisymmetrie.
\end{beweis}

Bevor wir nun zur zentralen Aussage dieses Abschnittes kommen, dem sogenannten Subtyping-Lemma, betrachten
wir zun\"achst noch einige weitere Eigenschaften der Subtyprelation.

\begin{lemma}[Maximale und minimale Typen] \label{lemma:Subtyping:Maximale_Typen} \
  \begin{enumerate}
    \item $\forall \tau\in\setType, \tau_\beta\in\{\typeBool,\typeInt,\typeUnit\}:
            \tau \le \tau_\beta \vee \tau_\beta \le \tau \,\Rightarrow\, \tau = \tau_\beta$
    \item $\forall \tau\in\setType: \typeObject{} \le \tau \,\Rightarrow\, \tau = \typeObject{}$
  \end{enumerate}
\end{lemma}
%
Im wesentlichen besagt das Lemma, dass Basistypen bez\"uglich der Subtyprelation sowohl maximal
als auch minimal sind, denn es existiert weder ein gr\"o"serer noch ein kleinerer Typ. Desweiteren
ist der leere Objekttyp maximal. Wir werden dieses Lemma benutzen um nachfolgend eine Verallgemeinerung,
das sogenannte Subtyping-Lemma, zu beweisen.
%
\begin{beweis} \
  \begin{enumerate}
    \item Der Beweis erfolgt durch Induktion \"uber die L\"ange der Herleitung von $\tau \le \tau_\beta$ und
          Fallunterscheidung nach der zuletzt angewandten Regel. Offensichtlich kommen f\"ur
          $\tau \le \tau_\beta$ nur die Regeln \RN{S-Refl} und \RN{S-Trans} in Frage.
          \PROOFCASEbeg
            \item $\tau \le \tau_\beta$ mit \RN{S-Refl}, dann ist $\tau = \tau_\beta$.

            \item $\tau \le \tau_\beta$ mit \RN{S-Trans}. Dann existiert ein $\tau'\in\setType$ mit $\tau \le \tau'$ und
                  $\tau' \le \tau_\beta$. Nach Induktionsvoraussetzung gilt $\tau' = \tau_\beta$ und $\tau = \tau'$, also
                  $\tau = \tau_\beta$.
          \PROOFCASEend
          F\"ur $\tau_\beta \le \tau$ folgt ebenso einfach $\tau_\beta = \tau$.

    \item Wir f\"uhren den Beweis wiederum durch Induktion \"uber die L\"ange der Herleitung von
          $\typeObject{} \le \tau$ und Fallunterscheidung nach der zuletzt angewandten Regel. Dazu
          sind lediglich die Regeln \RN{S-Refl}, \RN{S-Trans}, \RN{S-Obj-Depth} und \RN{S-Obj-Width}
          zu betrachten.
          \PROOFCASEbeg
            \item F\"ur $\typeObject{} \le \tau$ mit \RN{S-Refl} gilt $\tau = \typeObject{}$.

            \item F\"ur $\typeObject{} \le \tau$ mit \RN{S-Trans} existiert nach Definition ein
                  $\tau' \in \setType$ mit $\typeObject{} \le \tau'$ und $\tau' \le \tau$. Nach
                  Induktionsvoraussetzung folgt $\tau' = \typeObject{}$ aus $\typeObject{} \le \tau'$.
                  Wiederum mit Induktionsvoraussetzung folgt schliesslich aus $\tau' = \typeObject{}$
                  und $\tau' \le \tau$ das gew\"unschte Ergebnis $\tau = \tau' = \typeObject{}$.

            \item $\typeObject{} \le \tau$ kann mit \RN{S-Obj-Depth} nur dann hergeleitet werden, wenn
                  $\tau = \typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}$ mit $n = 0$ gilt, also
                  $\tau = \typeObject{}$.

            \item Analog folgt $\tau = \typeObject{}$ f\"ur den Fall, dass \RN{S-Obj-Width} die zuletzt angewandte
                  Regel ist.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}

Basierend auf diesen Erkenntnissen k\"onnen wir nun noch einige leicht zu beweisende Eigenschaften
der Subtyprelation festhalten, die intuitiv sofort ersichtlich sind. Da es sich hierbei um mehr
oder weniger triviale Beweise handelt, formulieren wir die Aussagen lediglich als Korollar.

\begin{korollar} \
  \begin{enumerate}
    \item $(\setType, \le)$ ist keine totale Ordnung.
    \item Es existiert kein gr\"o"ster Typ bez\"uglich der Subtyprelation.
    \item Es existiert kein kleinster Typ bez\"uglich der Subtyprelation.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Die Beweise erfolgen indirekt. Wir betrachten dazu nur den ersten Teil.
  \begin{enumerate}
    \item Angenommen die Ordnung $(\setType,\le)$ w\"are total, dann m\"usste f\"ur alle Typen
          $\tau_1,\tau_2\in\setType$ entweder $\tau_1 \le \tau_2$ oder $\tau_2 \le \tau_1$ gelten. Sei
          dazu $\tau_1 = \typeBool$ und $\tau_2 = \typeInt$. Nach Lemma~\ref{lemma:Subtyping:Maximale_Typen}
          (Maximale und minimale Typen) folgt sowohl aus $\typeBool \le \typeInt$ wie auch aus
          $\typeInt \le \typeBool$, dass $\typeBool = \typeInt$ gelten w\"urde, also der gesuchte Widerspruch.

    \item Angenommen $\tau_\top \in \setType$ w\"are der gr\"o"ste Typ bez\"uglich der Subtyprelation. Insbesondere
          m\"usste dann $\typeInt \le \tau_\top$ und $\typeObject{} \le \tau_\top$ gelten. Wegen
          Lemma~\ref{lemma:Subtyping:Maximale_Typen} (Maximale und minimale Typen) w\"are dann folglich $\tau_\top = \typeInt$ und
          $\tau_\top = \typeObject{}$, also $\typeObject{} = \typeInt$, der gesuchte Widerspruch.

    \item Ist ebenso offensichtlich und l\"a"st sich leicht zu einem Widerspruch f\"uhren.
  \end{enumerate}
\end{beweis}

Nach diesen Vor\"uberlegungen k\"onnen wir nun das zentrale Lemma \"uber die Subtyprelation $\le$ formulieren
und beweisen. Im wesentlichen dient das Lemma einem leichteren Umgang mit der Subtyprelation, so dass in den
sp\"ateren Beweisen nicht st\"andig die \RN{S-Trans}-Regel ber\"ucksichtigt werden muss.

\begin{lemma}[Subtyping-Lemma] \label{lemma:Subtyping:Subtyping_Lemma}
  $\tau \le \tau'$ gilt genau dann, wenn eine der folgenden Aussagen zutrifft:
  \begin{enumerate}
    \item $\tau = \tau'$
    \item $\tau = \typeArrow{\tau_1}{\tau_2}$ und $\tau' = \typeArrow{\tau_1'}{\tau_2'}$ mit
          $\tau_1' \le \tau_1$ und $\tau_2 \le \tau_2'$
    \item $\tau = \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}$ und
          $\tau' = \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}$ mit \\
          $\{m_1',\ldots,m_l'\}\subseteq\{m_1,\ldots,m_k\}$ und $\tau_i \le \tau_j'$ f\"ur alle
          $i,j\in\setN$ mit $m_i = m_j'$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wir beweisen die \"Aquivalenz in zwei Schritten.
  \begin{itemize}
    \item["`$\Leftarrow$"']%
          F\"ur diese Richtung gen\"ugt es zu zeigen, dass sich f\"ur die angegebenen F\"alle die
          Aussage $\tau \le \tau'$ mit den Regeln f\"urs Subtyping aus den Bedingungen herleiten l\"asst.
          \begin{enumerate}
            \item Aus $\tau = \tau'$ folgt unmittelbar $\tau \le \tau'$ mit Regel \RN{S-Refl}.

            \item Aus $\tau_1' \le \tau_1$ und $\tau_2 \le \tau_2'$ folgt mit Regel \RN{S-Arrow}
                  $\typeArrow{\tau_1}{\tau_2} \le \typeArrow{\tau_1'}{\tau_2'}$, also
                  $\tau \le \tau'$.

            \item F\"ur die Formel
                  $\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k} \le \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}$
                  geben wir eine Herleitung an, wobei bei der R\"uckw\"artsanwendung der Regel \RN{S-Trans} hierbei
                  zun\"achst ein Zwischentyp zu finden ist, welcher genau die Methodennamen von $\tau$ mit
                  den Methodentypen von $\tau'$ enth\"alt. Sei dazu im Folgenden
                  \EQNbeg
                     \tau_i'' & = & \CASEbeg
                                      \tau_j' & \text{falls } m_i=m_j' \\
                                      \tau_i  & \text{sonst.}
                                    \CASEend
                  \EQNend
                  \vspace{2mm}\[
                    \inferrule*[Left=S-Trans]%
                    {
                      \inferrule*[Left=S-Obj-Depth]%
                      {
                        \tau_1 \le \tau_1'' \\ \ldots \\ \tau_k \le \tau_k''
                      }%
                      {\typeObject{{m_i:\tau_i}^{i=1,\ldots,k}} \le \typeObject{{m_i:\tau_i''}^{i=1,\ldots,k}}}
                      \\
                      \inferrule*[lab=S-Obj-Width]%
                      {}
                      {\typeObject{{m_i:\tau_i''}^{i=1,\ldots,k}} \le \typeObject{{m_i':\tau_i'}^{i=1,\ldots,l}}}
                    }%
                    {\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k} \le \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}}
                  \]\vspace{2mm}
                  $\tau_i \le \tau_i''$ folgt hierbei entweder nach Voraussetzung, falls $\tau_i'' = \tau_j'$ f\"ur
                  $m_i = m_j'$, oder mit Regel \RN{S-Refl}, da in diesem Fall $\tau_i'' = \tau_i$ gilt.
          \end{enumerate}

    \item["`$\Rightarrow$"']%
          Induktion \"uber die L\"ange der Herleitung von $\tau \le \tau'$ und Fallunterscheidung
          nach der zuletzt angewandten Regel.
          \PROOFCASEbeg
            \item $\tau \le \tau'$ mit Regel \RN{S-Refl}, dann gilt $\tau = \tau'$.

            \item $\tau \le \tau'$ mit Regel \RN{S-Trans}, dann existiert ein $\tau''$ mit $\tau \le \tau''$
                  und $\tau'' \le \tau'$. Nach Induktionsvoraussetzung gilt jeweils eine der Aussagen des
                  Lemmas f\"ur $\tau \le \tau''$ und $\tau'' \le \tau$. Durch Fallunterscheidung nach der
                  Form von $\tau''$ zeigen wir, dass dann auch f\"ur $\tau \le \tau'$ eine der Aussagen gilt:
                  \begin{enumerate}
                    \item F\"ur $\tau'' \in \{\typeBool,\typeInt,\typeUnit\}$ folgt nach
                          Lemma~\ref{lemma:Subtyping:Maximale_Typen} $\tau = \tau'' = \tau'$.

                    \item F\"ur $\tau'' = \typeArrow{\tau_1''}{\tau_2''}$ muss
                          $\tau = \typeArrow{\tau_1}{\tau_2}$ und $\tau' = \typeArrow{\tau_1'}{\tau_2'}$
                          gelten. O.B.d.A. gilt dann $\tau_1'' \le \tau_1$, $\tau_2 \le \tau_2''$,
                          $\tau_1' \le \tau_1''$ und $\tau_2'' \le \tau_2'$. Mit Regel \RN{S-Trans} folgt
                          unmittelbar $\tau_1' \le \tau_1$ und $\tau_2' \le \tau_2$.

                    \item Der Fall $\tau = \typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}$ verl\"auft analog.
                  \end{enumerate}

            \item $\tau \le \tau'$ mit Regel \RN{S-Arrow}, dann ist $\tau = \typeArrow{\tau_1}{\tau_2}$ und
                  $\tau' = \typeArrow{\tau_1'}{\tau_2'}$ und es gilt $\tau_1' \le \tau_1$ und $\tau_2 \le \tau_2'$.

            \item $\tau \le \tau'$ mit \RN{S-Obj-Width} kann nur aus
                  $\tau = \typeObject{m_1:\tau_1;\ldots;m_{n+k}:\tau_{n+k}}$ und
                  $\tau' = \typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}$ folgen, und es gilt
                  $\{m_1,\ldots,m_n\} \subseteq \{m_1,\ldots,m_{n+k}\}$. Mit Regel \RN{S-Refl} folgt
                  dar\"uberhinaus $\tau_i \le \tau_i$ f\"ur $i=1,\ldots,n$.

            \item $\tau \le \tau'$ mit \RN{S-Obj-Depth} kann nur mit
                  $\tau = \typeObject{m_1:\tau_1;\ldots;m_n:\tau_n}$ und
                  $\tau' = \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$ aus
                  $\tau_i \le \tau_i'$ f\"ur $i=1,\ldots,n$ folgen. Offensichtlich
                  gilt $\{m_1,\ldots,m_n\} \subseteq \{m_1,\ldots,m_n\}$.
          \PROOFCASEend
  \end{itemize}
\end{beweis}%
%
Das Subtyping-Lemma l\"asst sich f\"ur Funktionstypen auch auf eine etwas andere Weise ausdr\"ucken,
die den Einsatz des Lemmas in den sp\"ateren Beweis vielleicht noch etwas deutlicher hervorhebt.
Betrachten wir dazu das folgende Korollar.

\begin{korollar}
  Seien $\tau, \tau_1, \tau_2 \in \setType$. Dann gilt:
  \begin{enumerate}
    \item $\tau \le \typeArrow{\tau_1}{\tau_2} \,\Rightarrow\, \exists \tau_1',\tau_2' \in \setType:
            \tau = \typeArrow{\tau_1'}{\tau_2'} \wedge \tau_1 \le \tau_1' \wedge \tau_2' \le \tau_2$
    \item $\typeArrow{\tau_1}{\tau_2} \le \tau \,\Rightarrow\, \exists \tau_1',\tau_2' \in \setType:
            \tau = \typeArrow{\tau_1'}{\tau_2'} \wedge \tau_1' \le \tau_1 \wedge \tau_2 \le \tau_2'$
  \end{enumerate}
\end{korollar}%
%
In Worten besagt das Korollar, dass ein Funktionstyp immer nur zusammen mit einem anderen Funktionstyp
in der Subtyprelation stehen kann, wobei die Typen der Parameter kontravariant und die Typen der
Ergebnisse kovariant bez\"uglich der Subtyprelation sein m\"ussen.
%
\begin{beweis}
  Folgt unmittelbar aus Lemma~\ref{lemma:Subtyping:Subtyping_Lemma}.
\end{beweis}%
%
Ein \"ahnliches -- wenn auch weniger \"ubersichtliches -- Korollar l\"a"st sich f\"ur Objekttypen aus dem
Lemma herleiten.
%
\begin{korollar}
  Seien $\tau, \tau_1',\ldots,\tau_l' \in \setType$ und $m_1',\ldots,m_l' \in \setMethod$. Dann gilt:
  \begin{enumerate}
    \item $\tau \le \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'} \\
           \Rightarrow\, \exists k \ge l:\exists m_1,\ldots,m_k\in\setMethod:
                         \exists \tau_1,\ldots,\tau_k \in \setType: \\
           \hspace*{6mm} \tau = \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}
                         \wedge \{m_1',\ldots,m_l'\} \subseteq \{m_1,\ldots,m_k\} \\
           \hspace*{6mm} \wedge [\forall 1 \le i \le k: \forall 1 \le j \le l:
                         m_i = m_j' \,\Rightarrow\, \tau_i \le \tau_j']$
    
    \item $\typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'} \le \tau \\
           \Rightarrow\, \exists k \le l:\exists m_1,\ldots,m_k \in\setMethod:
                         \exists \tau_1,\ldots,\tau_k\in\setType: \\
           \hspace*{6mm} \tau = \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}
                         \wedge \{m_1,\ldots,m_k\} \subseteq \{m_1',\ldots,m_l'\} \\
           \hspace*{6mm} \wedge [\forall 1 \le i \le k: \forall 1 \le j \le l:
                         m_i = m_j' \,\Rightarrow\, \tau_j' \le \tau_i]$
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt ebenso unmittelbar aus Lemma~\ref{lemma:Subtyping:Subtyping_Lemma}.
\end{beweis}


%%%%%%%%%%%%%%%%%%%%%%%
%% Die Sprache Losub %%
%%%%%%%%%%%%%%%%%%%%%%%

\section{Die Sprache \Losub}

Nachdem wir uns nun mit der Subtyprelation vertraut gemacht haben, und einige wichtige Eigenschaften
bewiesen haben, wollen wir uns nun der Frage zuwenden, wie Subtyping nun in eine
typsichere objekt-orientierte Programmiersprache eingebaut werden kann. F\"ur \define{structual
typing} existieren dazu heute im wesentlichen zwei Ans\"atze:
\begin{itemize}
  \item Beim {\em impliziten Subtyping} wird w\"ahrend der Typ\"uberpr\"ufung mit der
        {\em Subsumption-Regel}\index{Subtyping!Subsumption} automatisch zu einem gr\"o"seren Typ
        \"ubergegangen sofern notwendig. Die Syntax und Semantik der Programmiersprache bleiben dabei
        unangetastet.

  \item Beim {\em expliziten Subtyping} hingegen ist der Programmier daf\"ur
        verantwortlich, durch sogenannte {\em coercions}\index{Subtyping!Coercion} im Programmtext, einen
        \"Ubergang zu einem Supertyp durchzuf\"uhren.
\end{itemize}
W\"ahrend das implizite Subtyping in der Theorie am verbreitetsten ist, wird in der Praxis f\"ur
{\em structural typing} fast ausschliesslich Subtyping mit coercions verwendet\footnote{Im Gegensatz
zu objekt-orientierten Programmiersprachen mit opaquen Typen, wie z.B. Java oder C++, bei denen
durchgehend Subsumption zum Einsatz kommt.}. Der wesentliche Grund hierf\"ur liegt in der Performance
des generierten Maschinencodes (vgl. dazu \cite[S.200ff]{Pierce02}).

In diesem Abschnitt werden wir die Programmiersprache \Lot\ aus dem vorangegangen Kapitel um 
Subsumption\index{Subtyping!Subsumption} zur Sprache \Losub\ erweitern, und den Aspekt der Typsicherheit
dieser Programmiersprache betrachten. Die Syntax und Semantik der Programmiersprache \Losub\ stimmen
mit der Programmiersprache \Lot\ \"uberein, es kommt lediglich eine neue Typregel hinzu.

\begin{definition}[G\"ultige Typurteile f\"ur \Losub] \label{definition:Losub:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Losub}
  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\psi}$ heisst {\em g\"ultig} f\"ur
  \Losub, wenn es sich mit dem Typregeln von \Lot\ (aus
  Definition~\ref{definition:Lot:Gueltige_Typurteile}) sowie der Subsumption-Regel \\[5mm]
  \begin{tabular}{ll}
    \RN{Subsume} & $ \RULE{\Tjm{\Gamma}{e}{\tau} \quad \tau \le \tau'}
                          {\Tjm{\Gamma}{e}{\tau'}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst.
\end{definition}

Es ist leicht zu sehen, dass durch die Hinzunahme der \RN{Subsume}-Regel die Typeindeutig verloren
geht. Betrachten wir dazu beispielsweise den folgenden Ausdruck.
\EQNbeg
  \expObject{\self:\typeObject{m:\typeInt}}{\rowMethod{m}{1}{}}
\EQNend
Nur mit den Typregeln der Sprache \Lot\ l\"asst sich f\"ur diesen Ausdruck in der leeren
Typumgebung der Objekttyp $\typeObject{m:\typeInt}$ wie folgt herleiten.
\vspace{2mm}\[
  \inferrule*[left=Object]%
  {
    \inferrule*[Left=Method]%
    {
      \inferrule*[Left=Const]%
      {
        \inferrule*[lab=Int]%
        {}
        {\tj{1}{\typeInt}}
      }
      {\Tj{[\self:\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}]}{1}{\typeInt}}%
      \\
      \inferrule*[lab=Empty]%
      {}
      {\Tj{[\self:\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}]}{\rowEpsilon}{\rtypeEmpty}}%
    }
    {\Tj{[\self:\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}]}{\rowMethod{m}{1}{\rowEpsilon}}{(\rtypeMethod{m}{\typeInt}{\rtypeEmpty})}}
  }
  {\Tj{[\,]}{\expObject{\self:\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}}{\rowMethod{m}{1}{\rowEpsilon}}}{\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}}}
\] \vspace*{2mm}
%
Andererseits l\"asst sich f\"ur den gleichen Ausdruck in der gleichen Typumgebung ebenfalls
der leere Objekttyp $\typeObject{}$ herleiten, durch Anwenden der \RN{Subsume}-Regel im
Anschluss an die obige Herleitung des Objekttyps.
%
\vspace{2mm}\[
  \inferrule*[left=Subsume]%
  {
    \inferrule*[Left=Object]%
    {\vdots}
    {\Tj{[\,]}{\bobject\ldots\bend}{\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}}}
    \\
    \inferrule*[lab=S-Obj-Width]%
    {}
    {\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}} \le \typeObject{\rtypeEmpty}}
  }
  {\Tj{[\,]}{\expObject{\self:\typeObject{\rtypeMethod{m}{\typeInt}{\rtypeEmpty}}}{\rowMethod{m}{1}{\rowEpsilon}}}{\typeObject{\rtypeEmpty}}}
\] \vspace*{2mm}
%
Vergleicht man die \RN{Subsume}-Regel mit den bisherigen Typregeln, so wird auch sofort die Ursache dieser
Uneindeutigkeit offensichtlich. Bisher waren Typregeln eineindeutig mit der syntaktischen Form eines Ausdrucks
verkn\"upft, zum Beispiel war \RN{App} die einzige auf Applikationen anwendbare Regel und ebenso war \RN{App}
ausschliesslich auf Applikationen anwendbar. Im Typsystem der Sprache \Losub\ kann nun aber unabh\"angig von
der syntaktischen Form des Ausdrucks immer entweder die aus der Sprache \Lot\ geerbte Typregel oder die
\RN{Subsume}-Regel angewandt werden, wie an den beiden Typherleitungen f\"ur den Ausdruck
\EQNbeg
  \expObject{\self:\typeObject{m:\typeInt}}{\rowMethod{m}{1}{}}
\EQNend
gut zu ersehen ist. Wir werden sp\"ater auf das Thema Typeindeutigkeit in einer Sprache mit Subtyping eingehen.
F\"ur den Augenblick halten wir lediglich fest, dass die Typeindeutigkeit in der Sprache \Losub\ nicht gilt.


%%%%%%%%%%%%%%%%%%%
%% Typsicherheit %%
%%%%%%%%%%%%%%%%%%%

\subsection{Typsicherheit} \index{Typsicherheit!Subtyping}

Wir wollen nun f\"ur die Sprache \Losub, \"ahnlich wie zuvor f\"ur die Sprache \Lot, zeigen, dass die
Berechnung eines wohlgetypten, abgeschlossenen Ausdrucks nicht stecken bleiben kann, also die Typsicherheit
der Programmiersprache \Losub. Dazu \"uberzeugen wir uns zun\"achst davon, dass diese nicht trivialerweise
aus der Typsicherheit der Programmiersprache \Lot\ folgt, indem wir einen Ausdruck suchen, der in \Losub\ 
wohlgetypt ist, nicht aber in \Lot. Betrachten wir dazu die Funktion
\EQNbeg
  \expAbstr{o:\typeObject{m:\typeInt}}{\expSend{o}{m}},
\EQNend
die ein Objekt mit einer Methode $m$ von Typ $\typeInt$ als Parameter erwartet und diesem Objekt die Nachricht
$m$ sendet. F\"ur diese Funktion l\"asst sich in beiden Typsystemen in der leeren Typumgebung der Typ
$\typeArrow{\typeObject{m:\typeInt}}{\typeInt}$ wie folgt herleiten.
%
\vspace{2mm}\[
  \inferrule*[left=Abstr]%
  {
    \inferrule*[Left=Send]%
    {
      \inferrule*[lab=Id]%
      {}
      {\Tj{[o:\typeObject{m:\typeInt}]}{o}{\typeObject{m:\typeInt}}}
    }
    {\Tj{[o:\typeObject{m:\typeInt}]}{\expSend{o}{m}}{\typeInt}}
  }
  {\Tj{[\,]}{\expAbstr{o:\typeObject{m:\typeInt}}{\expSend{o}{m}}}{\typeArrow{\typeObject{m:\typeInt}}{\typeInt}}}
\]\vspace{2mm}
%
Betrachten wir weiterhin das Objekt
\EQNbeg
  \expObject{\self:\typeObject{m:\typeInt;n:\typeInt}}{\rowMethod{m}{1}{\rowMethod{n}{2}{}}},
\EQNend
welches zwei Methoden von Typ $\typeInt$ bereitstellt. Mit den Typregeln von \Lot\ l\"asst sich hierf\"ur
offensichtlich der Typ $\typeObject{m:\typeInt;n:\typeInt}$ herleiten. Gem\"a"s der Typeindeutig der
Sprache \Lot\ sind dies die einzigen Typen, die sich mit den Typregeln von \Lot\ f\"ur diese beiden
Ausdr\"ucke herleiten lassen.

Nennen wir nun die Funktion $f_m$ und das Objekt $obj$ und betrachten den folgenden Ausdruck.\footnote{Streng
genommen m\"ussten wir daf\"ur $\blet$-Ausdr\"ucke benutzen, der \"Ubersichtlichkeit wegen vermeiden wir dies
jedoch an dieser Stelle.}
\EQNbeg
  \expApp{f_m}{obj}
\EQNend
Sei $\Gamma = [f_m:\typeArrow{\typeObject{m:\typeInt}}{\typeInt},obj:\typeObject{m:\typeInt;n:\typeInt}]$ die
Typumgebung, in der ein Typ f\"ur den Ausdruck bestimmt werden soll. Betrachten wir zun\"achst eine m\"ogliche
Typherleitung in der Sprache \Lot.
%
\vspace{2mm}\[
  \inferrule*[left=App]%
  {
    \inferrule*[lab=Id]%
    {}
    {\Tj{\Gamma}{f_m}{\typeArrow{\typeObject{m:\typeInt}}{\typeInt}}}
    \\
    \inferrule*[lab=Id]%
    {}
    {\Tj{\Gamma}{obj}{\typeObject{m:\typeInt;n:\typeInt}}}
  }
  {\Tj{\Gamma}{\expApp{f_m}{obj}}{}}
\]\vspace{2mm}
%
Die Typregel \RN{App} fordert $\typeObject{m:\typeInt} = \typeObject{m:\typeInt;n:\typeInt}$, ein
Widerspruch. Also kann f\"ur diesen Ausdruck kein Typ hergeleitet werden. Im Typsystem der Sprache
\Losub\ hingegen l\"asst sich ein Typ f\"ur diesen Ausdruck herleiten. Hierzu existieren f\"ur
diesen speziellen Ausdruck grunds\"atzlich zwei M\"oglichkeiten den Widerspruch aufzuheben:
\begin{enumerate}
  \item den Typ von $f_m$ anpassen zu $\typeArrow{\typeObject{m:\typeInt;n:\typeInt}}{\typeInt}$,
  \item oder den Typ von $obj$ anpassen zu $\typeObject{m:\typeInt}$.
\end{enumerate}
Die Typanpassung erfolgt mit der \RN{Subsume}-Regel und den entsprechenden Subtyping-Regeln. Wir
betrachten dazu exemplarisch den ersten Fall.
%
\vspace{2mm}\[
  \inferrule*[right=Subsume]%
  {
    \inferrule*[lab=Id]%
    {}
    {\Tj{\Gamma}{f_m}{\typeArrow{\typeObject{m:\typeInt}}{\typeInt}}}
    \\
    \inferrule*[Right=S-Arrow]%
    {
      \inferrule*[lab=S-Obj-Width]%
      {}
      {\typeObject{m:\typeInt;n:\typeInt} \le \typeObject{m:\typeInt}}
      \\
      \inferrule*[lab=S-Refl]%
      {}
      {\typeInt \le \typeInt}
    }
    {\typeArrow{\typeObject{m:\typeInt}}{\typeInt} \le \typeArrow{\typeObject{m:\typeInt;n:\typeInt}}{\typeInt}}
  }
  {\Tj{\Gamma}{f_m}{\typeArrow{\typeObject{m:\typeInt;n:\typeInt}}{\typeInt}}}
\]\vspace{2mm}
%
Nach dieser Typanpassung sind die Voraussetzungen f\"ur die Typregel \RN{App} erf\"ullt und f\"ur den
Gesamtausdruck l\"asst sich somit der Typ $\typeInt$ herleiten.

Anhand des vorangegangenen Beispiels haben wir gesehen, dass im Typsystem der Sprache \Losub\ mehr wohlgetypte
Ausdr\"ucke existieren als im Typsystem der Sprache \Lot. Somit k\"onnen also die Ergebnisse \"uber die Typsicherheit
von \Lot\ nicht einfach auf \Losub\ \"ubertragen werden, sondern es m\"ussen teilweise neue \"Uberlegungen f\"ur
die Sprache mit Subtyping angestellt werden.

Hierzu betrachten wir zun\"achst die f\"ur den Beweis der Typerhaltung notwendigen Lemmata aus
Kapitel~\ref{kapitel:Funktionale_Objekte} f\"ur die Sprache \Losub. Die Aussagen der Lemmata
wurden bereits f\"ur \Lot\ entsprechend geschickt gew\"ahlt, so dass diese \"ubernommen werden
k\"onnen. In den Beweisen muss nun zus\"atzlich zu den Typregeln f\"ur die Programmiersprache
\Lot\ die \RN{Subsume}-Regel betrachtet werden.

\begin{lemma}[Typumgebungen und frei vorkommende Namen] \label{lemma:Losub:free_und_dom_Gamma} \
  \begin{enumerate}
    \item $\forall \Gamma \in \setTEnv, e\in\setExp,\tau\in\setType:\,
           \Tj{\Gamma}{e}{\tau}\,\Rightarrow\,\free{e}\subseteq\dom{\Gamma}$
    \item $\forall \Gamma \in \setTEnv, r\in\setRow,\phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\Rightarrow\,\free{r}\subseteq\dom{\Gamma}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Der Beweis erfolgt wie gehabt durch simultane Induktion \"uber die L\"ange der Herleitung der
  Typurteile $\Tj{\Gamma}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$ und Fallunterscheidung nach der
  zuletzt angewandten Typregel. Wir betrachten nur den neuen Fall der Subsumption-Regel.
  \PROOFCASEbeg
    \item $\Tj{\Gamma}{e}{\tau}$ mit Typregel \RN{Subsume} kann nur aus Pr\"amissen der Form
          $\Tj{\Gamma}{e}{\tau'}$ und $\tau' \le \tau$ folgen. Nach Induktionsvoraussetzung
          gilt also $\free{e} \subseteq \dom{\Gamma}$, was zu zeigen war.
  \PROOFCASEend
  Die \"ubrigen F\"alle sind v\"ollig identisch zum Beweis von Lemma~\ref{lemma:Lot:free_und_dom_Gamma}.
\end{beweis}
%
{\bf TODO:} \"Uberleitung
%
\begin{lemma}[Koinzidenzlemma f\"ur \Losub] \label{lemma:Losub:Koinzidenzlemma} \
  \begin{enumerate}
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, e \in \setExp, \tau \in \setType:\,
           \Tj{\Gamma_1}{e}{\tau}\,\wedge\,\Gamma_1 =_{\free{e}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{e}{\tau}$
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, r \in \setRow, \phi \in \setRType:\,
           \Tj{\Gamma_1}{r}{\phi}\,\wedge\,\Gamma_1 =_{\free{r}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{r}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Hier ist ebenfalls nur der neue Fall f\"ur die Subsumption-Regel zu betrachten, die \"ubrigen F\"alle
  sind bereits durch den Beweis von Lemma~\ref{lemma:Lot:Koinzidenzlemma} abgedeckt.
  \PROOFCASEbeg
    \item $\Tj{\Gamma_1}{e}{\tau}$ mit Typregel \RN{Subsume} kann nur aus Pr\"amissen der Form
          $\Tj{\Gamma_1}{e}{\tau'}$ und $\tau' \le \tau$ folgen. Mit Induktionsvoraussetzung folgt
          daraus $\Tj{\Gamma_2}{e}{\tau'}$ und mit Typregel \RN{Subsume} schliesslich das gesuchte
          Ergebnis $\Tj{\Gamma_2}{e}{\tau}$.
  \PROOFCASEend
\end{beweis}
%
{\bf TODO:} \"Uberleitung
%
\begin{lemma}[Typurteile und Substitution] \label{lemma:Losub:Typurteile_und_Substitution}
  Sei $\id \in \setAttribute \cup \setVar$, $\Gamma \in \setTEnv$, $\tau \in \setType$
  und $e \in \setExp$. Dann gilt:
  \begin{enumerate}
    \item $\forall e' \in \setExp:
           \forall \tau' \in \setType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$
    \item $\forall r \in \setRow:
           \forall \phi \in \setRType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{r\SUB{e}{\id}}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Mit der gleichen Argumentation wie im Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_Substitution} f\"ur
  die Sprache \Lot, wobei ein neuer Fall f\"ur die \RN{Subsume}-Regel hinzukommt, der allerdings direkt mit
  Induktionsvoraussetzung folgt.
\end{beweis}

Neben dem Lemma f\"ur die Substitution von Ausdr\"ucken f\"ur Variablen und Attributnamen muss ebenfalls
der Beweis f\"ur Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution} \"uber Substitution f\"ur $\self$
erweitert werden. Hier ist wiederum der Beweis lediglich um einen neuen Fall f\"ur die \RN{Subsume}-Regel
zu erg\"anzen.
%
\begin{lemma}[Typurteile und \self-Substitution] \label{lemma:Losub:Typurteile_und_self_Substitution}
  Sei $\Gamma \in \setTEnv$, $\self\in\setSelf$,\linebreak[4] $\tau\in\setType$ und $r\in\setRow$. Dann gilt:
  \renewcommand{\labelenumii}{(\arabic{enumii})}
  \begin{enumerate}
    \item F\"ur alle $e\in\setExp$ und $\tau'\in\setType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          \end{enumerate}

    \item F\"ur alle $r'\in\setRow$ und $\phi\in\setRType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r \oplus r'}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{r'\SUB{\expObject{\self:\tau}{r \oplus r'}}{\self}}{\phi}$
          \end{enumerate}
  \end{enumerate}
  \renewcommand{\labelenumii}{\arabic{enumii}.}
\end{lemma}

\begin{beweis}
  Identisch zum Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution}, mit einem neuen
  Fall f\"ur die Subsumption-Regel, der wiederum direkt mit der Induktionsvoraussetzung folgt.
\end{beweis}

Zum Beweis der Preservation f\"ur die Programmiersprache \Losub\ ben\"otigen wir neben den bisherigen
Lemmata noch das folgende Lemma, welches im wesentlichen einer Umkehrung der Typrelation entspricht
(\"ublicherweise als {\em inversion lemma} bezeichnet).
Wir beschr\"anken uns dabei auf die Aussagen, die wir im Beweis
der Preservation- und Progress-S\"atze benutzen werden, statt das Lemma in seiner allgemeinsten Form
anzugeben.

\begin{lemma}[Umkehrung der Typrelation] \label{lemma:Losub:Umkehrung_der_Typrelation} \
  \begin{enumerate}
    \item Wenn $\Tj{\Gamma}{\op}{\tau}$, dann gilt $\tau=\typeIntIntInt$ f\"ur $\op\in\{+,-,*\}$
          oder $\tau=\typeIntIntBool$ f\"ur $\op\in\{\le,\ge,<,>,=\}$.
    \item Wenn $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1'}{\tau_2}}$, dann gilt
          $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$ und $\tau_1' \le \tau_1$.
    \item Wenn $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$, dann gilt $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$,
          $\Tj{\Gamma}{e_2}{\tau_2}$ und $\tau_2 \le \tau_2'$.
    \item Wenn $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$, dann gilt
          $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$, $\tau = \typeObject{\phi}$ und $\tau \le \tau'$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Die Beweise erfolgen jeweils durch vollst\"andige Induktion \"uber die L\"ange der Herleitung des
  Typurteils und Fallunterscheidung nach der zuletzt angewandten Typregel. Hierbei kommen jeweils
  nur zwei Typregeln in Frage.
  \begin{enumerate}
    \item $\Tj{\Gamma}{\op}{\tau}$ kann nur mit einer der Typregeln \RN{Const} oder \RN{Subsume} hergeleitet
          worden sein.
          \PROOFCASEbeg
            \item Im Fall von \RN{Const} gilt $\tj{\op}{\tau}$, welches wiederum nur mit \RN{Aop} oder
                  \RN{Rop} hergeleitet worden sein kann. F\"ur \RN{Aop} gilt $\op\in\{+,-,*\}$ und
                  $\tau=\typeIntIntInt$, andernfalls muss gelten $\op\in\{\le,\ge,<,>,=\}$ und $\tau=\typeIntIntBool$.

            \item F\"ur $\Tj{\Gamma}{\op}{\tau}$ mit Typregel \RN{Subsume} gilt $\Tj{\Gamma}{\op}{\tau'}$
                  und $\tau' \le \tau$. Nach Induktionsvoraussetzung ist $\tau'=\typeIntIntInt$ und
                  $\op\in\{+,-,*\}$ oder $\tau'=\typeIntIntBool$ und $\op\in\{\le,\ge,<,>,=\}$.

                  Wir betrachten nur den Fall $\typeIntIntInt \le \tau$, der zweite Fall folgt entsprechend.
                  Gem\"a"s Subtyping-Lemma (\ref{lemma:Subtyping:Subtyping_Lemma}) existieren
                  $\tau_1,\tau_2\in\setType$ mit $\tau=\typeArrow{\tau_1}{\tau_2}$, $\tau_1\le\typeInt$
                  und $\typeArrow{\typeInt}{\typeInt} \le \tau_2$. Nach erneuter Anwendung des Lemmas
                  also $\tau_2 = \typeArrow{\tau_2'}{\tau_2''}$, $\tau_2' \le \typeInt$ und $\typeInt \le \tau_2''$.
                  Mit Lemma~\ref{lemma:Subtyping:Maximale_Typen} folgt schliesslich
                  $\tau_1 = \tau_2' = \tau_2'' = \typeInt$, also $\tau = \typeIntIntInt$, was zu zeigen
                  war.
          \PROOFCASEend

    \item Zur Herleitung des Typurteils $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1'}{\tau_2}}$
          kommen nur die Typregeln \RN{Abstr} und \RN{Subsume} in Frage.
          \PROOFCASEbeg
            \item Falls zuletzt die \RN{Abstr}-Regel angewandt worden ist, gilt nach Voraussetzung
                  $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$ und $\tau_1' = \tau_1$. Mit Subtyping-Regel
                  \RN{S-Refl} folgt dann $\tau_1' \le \tau_1$.

            \item F\"ur $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1'}{\tau_2}}$ mit
                  \RN{Subsume} existiert nach Voraussetzung ein $\tau''\in\setType$ mit
                  $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau''}$ und $\tau'' \le \typeArrow{\tau_1'}{\tau_2}$.
                  Gem\"a"s dem Subtyping-Lemma (\ref{lemma:Subtyping:Subtyping_Lemma}) existieren somit
                  $\tau_1'',\tau_2''\in\setType$ mit $\tau''=\typeArrow{\tau_1''}{\tau_2''}$,
                  $\tau_1' \le \tau_1''$ und $\tau_2'' \le \tau_2$. F\"ur
                  $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1''}{\tau_2''}}$ folgt dann
                  mit Induktionsvoraussetzung $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2''}$ und
                  $\tau_1'' \le \tau_1$. Aus $\tau_1' \le \tau_1''$ und $\tau_1'' \le \tau_1$ folgt
                  mit Subtyping-Regel \RN{S-Trans} $\tau_1' \le \tau_1$, und wegen
                  $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2''}$ und $\tau_2'' \le \tau_2$ folgt
                  schliesslich mit Typregel \RN{Subsume} $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$.
          \PROOFCASEend
    
    \item Das Typurteil $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ kann ausschliesslich mit Typregel \RN{App}
          oder Typregel \RN{Subsume} folgen.
          \PROOFCASEbeg
            \item $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} bedingt
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{\Gamma}{e_2}{\tau_2}$, und mit
                  \RN{S-Refl} folgt $\tau_2 \le \tau_2$.

            \item $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{Subsume} kann nur aus Pr\"amissen
                  der Form $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau'}$ und $\tau' \le \tau$ folgen. Nach
                  Induktionsvoraussetzung existieren $\tau_2,\tau_2'\in\setType$ mit
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau'}}$, $\Tj{\Gamma}{e_2}{\tau_2}$ und
                  $\tau_2 \le \tau_2'$. Schliesslich folgt wegen $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau'}}$ und
                  $\tau' \le \tau$ mit Typregel \RN{Subsume} und den Subtyping-Regeln \RN{S-Arrow}
                  und \RN{S-Refl} $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$.
          \PROOFCASEend

    \item Das Typurteil $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ kann nur mit einer
          der Typregeln \RN{Object} oder \RN{Subsume} hergeleitet worden sein.
          \PROOFCASEbeg
            \item Falls $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ mit Typregel \RN{Object}
                  hergeleitet wurde, existiert nach Voraussetzung ein $\phi\in\setRType$ mit
                  $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi} = \tau'$.
                  Wegen \RN{S-Refl} also $\tau \le \tau'$.

            \item $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ mit Typregel \RN{Subsume} kann
                  nur aus Pr\"amissen der Form $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau''}$
                  und $\tau'' \le \tau'$ folgen. Nach Induktionsvoraussetzung existiert ein $\phi\in\setRType$,
                  so dass gilt $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ mit $\tau = \typeObject{\phi}$
                  und $\tau \le \tau''$. Mit Subtyping-Regel \RN{S-Trans} folgt $\tau \le \tau'$ wegen
                  $\tau \le \tau''$ und $\tau'' \le \tau'$.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}
%
{\bf TODO}

\begin{satz}[Typerhaltung, "`Preservation"'] \label{satz:Losub:Preservation} \index{Typsicherheit!Preservation} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv:\forall e,e'\in\setExp:\forall \tau\in\setType:\,
           \Tj{\Gamma^\star}{e}{\tau}\,\wedge\,e \to e'\ \Rightarrow\ \Tj{\Gamma^\star}{e'}{\tau}$
    \item $\forall \Gamma\in\setTEnv:\forall r,r'\in\setRow:\forall \phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\wedge\,r \to r'\ \Rightarrow\ \Tj{\Gamma}{r'}{\phi}$
  \end{enumerate}
\end{satz}

\begin{beweis}
  F\"ur die Programmiersprache \Lot\ wurde die Typerhaltung durch simultane Induktion \"uber die
  L\"ange der Herleitung der small steps und Fallunterscheidung nach der zuletzt angewandten small
  step Regel bewiesen. Damit war der Beweis sehr einfach, denn f\"ur jeden Ausdruck und jede Reihe
  war jeweils h\"ochstens eine Typregel anwendbar und der Typ -- so er denn existierte -- eindeutig
  bestimmt.

  Durch Hinzunahme der Subsumptionregel ist diese Eindeutigkeit verloren gegangen. In der Programmiersprache
  \Losub\ kann auf jede syntaktische Form eines Ausdrucks entweder die Typregel, deren conclusio ebenfalls
  die syntaktische Form aufweist, oder die \RN{Subsume}-Regel angewandt werden. Entsprechend muss die Struktur
  des Beweises f\"ur die Sprache mit Subsumption ge\"andert werden.

  Wir f\"uhren den Beweis durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{\Gamma^\star}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$, mit Fallunterscheidung nach der letzten
  Typregel in der Herleitung.
  \PROOFCASEbeg
    \item F\"ur \RN{Const}, \RN{Id}, \RN{Abstr} und \RN{Empty} gilt gem\"a"s Lemma~\ref{lemma:Lo:Werte_und_small_steps}
          $e \not\to$ bzw. $r \not\to$.

    \item $\Tj{\Gamma^\star}{e}{\tau}$ mit \RN{Subsume} kann nur aus Pr\"amissen der Form $\Tj{\Gamma^\star}{e}{\tau'}$
          und $\tau' \le \tau$ folgen. Nach Induktionsvoraussetzung gilt dann $\Tj{\Gamma^\star}{e'}{\tau'}$, und mit
          Typregel \RN{Subsume} folgt schliesslich $\Tj{\Gamma^\star}{e'}{\tau}$.

    \item $\Tj{\Gamma^\star}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} kann nur aus Pr\"amissen der Form
          $\Tj{\Gamma^\star}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{\Gamma^\star}{e_2}{\tau_2}$ folgen. Der small step
          $\expApp{e_1}{e_2} \to e'$ kann nur mit einer der Regeln \RN{App-Left}, \RN{App-Right}, \RN{Op}
          oder \RN{Beta-V} hergeleitet worden sein.
          \begin{enumerate}
            \item Im Fall von \RN{App-Left} gilt $e' = \expApp{e_1'}{e_2}$ und es existiert ein small step
                  $e_1 \to e_1'$. Nach Induktionsvoraussetzung gilt $\Tj{\Gamma^\star}{e_1'}{\typeArrow{\tau_2}{\tau}}$
                  und mit Typregel \RN{App} folgt daraus $\Tj{\Gamma^\star}{\expApp{e_1'}{e_2}}{\tau}$.

            \item $\expApp{e_1}{e_2} \to e'$ mit \RN{App-Right} kann nur aus $e_2 \to e_2'$ und
                  $e' = \expApp{e_1}{e_2'}$ folgen. Mit Induktionsvoraussetzung folgt
                  $\Tj{\Gamma^\star}{e_2'}{\tau_2}$ und mit Typregel \RN{App} somit
                  $\Tj{\Gamma^\star}{\expApp{e_1}{e_2'}}{\tau}$.

            \item F\"ur $\expApp{e_1}{e_2} \to e'$ mit Regel \RN{Op} muss $e_1 = \expApp{\op}{n_1}$ mit
                  $\op \in \setOp$, $n_1 \in \setInt$ und $e_2 = n_2 \in \setInt$ gelten. Weiterhin ist
                  $e' = \op^I(n_1,n_2)$. Dann ist zu unterscheiden zwischen arithmetischen und relationalen Operatoren.
                  Hierbei ist zu beachten, dass gem\"a"s Lemma~\ref{lemma:Subtyping:Maximale_Typen} Anwendungen
                  der \RN{Subsume}-Regel im Folgenden ignoriert werden k\"onnen.
                  
                  Sei also $\op \in \{+,-,*\}$, so gilt nach Voraussetzung
                  $\Tj{\Gamma^\star}{\expApp{\expApp{\op}{n_1}}{n_2}}{\typeInt}$
                  und insbesondere $\tj{\op}{\typeIntIntInt}$ wegen \RN{Aop}. Also ist $\op^I(n_1,n_2)\in\setInt$,
                  und es gilt $\Tj{\Gamma^\star}{\op^I(n_1,n_2)}{\typeInt}$.

                  Sei andererseits $\op\in\{<,>,\le,\ge,=\}$. Es gilt
                  $\Tj{\Gamma^\star}{\expApp{\expApp{\op}{n_1}}{n_2}}{\typeBool}$
                  nach Voraussetzung und insbesondere
                  $\tj{\op}{\typeIntIntBool}$ wegen \RN{Rop}. Dann muss also gelten $\op^I(n_1,n_2)\in\setBool$
                  und somit $\Tj{\Gamma^\star}{\op^I(n_1,n_2)}{\typeBool}$.

            \item Falls $\expApp{e_1}{e_2} \to e'$ mit \RN{Beta-V} hergeleitet worden ist, so gilt
                  $e_1 = \expAbstr{x:\tau_2'}{e_1'}$, $e_2 \in \setVal$ und $e' = e_1'\SUB{e_2}{x}$. Nach
                  Lemma~\ref{lemma:Losub:Umkehrung_der_Typrelation} gilt $\Tj{\Gamma^\star\SUB{\tau_2'}{x}}{e_1'}{\tau}$
                  und $\tau_2 \le \tau_2'$. Aus $\Tj{\Gamma^\star}{e_2}{\tau_2}$ und $\tau_2 \le \tau_2'$ folgt mit
                  Typregel \RN{Subsume} $\Tj{\Gamma^\star}{e_2}{\tau_2'}$, und nach
                  Lemma~\ref{lemma:Losub:Typurteile_und_Substitution} gilt dann
                  $\Tj{\Gamma^\star}{e_1'\SUB{e_2}{x}}{\tau}$ wegen $\Tj{\Gamma^\star\SUB{\tau_2'}{x}}{e_1'}{\tau}$
                  und $\Tj{\Gamma^\star}{v_2}{\tau_2'}$.
          \end{enumerate}

    \item F\"ur $\Tj{\Gamma^\star}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send} gilt nach Voraussetzung
          $\Tj{\Gamma^\star}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\rtypeEmpty}}}$. Der small step
          $\expSend{e_1}{m} \to e'$ kann entweder mit \RN{Send-Eval} oder \RN{Send-Unfold} hergeleitet
          worden sein.
          \begin{enumerate}
            \item Im Fall von \RN{Send-Eval} existiert ein $e_1'\in\setExp$ mit $e' = \expSend{e_1'}{m}$ und ein
                  small step $e_1 \to e_1'$. Nach Induktionsvoraussetzung gilt
                  $\Tj{\Gamma^\star}{e_1'}{\typeObject{\rtypeMethod{m}{\tau}{\rtypeEmpty}}}$ und mit Typregel
                  \RN{Send} folgt $\Tj{\Gamma^\star}{\expSend{e_1'}{m}}{\tau}$.

            \item $\expSend{e_1}{m} \to e'$ mit \RN{Send-Unfold} andererseits bedingt
                  $e_1 = \expObject{\self:\tau'}{\omega}$ sowie
                  $e' = \expSend{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{m}$, also gilt insbesondere
                  $\Tj{\Gamma^\star}{\expObject{\self:\tau}{\omega}}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$.

                  Nach Lemma~\ref{lemma:Losub:Umkehrung_der_Typrelation} existiert ein $\phi'\in\setRType$ mit
                  $\Tj{(\Gamma^\star)^\star\SUB{\tau'}{\self}}{\omega}{\phi'}$, $\tau' = \typeObject{\phi'}$ und
                  $\typeObject{\phi'} \le \typeObject{\rtypeMethod{m}{\tau}{\phi}}$. Mit Typregel \RN{Object} folgt
                  $\Tj{\Gamma^\star}{\expObject{\self:\tau'}{\omega}}{\tau'}$ wegen
                  $\Tj{(\Gamma^\star)^\star\SUB{\tau'}{\self}}{\omega}{\phi'}$ und $\tau' = \typeObject{\phi'}$.

                  Aufgrund von $\dom{\Gamma^\star} \cap \setAttribute = \emptyset$ folgt
                  somit wegen Lemma~\ref{lemma:Losub:Typurteile_und_self_Substitution}
                  $\Tj{\Gamma^\star}{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{\phi'}$. Wegen
                  $\typeObject{\phi'} \le \typeObject{\rtypeMethod{m}{\tau}{\phi}}$ existieren nach
                  Lemma~\ref{lemma:Subtyping:Subtyping_Lemma} $\phi''\in\setRType$ und $\tau''\in\setType$,
                  so dass gilt $\phi' = (\rtypeMethod{m}{\tau''}{\phi''})$ mit $\tau'' \le \tau$.
                  Also folgt mit Typregel \RN{Send'}
                  $\Tj{\Gamma^\star}{\expSend{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{m}}{\tau''}$ und
                  wegen $\tau'' \le \tau$ schliesslich
                  $\Tj{\Gamma^\star}{\expSend{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{m}}{\tau}$
                  mit Typregel \RN{Subsume}.
          \end{enumerate}

    \item $\Tj{\Gamma^\star}{\expSend{\omega}{m}}{\tau}$ mit Typregel \RN{Send'} kann nur aus
          $\Tj{\Gamma^\star}{\omega}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$ folgen. Der small
          step $\expSend{\omega}{m} \to e'$ wiederum kann nur mit einer der Regeln \RN{Send-Attr},
          \RN{Send-Skip} oder \RN{Send-Exec} hergeleitet worden sein.
          \begin{enumerate}
            \item F\"ur $\expSend{\omega}{m} \to e'$ mit \RN{Send-Attr} muss gelten
                  $\omega = (\rowVal{a}{v}{\omega'})$ und $e' = \omega'\SUB{v}{a}$, also
                  $\Tj{\Gamma^\star}{\rowVal{a}{v}{\omega'}}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$.
                  Dieses Typurteil wiederum kann nur mit Typregel \RN{Attr} aus Pr\"amissen der
                  Form $\Tj{(\Gamma^\star=)^\star}{v}{\tau'}$ und
                  $\Tj{\Gamma\SUB{\tau'}{a}}{\omega'}{(\rtypeMethod{m}{\tau}{\phi})}$
                  folgen. Nach Lemma~\ref{lemma:Losub:Typurteile_und_Substitution} folgt
                  $\Tj{\Gamma^\star}{\omega'\SUB{v}{a}}{(\rtypeMethod{m}{\tau}{\phi})}$
                  und mit Typregel \RN{Send'} somit $\Tj{\Gamma^\star}{\expSend{\omega'\SUB{v}{a}}{m}}{\tau}$.
          \end{enumerate}
          Die Beweise f\"ur \RN{Send-Skip} und \RN{Send-Exec} sind ebenfalls identisch zu dem Beweis
          der Preservation f\"ur die Programmiersprache \Lot.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

Damit ist sichergestellt, dass die Wohlgetyptheit -- und insbesondere der konkrete Typ -- auch f\"ur die
Programmiersprache \Losub\ w\"ahrend eines small steps erhalten bleibt. F\"ur die Typsicherheit bleibt
noch zu die Existenz des \"Ubergangsschritts -- das sogenannte {\em Progress-Theorem} -- zu zeigen. Dazu
beginnen wir, wie bereits beim Beweis des Progress-Theorems f\"ur die Programmiersprache \Lot, mit einem
{\em Canonical Forms Lemma}, welches eine Aussage \"uber die m\"oglichen Formen von Werten bestimmter
Typen macht. Wir beschr\"anken uns \"ahnlich wie bei \Lot\ auf die Aussagen des Lemmas, die wir im
nachfolgenden Beweis des Progress-Theorems benutzen werden, um das Lemma kurz zu halten.

\begin{lemma}[Canonical Forms] \label{lemma:Losub:Canonical_Forms} \
  \begin{enumerate}
    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeInt}$ gilt $v\in\setInt$.

    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ gilt genau eine
          der folgenden Aussagen:
          \begin{enumerate}
            \item $v \in \setOp$
            \item $v = \expApp{\op}{v_1}$ mit $\op \in \setOp$ und $v_1 \in \setVal$
            \item $v = \expAbstr{x:\tau_1'}{e}$ mit $x\in\setVar$, $\tau_1'\in\setType$ und $e\in\setExp$.
          \end{enumerate}

    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeObject{\phi}}$ gilt
          $v = \expObject{\self:\typeObject{\phi'}}{\omega}$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Beide Beweise erfolgen durch Induktion \"uber die L\"ange der Herleitung des Typurteils und Fallunterscheidung
  nach der zuletzt angewandten Typregel.
  \begin{enumerate}
    \item Das Typurteil $\Tj{[\,]}{v}{\typeInt}$ kann ausschliesslich mit einer der Typregeln \RN{Const}
          oder \RN{Subsume} hergeleitet worden sein, da f\"ur Werte vom Typ $\typeInt$ sonst keine
          Typregel in Frage kommt.
          \PROOFCASEbeg
            \item $\Tj{[\,]}{v}{\typeInt}$ mit Typregel \RN{Const} kann nur aus $\tj{v}{\typeInt}$ folgen.
                  Letzteres wiederum kann nur mit \RN{Int} folgen, also gilt $v\in\setInt$.

            \item F\"ur $\Tj{[\,]}{v}{\typeInt}$ mit \RN{Subsume} muss gelten $\Tj{[\,]}{v}{\tau}$
                  und $\tau \le \typeInt$. Wegen Lemma~\ref{lemma:Subtyping:Maximale_Typen} folgt
                  $\tau = \typeInt$, und mit Induktionsvoraussetzung schliesslich $v\in\setInt$.
          \PROOFCASEend

    \item Das Typurteil $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ kann nur mit den Typregeln \RN{App},
          \RN{Abstr}, \RN{Const} oder \RN{Subsume} hergeleitet worden sein.
          \PROOFCASEbeg
            \item $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ mit Typregel \RN{Const} kann nur aus
                  $v\in\setConst$ und $\tj{v}{\typeArrow{\tau_1}{\tau_2}}$ folgen. Letzteres wiederum
                  kann aber nur mit \RN{Aop} oder \RN{Rop} hergeleitet worden sein, also gilt $v\in\setOp$.

            \item Falls $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ mit Typregel \RN{Abstr} hergeleitet worden
                  ist, gilt unmittelbar nach Voraussetzung $v = \expAbstr{x:\tau_1'}{e}$.

            \item F\"ur $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ mit Typregel \RN{App} muss gelten
                  $v = \expApp{e_1}{e_2}$, nach Definition~\ref{definition:Lo:Werte_und_Reihenwerte} also
                  $e_1 \in \setOp$ und $e_2 \in \setVal$.

            \item $\Tj{[\,]}{v}{\typeArrow{\tau_1}{\tau_2}}$ mit Typregel \RN{Subsume} kann nur aus
                  Pr\"amissen der Form $\Tj{[\,]}{v}{\tau'}$ und $\tau' \le \typeArrow{\tau_1}{\tau_2}$
                  folgen. Nach Lemma~\ref{lemma:Subtyping:Subtyping_Lemma} existieren $\tau_1',\tau_2'\in\setType$
                  mit $\tau' = \typeArrow{\tau_1'}{\tau_2'}$, $\tau_1 \le \tau_1'$ und $\tau_2' \le \tau_2$.
                  Aus $\Tj{[\,]}{v}{\typeArrow{\tau_1'}{\tau_2'}}$ folgt dann mit Induktionsvoraussetzung,
                  dass $v$ eine der im Lemma aufgef\"uhrten Formen hat.
          \PROOFCASEend

    \item In diesem Fall ist klar, dass das Typurteil $\Tj{[\,]}{v}{\typeObject{\phi}}$ nur mit den Typregeln
          \RN{Object} oder \RN{Subsume} hergeleitet worden sein kann.
          \PROOFCASEbeg
            \item F\"ur $\Tj{[\,]}{v}{\typeObject{\phi}}$ mit Typregel \RN{Object} gilt bereits nach Voraussetzung
                  $v = \expObject{\self:\typeObject{\phi}}{\omega}$.

            \item $\Tj{[\,]}{v}{\typeObject{\phi}}$ mit Typregel \RN{Subsume} kann nur aus Pr\"amissen der Form
                  $\Tj{[\,]}{v}{\tau}$ und $\tau \le \typeObject{\phi}$ folgen. Gem\"a"s
                  Lemma~\ref{lemma:Subtyping:Subtyping_Lemma} ist $\tau$ ebenfalls ein Objekttyp, und mit
                  Induktionsvoraussetzung folgt die Aussage.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}

\begin{satz}[Existenz des \"Ubergangsschritts, "`Progress"'] \label{satz:Losub:Progress} \index{Typsicherheit!Progress} \
  \begin{enumerate}
    \item $\forall e\in\setExp, \tau\in\setType:\, \Tj{[\,]}{e}{\tau}
           \,\Rightarrow\,(e\in\setVal\,\vee\,\exists e'\in\setExp: e \to e')$
    \item $\forall \Gamma\in\setTEnv,r\in\setRow, \phi\in\setRType:\, \Tj{\Gamma^+}{r}{\phi}
           \,\Rightarrow\,(r\in\setRVal\,\vee\,\exists r'\in\setRow: r \to r')$
  \end{enumerate}
\end{satz}

\begin{beweis}
  Wie bereits f\"ur die Programmiersprache \Lot\ erfolgt der Beweis des Progress-Theorems durch
  simultane Induktion \"uber die L\"ange der Herleitung der Typurteile $\Tj{[\,]}{e}{\tau}$
  und $\Tj{\Gamma^+}{r}{\phi}$, allerdings mit Fallunterscheidung nach der zuletzt angewandten
  Typregel statt Fallunterscheidung nach der syntaktischen Form von $e$ und $r$.
  Der Beweis ist im wesentlichen gleich, da das Canonical Forms Lemma bereits die meisten
  durch Subsumption hinzukommenden Sonderf\"alle abdeckt.
  \PROOFCASEbeg
    \item F\"ur \RN{Const} und \RN{Abstr} gilt $e\in\setVal$, und f\"ur \RN{Empty} gilt $r\in\setRVal$.

    \item $\Tj{[\,]}{e}{\tau}$ mit \RN{Subsume} kann ausschliesslich aus $\Tj{[\,]}{e}{\tau'}$
          mit $\tau' \le \tau$ folgen. Die Aussage folgt dann mit Induktionsvoraussetzung
          aus $\Tj{[\,]}{e}{\tau'}$.

    \item Das Typurteil $\Tj{[\,]}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} bedingt
          $\Tj{[\,]}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{[\,]}{e_2}{\tau_2}$. Weiterhin
          ist nach der Art der Teilausdr\"ucke $e_1,e_2$ zu unterscheiden.

          Wenn $e_1\not\in\setVal$, dann existiert nach Induktionsvoraussetzung ein $e_1'\in\setExp$
          mit $e_1 \to e_1'$. Also existiert f\"ur $\expApp{e_1}{e_2}$ ein small step
          $\expApp{e_1}{e_2} \to \expApp{e_1'}{e_2}$ mit Regel \RN{App-Left}.

          Entsprechendes gilt f\"ur den Fall $e_1\in\setVal$ und $e_2\not\in\setVal$. Dann
          existiert ein small step mit Regel \RN{App-Right}.

          Es bleibt noch der Fall $e_1,e_2\in\setVal$ zu betrachten. Wegen $\Tj{[\,]}{e_1}{\typeArrow{\tau_2}{\tau}}$
          sind gem\"a"s dem Canonical Forms Lemma (\ref{lemma:Losub:Canonical_Forms}) f\"ur $e_1$ drei F\"alle zu
          unterscheiden.
          \begin{enumerate}
            \item Wenn $e_1\in\setOp$, dann gilt nach Definition~\ref{definition:Lo:Werte_und_Reihenwerte}
                  $\expApp{e_1}{e_2}\in\setVal$.

            \item Ist $e_1 = \expApp{\op}{v_1}$ f\"ur $\op\in\setOp$ und $v_1\in\setVal$, so folgt aus
                  $\Tj{[\,]}{\expApp{\op}{v_1}}{\typeArrow{\tau_2}{\tau}}$ mit
                  Lemma~\ref{lemma:Losub:Umkehrung_der_Typrelation}
                  $\Tj{[\,]}{\op}{\typeArrow{\tau_1'}{\typeArrow{\tau_2}{\tau}}}$,
                  $\Tj{[\,]}{v_1}{\tau_1}$ und $\tau_1 \le \tau_1'$. Ebenfalls mit
                  Lemma~\ref{lemma:Losub:Umkehrung_der_Typrelation} folgt aus
                  $\Tj{[\,]}{\op}{\typeArrow{\tau_1'}{\typeArrow{\tau_2}{\tau}}}$, dass
                  $\tau_1'=\typeInt$ und $\tau_2=\typeInt$ gelten muss. Nach Lemma~\ref{lemma:Subtyping:Maximale_Typen}
                  somit $\tau_1=\typeInt$, das hei"st $\Tj{[\,]}{v_1}{\typeInt}$ und $\Tj{[\,]}{e_2}{\typeInt}$.
                  Daraus folgt mit Lemma~\ref{lemma:Losub:Canonical_Forms} $v_1,e_2\in\setInt$, also
                  existiert ein small step $\expApp{\op}{\expApp{v_1}{e_2}} \to \op^I(v_1,e_2)$ mit Regel \RN{Op}.

            \item F\"ur $e_1 = \expAbstr{x:\tau_2'}{e_1'}$ existiert ein small step
                  $\expApp{(\expAbstr{x:\tau_2'}{e_1'})}{e_2} \to e_1'\SUB{e_2}{x}$ mit Regel
                  \RN{Beta-V}, da nach Voraussetzung $e_2\in\setVal$.
          \end{enumerate}

    \item $\Tj{[\,]}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object} kann ausschliesslich mit
          $\Tj{[\self:\tau]}{r}{\phi}$ und $\tau=\typeObject{\phi}$ folgen. Nach Induktionsvoraussetzung
          ist $r\in\setRVal$ oder es existiert ein $r'\in\setRow$ mit $r \to r'$. Falls also $r\in\setRVal$,
          so gilt $(\expObject{\self:\tau}{r})\in\setVal$. Anderenfalls, f\"ur $r \to r'$, existiert ein small step
          $\expObject{\self:\tau}{r} \to \expObject{\self:\tau}{r'}$ mit Regel \RN{Object-Eval}.

    \item F\"ur $\Tj{[\,]}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send} muss gelten
          $\Tj{[\,]}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$, und nach Induktionsvoraussetzung
          gilt entweder $e_1\in\setVal$ oder es existiert ein $e_1'\in\setExp$ mit $e_1 \to e_1'$.

          Falls $e_1\in\setVal$, so gilt nach Lemma~\ref{lemma:Losub:Canonical_Forms}
          $e_1 = \expObject{\self:\typeObject{\phi}}{\omega}$ und es existiert ein small step
          $\expSend{\expObject{\self:\typeObject{\phi}}{\omega}}{m} \to \expSend{\omega\SUB{e_1}{\self}}{m}$
          mit Regel \RN{Send-Unfold}.

          Anderenfalls existiert ein small step $\expSend{e_1}{m} \to \expSend{e_1'}{m}$ mit Regel
          \RN{Send-Eval}.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen \"ahnlich.
\end{beweis}

\begin{satz}[Typsicherheit, "`Safety"'] \label{satz:Losub:Safety} \index{Typsicherheit!Safety}
  Wenn $\Tj{[\,]}{e}{\tau}$, dann bleibt die Berechnung f\"ur $e$ nicht stecken.
\end{satz}

\begin{beweis}
  Folgt analog wie f\"ur \Lot\ aus den Preservation und Progress-S\"atzen.
\end{beweis}


%%%%%%%%%%%%%%%%%%%%
%% Minimal Typing %%
%%%%%%%%%%%%%%%%%%%%

\section{Minimal Typing}

Nach dem Beweis der Typsicherheit der Programmiersprache \Losub\ im vorangegangenen Abschnitt wollen wir nun auf
die Frage der Typeindeutigkeit zur\"uckkommen. Wir haben bereits gesehen, dass das Typsystem nach Hinzunahme der
Subsumption-Regel nicht mehr deterministisch ist. W\"ahrend f\"ur die Sprache \Lot\ ein einfacher Algorithmus zur
Typ\"uberpr\"ufung existiert, der durch R\"uckw\"artsanwendung von Typregeln versucht einen Typ herzuleiten, ist
dies f\"ur die Sprache \Losub\ nicht mehr m\"oglich.

Neben der \RN{Subsume}-Regel existiert noch ein weiteres Hinderniss f\"ur eine einfache algorithmische Umsetzung: Das
Regelwerk f\"ur die Subtyprelation ist ebenfalls nicht deterministisch, denn auf jede Formel der Gestalt
$\tau \le \tau'$ ist stets die \RN{S-Trans}-Regel und h\"aufig zumindest eine weitere Regel anwendbar.

In diesem Abschnitt wollen wir versuchen ein deterministisches Regelwerk f\"ur die Typ\"uberpr\"ufung einer
Sprache mit Subtyping anzugeben, welches \"aquivalent zum Typsystem der Sprache \Losub\ ist.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Die Subtyprelation \lem %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Die Subtyprelation $\le_m$}

Nach dem Subtyping-Lemma (\ref{lemma:Subtyping:Subtyping_Lemma}) enth\"alt die Subtyprelation $\le$ nur Paare
von Typen, deren syntaktische Form \"ubereinstimmt. Das bedeutet, ein Funktionstyp kann nur in Relation zu
einem anderen Funktionstyp stehen, aber niemals zu einem Objekttyp oder einem primitiven Typ. Im Folgenden
definieren wir basierend auf dieser \"Uberlegung die Relation $\le_m$ und zeigen anschliessend, dass die
Relationen $\le$ und $\le_m$ \"ubereinstimmen (vgl. dazu Definition~\ref{definition:Subtyping:Subtyping_Regeln}
f\"ur die Relation $\le$).

\begin{definition}[Subtyping-Regeln f\"urs Minimal Typing] \label{definition:Minimal_Typing:Subtyping_Regeln}
  Die Subtyprelation $\le_m$ ist die kleinste Relation auf $\setType \times \setType$, die sich mit
  den folgenden Regeln herleiten l\"a"st. \\[5mm]
  \begin{tabular}{ll}
    \RN{Sm-Refl}      & $\tau_\beta \le_m \tau_\beta \text{ f\"ur alle } \tau_\beta\in\{\typeBool,\typeInt,\typeUnit\}$  \\[1mm]
    \RN{Sm-Arrow}     & $\RULE{\tau_1' \le_m \tau_1 \quad \tau_2 \le_m \tau_2'}
                              {\typeArrow{\tau_1}{\tau_2} \le_m \typeArrow{\tau_1'}{\tau_2'}}$ \\[4mm]
    \RN{Sm-Object}    & $\RULE{\tau_i \le_m \tau_j' \text{ f\"ur alle } i,j \text{ mit } m_i = m_j'}
                              {\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}
                               \le_m \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}}$ \\[3mm]
                      & $\text{falls } \{m_1',\ldots,m_l'\} \subseteq \{m_1,\ldots,m_k\}$
  \end{tabular} \\[1mm]
\end{definition}

Intutiv ist klar, dass gem\"a"s Lemma~\ref{lemma:Subtyping:Subtyping_Lemma} die Relationen $\le$ und
$\le_m$ identisch sind. Der wesentliche Unterschied besteht in der Regel \RN{Sm-Refl}, die nun auf
primitive Typen eingeschr\"ankt worden ist, und in der Regel \RN{Sm-Object}, die eine Kombination
der vorherigen Regeln \RN{S-Trans}, \RN{S-Obj-Depth} und \RN{S-Obj-Width} darstellt.

Um den Beweis der Gleichheit der beiden Relationen $\le$ und $\le_m$ zu erleichtern, zeigen wir
zun\"achst, dass die Relation $\le_m$ transitiv ist. Dazu das folgende Lemma.

\begin{lemma} \label{lemma:Minimal_Typing:Subtyprelation_transitiv}
  $\forall \tau_1,\tau_2,\tau_3\in\setType: \tau_1 \le_m \tau_2 \ \wedge \ \tau_2 \le_m \tau_3 \
           \Rightarrow \ \tau_1 \le_m \tau_3$
\end{lemma}

\begin{beweis}
  Der Beweis erfolgt durch simultane Induktion \"uber die L\"ange der Herleitungen von
  $\tau_1 \le_m \tau_2$ und $\tau_2 \le_m \tau_3$ und Fallunterscheidung nach der syntaktischen
  Form von $\tau_2$.
  \PROOFCASEbeg
    \item $\tau_2 \in \{\typeBool,\typeInt,\typeUnit\}$ bedingt, dass $\tau_1 \le_m \tau_2$ und
          $\tau_2 \le_m \tau_3$ mit Regel \RN{Sm-Refl} folgen m\"ussen, also $\tau_1 = \tau_2 = \tau_3$.
          Daraus wiederum folgt unmittelbar $\tau_1 \le_m \tau_3$ mit Regel \RN{Sm-Refl}.

    \item F\"ur $\tau_2 = \typeArrow{\tau_2'}{\tau_2''}$ k\"onnen $\tau_1 \le_m \tau_2$ und
          $\tau_2 \le_m \tau_3$ nur Regel \RN{Sm-Arrow} hergeleitet worden sein. Also ist
          $\tau_1 = \typeArrow{\tau_1'}{\tau_1''}$ und $\tau_3 = \typeArrow{\tau_3'}{\tau_3''}$,
          und es gilt $\tau_2' \le_m \tau_1'$, $\tau_1'' \le_m \tau_2''$, $\tau_3' \le_m \tau_2'$
          und $\tau_2'' \le_m \tau_3''$. Nach Induktionsvoraussetzung folgt daraus
          $\tau_3' \le_m \tau_1'$ und $\tau_1'' \le_m \tau_3''$, und mit Regel \RN{Sm-Arrow}
          schliesslich $\typeArrow{\tau_1'}{\tau_1''} \le_m \typeArrow{\tau_3'}{\tau_3''}$.

    \item Der Fall $\tau_2 = \typeObject{\phi}$ verl\"auft entsprechend, wobei dann
          $\tau_1 \le_m \tau_2$ und $\tau_2 \le_m \tau_3$ nur mit Regel \RN{Sm-Object} folgen k\"onnen.
  \PROOFCASEend
\end{beweis}
%
Mit diesem Ergebnis k\"onnen wir nun den folgenden Satz vergleichsweise einfach beweisen.

\begin{satz}
  $\forall \tau_1,\tau_2\in\setType: \tau_1 \le_m \tau_2 \ \Leftrightarrow \ \tau_1 \le \tau_2$
\end{satz}

\begin{beweis}
  Die \"Aquivalenz zeigen wir in zwei Schritten.
  \begin{enumerate}
    \item["`$\Rightarrow$"']
          Diesen Teil des Beweises f\"uhren wir durch vollst\"andige Induktion \"uber die L\"ange der Herleitung
          von $\tau_1 \le_m \tau_2$ und Fallunterscheidung nach der zuletzt angewandten Regel.
          \PROOFCASEbeg
            \item Im Fall von $\tau_1 \le_m \tau_2$ mit Regel \RN{Sm-Refl} muss gelten $\tau_1 = \tau_2$. Also
                  folgt $\tau_1 \le \tau_2$ mit \RN{S-Refl}.

            \item F\"ur \RN{Sm-Arrow} folgt die Behauptung sofort mit Induktionsvoraussetzung, da die
                  \RN{Sm-Arrow}-Regel identisch ist mit der \RN{S-Arrow}-Regel.

            \item Der \RN{Sm-Object}-Fall folgt ebenso leicht mit Induktionsvoraussetzung und
                  Lemma~\ref{lemma:Subtyping:Subtyping_Lemma}.
          \PROOFCASEend

    \item["`$\Leftarrow$"']
          Diese Richtung beweisen wir entsprechend mittels vollst\"andiger Induktion \"uber die L\"ange
          der Herleitung von $\tau_1 \le \tau_2$ und Fallunterscheidung nach der letzten Regel in der
          Herleitung.
          \PROOFCASEbeg
            \item $\tau_1 \le \tau_2$ mit \RN{S-Refl} kann nur aus $\tau_1 = \tau_2$ folgen. Dann ist
                  nach der syntaktischen Form von $\tau_1$ zu unterscheiden.

                  F\"ur $\tau_1 \in \{\typeBool,\typeInt,\typeUnit\}$ folgt unmittelbar $\tau_1 \le_m \tau_2$
                  mit Regel \RN{Sm-Refl}.

                  Wenn $\tau_1 = \typeArrow{\tau_1'}{\tau_1''}$, dann gilt $\tau_1' \le \tau_1'$ und
                  $\tau_1'' \le \tau_1''$ wegen \RN{S-Refl}, mit Induktionsvoraussetzung folgt
                  daraus $\tau_1' \le_m \tau_1'$ und $\tau_1'' \le_m \tau_1''$, und mit Regel \RN{Sm-Arrow}
                  schliesslich $\typeArrow{\tau_1'}{\tau_1''} \le_m \typeArrow{\tau_1'}{\tau_1''}$.

                  Bleibt noch der Fall $\tau_1 = \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$ zu betrachten.
                  Wegen \RN{S-Refl} gilt wieder $\tau_1' \le \tau_1'$ f\"ur $i=1,\ldots,n$ und nach
                  Induktionsvoraussetzung gilt somit $\tau_1' \le_m \tau_1'$ f\"ur $i=1,\ldots,n$.
                  Mit Regel \RN{Sm-Object} folgt daraus
                  $\typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'} \le_m \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$,
                  denn trivialerweise gilt $\{m_1,\ldots,m_n\} \subseteq \{m_1,\ldots,m_n\}$.

            \item F\"ur $\tau_1 \le \tau_2$ mit \RN{S-Arrow} folgt die Behauptung unmittelbar aus der
                  Induktionsvoraussetzung mit Regel \RN{Sm-Arrow}.

            \item Wenn $\tau_1 \le \tau_2$ mit Regel \RN{S-Trans} hergeleitet worden ist, existiert nach
                  Voraussetzung ein $\tau_3$ mit $\tau_1 \le \tau_3$ und $\tau_3 \le \tau_2$. Daraus folgt
                  mit Induktionsvoraussetzung $\tau_1 \le_m \tau_3$ und $\tau_3 \le_m \tau_2$, und somit
                  $\tau_1 \le_m \tau_3$ wegen der Transitivit\"at von $\le_m$
                  (Lemma~\ref{lemma:Minimal_Typing:Subtyprelation_transitiv}).

            \item Falls andererseits $\tau_1 \le \tau_2$ mit Regel \RN{S-Obj-Width} hergeleitet wurde, so
                  muss gelten $\tau_1 = \typeObject{m_1:\tau_1';\ldots;m_{n+k}:\tau_{n+k}'}$ und
                  $\tau_2 = \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$. Es gilt also insbesondere
                  $\{m_1,\ldots,m_n\} \subseteq \{m_1,\ldots,m_{n+k}\}$, und weiterhin $\tau_i' \le \tau_i'$
                  f\"ur $i=1,\ldots,n$ wegen \RN{S-Refl}. Daraus folgt mit Induktionsvoraussetzung
                  $\tau_i' \le_m \tau_i'$ f\"ur $i=1,\ldots,n$, und schliesslicht mit Regel \RN{Sm-Object} \linebreak[4]
                  $\typeObject{m_1:\tau_1';\ldots;m_{n+k}:\tau_{n+k}'} \le_m \typeObject{m_1:\tau_1';\ldots;m_n:\tau_n'}$.
  
            \item F\"ur $\tau_1 \le \tau_2$ mit Regel \RN{S-Obj-Depth} folgt die Behauptung ebenso
                  problemlos mit \RN{Sm-Object} aus der Induktionsvoraussetzung.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}
%
Mit diesem Ergebnis brauchen wir nicht l\"anger zwischen $\le$ und $\le_m$ zu unterscheiden, und k\"onnen
wahlweise die Regeln aus Definition~\ref{definition:Subtyping:Subtyping_Regeln} oder
Definition~\ref{definition:Minimal_Typing:Subtyping_Regeln} benutzen, um Aussagen der Gestalt
$\tau_1 \le \tau_2$ herzuleiten.

Basierend auf dem neuen Regelwerk aus Definition~\ref{definition:Minimal_Typing:Subtyping_Regeln} l\"a"st sich
nun ein einfacher Entscheidungsalgorithmus formulieren, der f\"ur zwei Typen $\tau_1,\tau_2\in\setType$ \"uberpr\"uft,
ob $\tau_1 \le \tau_2$ gilt.

\begin{algorithmus}[Entscheidungsalgorithmus f\"ur die Subtyprelation] \label{algorithmus:Minimal_Typing:Subtyprelation}
  Der Algorithmus erh\"alt als Eingabe zwei Typen $\tau,\tau'\in\setType$ und liefert "`ja"', falls $\tau < \tau'$
  gilt, sonst "`nein"'.
  \PROOFCASEbeg
    \item Wenn $\tau,\tau'\in\{\typeBool,\typeInt,\typeUnit\}$ und $\tau = \tau'$, dann Antwort "`ja"'.

    \item Wenn $\tau = \typeArrow{\tau_1}{\tau_2}$ und $\tau' = \typeArrow{\tau_1'}{\tau_2'}$, dann
          \"uberpr\"ufe rekursiv, ob $\tau_1' \le \tau_1$ und $\tau_2 \le \tau_2$ gelten.

    \item Wenn $\tau = \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}$ und
          $\tau' = \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}$ ist, wobei
          $\{m_1',\ldots,m_l'\} \subseteq \{m_1,\ldots,m_k\}$, dann \"uberpr\"ufe rekursiv, ob
          $\tau_i \le \tau_j$ f\"ur alle $i,j$ mit $m_i = m_j'$ gilt.

    \item In allen anderen F\"allen ist die Antwort "`nein"'.
  \PROOFCASEend
\end{algorithmus}
%
Es ist offensichtlich, dass der Algorithmus korrekt ist. Ebenso offensichtlich ist, dass der Algorithmus
f\"ur jede Eingabe terminiert, es sich also tats\"achlich um einen Entscheidungsalgorithmus f\"ur die
Subtyprelation handelt, da ein rekursiver Schritt immer nur mit kleineren Typen durchgef\"uhrt wird.


%%%%%%%%%%%%%%%%%%%%%
%% Die Sprache Lom %%
%%%%%%%%%%%%%%%%%%%%%

\subsection{Die Sprache \Lom}

{\bf TODO:} Prosa

\begin{definition}[Suprema und Infima] \label{definition:Lom:Suprema_und_Infima} \
  \begin{enumerate}
    \item Das Supremum $\tau \vee \tau'$ zweier Typen $\tau,\tau'\in\setType$ ist
          wie folgt induktiv definiert:
          \EQNbeg
            \tau_\beta \vee \tau_\beta
              & =
              & \tau_\beta \text{ f\"ur alle }\tau_\beta\in\{\typeBool,\typeInt,\typeUnit\}
            \\

            \typeArrow{\tau_1}{\tau_2} \vee \typeArrow{\tau_1'}{\tau_2'}
              & =
              & \typeArrow{(\tau_1 \wedge \tau_1')}{(\tau_2 \vee \tau_2')}
            \\

            \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k} \\
             \vee \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}
              & =
              & \typeObject{m_1'':\tau_1'';\ldots;m_n'':\tau_m''}
            \\
            && \text{mit } \{m_1'',\ldots,m_n''\} = \{m_1,\ldots,m_k\} \cap \{m_1',\ldots,m_l'\} \\
            && \text{und } \tau_h'' = \tau_i \vee \tau_i' \text{ f\"ur } m_i = m_h'' = m_j'
          \EQNend

    \item Das Infimum $\tau \wedge \tau'$ zweier Typen $\tau,\tau'\in\setType$ ist induktiv
          definiert durch:
          \EQNbeg
            \tau_\beta \wedge \tau_\beta
              & =
              & \tau_\beta \text{ f\"ur alle }\tau_\beta\in\{\typeBool,\typeInt,\typeUnit\}
            \\

            \typeArrow{\tau_1}{\tau_2} \wedge \typeArrow{\tau_1'}{\tau_2'}
              & =
              & \typeArrow{(\tau_1 \vee \tau_1')}{(\tau_2 \wedge \tau_2')}
            \\

            \typeObject{m_1:\tau_1;\ldots;m_k:\tau_k} \\
             \wedge \typeObject{m_1':\tau_1';\ldots;m_l':\tau_l'}
              & =
              & \typeObject{m_1'':\tau_1'';\ldots;m_n'':\tau_m''}
            \\
            && \text{mit } \{m_1'',\ldots,m_n''\} = \{m_1,\ldots,m_k\} \cup \{m_1',\ldots,m_l'\} \\
            && \text{und } \tau_h'' = \tau_i \wedge \tau_i' \text{ f\"ur } m_i = m_h'' = m_j'
          \EQNend
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa

\begin{lemma} \label{lemma:Lom:Suprema_und_Infima}
  Seien $\tau_1,\tau_2 \in \setType$.
  \begin{enumerate}
    \item Wenn $\tau_1 \vee \tau_2$ existiert, dann gilt $\tau_1 \le \tau_1 \vee \tau_2$ und $\tau_2 \le \tau_1\vee\tau_2$.
    \item Wenn $\tau_1\wedge\tau_2$ existiert, dann gilt $\tau_1\wedge\tau_2\le\tau_1$ und $\tau_1\wedge\tau_2\le\tau_2$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Folgt unmittelbar aus Definition~\ref{definition:Lom:Suprema_und_Infima}.
\end{beweis}
%
Weiterhin ben\"otigen wir noch kleines Lemma, welches die Existenz eines Supremums, also eines kleinsten
gemeinsamen Supertyps, f\"ur zwei kompatible Typen sichert, die beide ihrerseits Subtyp eines bekannten
Typs sind.

\begin{lemma} \label{lemma:Lom:Existenz_des_Supremums}
  Seien $\tau,\tau_1,\tau_2 \in \setType$. Wenn $\tau_1 \le \tau$ und $\tau_2 \le \tau$, dann existiert ein
  Typ $\tau_1 \vee \tau_2$ mit $\tau_1 \vee \tau_2 \le \tau$.
\end{lemma}

\begin{beweis}
  Trivial.
\end{beweis}

Wir geben nun Typregeln f\"ur das Minimal Typing an, mit denen sich g\"ultige Typurteile $\Tjm{\Gamma}{e}{\tau}$
und $\Tjm{\Gamma}{r}{\phi}$ herleiten lassen. Allerdings beschr\"anken wir uns dabei auf Typherleitungen f\"ur
Ausdr\"ucke, die der Programmierer benutzen kann, d.h. insbesondere es wird keine Typherleitung f\"ur Ausdr\"ucke
der Form $\expSend{\omega}{m}$ geben.

Die Idee hierbei ist wie folgt: Typurteile f\"ur diese speziellen Ausdr\"ucke werden lediglich ben\"otigt
zum Beweis der Typsicherheit mit Hilfe des Kalk\"uls. F\"ur das Minimal Typing werden wir aber Typsicherheit
nicht explizit zeigen, sondern lediglich beweisen das der Kalk\"ul korrekt ist bez\"uglich des Typsystems
von \Losub, und somit die Typsicherheit der Sprache \Lom\ aus der Typsicherheit der Sprache \Losub\ folgt.
Das bedeutet wir k\"onnen uns beim Minimal Typing auf die Ausdr\"ucke beschr\"anken, die der Programmierer
im Quelltext notieren kann.

Basierend auf diesen \"Uberlegungen k\"onnen wir nun die Regeln f\"ur den Minimal Typing Kalk\"ul
definieren. Dazu \"ubernehmen wir im wesentlichen die Typregeln der Programmiersprache \Losub, mit
Ausnahme der \RN{Subsume}-Regel, und erweitern die Regeln \RN{App}, \RN{Rec}, \RN{Cond},
\RN{Dupl} und \RN{Method} um Subsumption.

\begin{definition}[G\"ultige Typurteile f\"ur \Lom] \label{definition:Lom:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Lom}
  Ein Typurteil $\Tjm{\Gamma}{e}{\tau}$ oder $\Tjm{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lom,
  wenn es sich mit den folgenden Typregeln f\"ur die funktionale Kernsprache \\[5mm]
  \begin{tabular}{ll} 
    \RN{Id}           & $\Tjm{\Gamma}{\id}{\tau} \quad \text{falls } \id\in\dom{\Gamma} \wedge \Gamma(\id) = \tau$ \\[1mm]
    \RN{Const}        & $\RULE{\tj{c}{\tau}}
                              {\Tjm{\Gamma}{c}{\tau}}$ \\[4mm]
    \RN{App-Subsume}  & $\RULE{\Tjm{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}
                               \quad
                               \Tj{\Gamma}{e_2}{\tau_2}
                               \quad
                               \tau_2\le\tau_2'}
                              {\Tjm{\Gamma}{\expApp{e_1}{e_2}}{\tau}}$ \\[4mm]
    \RN{Abstr}        & $\RULE{\Tjm{\Gamma\SUB{\tau}{x}}{e}{\tau'}}
                              {\Tjm{\Gamma}{\expAbstr{x:\tau}{e}}{\typeArrow{\tau}{\tau'}}}$ \\[4mm]
    \RN{Rec-Subsume}  & $\RULE{\Tjm{\Gamma\SUB{\tau}{x}}{e}{\tau'} \quad \tau' \le \tau}
                              {\Tjm{\Gamma}{\expRec{x:\tau}{e}}{\tau}}$ \\[4mm]
    \RN{Let}          & $\RULE{\Tjm{\Gamma}{e_1}{\tau_1}
                               \quad
                               \Tjm{\Gamma\SUB{\tau_1}{x}}{e_2}{\tau_2}}
                              {\Tjm{\Gamma}{\expLet{x}{e_1}{e_2}}{\tau_2}}$ \\[4mm]
    \RN{Cond-Subsume} & $\RULE{\Tjm{\Gamma}{e_0}{\typeBool}
                               \quad
                               \Tjm{\Gamma}{e_1}{\tau_1}
                               \quad
                               \Tjm{\Gamma}{e_2}{\tau_2}}
                              {\Tjm{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau_1 \vee \tau_2}}$
  \end{tabular} \\[7mm]
  den folgenden Typregeln f\"ur Objekte \\[5mm]
  \begin{tabular}{ll}
    \RN{Send}         & $\RULE{\Tjm{\Gamma}{e}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}}
                              {\Tjm{\Gamma}{\expSend{e}{m}}{\tau}}$ \\[4mm]
    \RN{Object}       & $\RULE{\Tjm{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}
                               \quad
                               \tau = \typeObject{\phi}}
                              {\Tjm{\Gamma}{\expObject{\self:\tau}{r}}{\tau}}$ \\[4mm]
    \RN{Dupl-Subsume} & $\RULE{\Tjm{\Gamma}{\self}{\tau}
                               \quad
                               \forall i=1 \ldots n:\Tjm{\Gamma}{a_i}{\tau_i}
                                             \wedge \Tjm{\Gamma}{e_i}{\tau_i'}
                                             \wedge \tau_i' \le \tau_i}
                              {\Tjm{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}}$
  \end{tabular} \\[7mm]
  sowie den folgenden Typregeln f\"ur Reihen \\[5mm]
  \begin{tabular}{ll}
    \RN{Empty}          & $\Tjm{\Gamma}{\rowEpsilon}{\rtypeEmpty}$ \\[2mm]
    \RN{Attr}           & $\RULE{\Tjm{\Gamma^\star}{e}{\tau}
                                 \quad
                                 \Tjm{\Gamma\SUB{\tau}{a}}{r_1}{\phi}}
                                {\Tjm{\Gamma}{\rowVal{a}{e}{r_1}}{\phi}}$ \\[4mm]
    \RN{Method-Subsume} & $\RULE{\Tjm{\Gamma}{\self}{\typeObject{\rtypeMethod{m}{\tau}{\phi'}}}
                                 \quad
                                 \Tjm{\Gamma}{e}{\tau'}
                                 \quad
                                 \Tjm{\Gamma}{r_1}{\phi}
                                 \quad
                                 \tau' \le \tau}
                                {\Tjm{\Gamma}{\rowMethod{m}{e}{r_1}}
                                             {(\rtypeMethod{m}{\tau}{\rtypeEmpty}) \oplus \phi}}$
  \end{tabular} \\[7mm]
  herleiten l\"a"st.
\end{definition}

{\bf TODO:} Mehr Prosa?

Wir wollen nun zeigen, dass der Minimal Typing Kalk\"ul aus Definition~\ref{definition:Lom:Gueltige_Typurteile}
korrekt ist, also dass die Typrelation der Programmiersprache \Lom\ eine Teilmenge der Typrelation von \Losub\ 
ist. Anders ausgedr\"uckt bedeutet das: Wenn sich mit den Regeln von \Lom\ f\"ur einen Ausdruck $e$ in einer
Typumgebung $\Gamma$ ein Typ $\tau$ herleiten l\"a"st, so l\"a"st sich auch mit den Regeln von \Losub\ der gleiche
Typ $\tau$ herleiten (und entsprechend f\"ur Reihen).

\begin{satz}[Korrektheit des Minimal Typing] \label{satz:Lom:Korrektheit} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv,e\in\setExp,\tau\in\setType:
            \Tjm{\Gamma}{e}{\tau} \ \Rightarrow \ \Tj{\Gamma}{e}{\tau}$
    \item $\forall \Gamma\in\setTEnv,r\in\setRow,\phi\in\setRType:
            \Tjm{\Gamma}{r}{\phi} \ \Rightarrow \ \Tj{\Gamma}{r}{\phi}$
  \end{enumerate}
\end{satz}
%
Intuitiv sollte im wesentlichen schon klar sein, dass dieser Satz gilt. Wir betrachten daher im folgenden Beweis
lediglich die Herleitungen, die mit der Anwendung einer der f\"unf ge\"anderten Regeln enden.

\begin{beweis}
  Wie \"ublich f\"uhren wir den Beweis durch simultane Induktion \"uber die L\"ange der Herleitungen der
  Typurteile $\Tjm{\Gamma}{e}{\tau}$ und $\Tjm{\Gamma}{r}{\phi}$, und Fallunterscheidung nach der zuletzt
  angewandten Typregel (aus dem Minimal Typing Kalk\"ul). Wie bereits erw\"ahnt betrachten wir lediglich
  die interessanten F\"alle.
  \PROOFCASEbeg
    \item $\Tjm{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App-Subsume} kann nur aus Pr\"amissen der
          Form $\Tjm{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$, $\Tjm{\Gamma}{e_2}{\tau_2}$ und $\tau_2 \le \tau_2'$
          folgen. Nach Induktionsvoraussetzung gilt also $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$ und
          $\Tj{\Gamma}{e_2}{\tau_2}$, woraus sich das Typurteil $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ wie
          folgt herleiten l\"a"st:
          \vspace{2mm}\[
            \inferrule*[Right=App]%
            {
              \Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}
              \\
              \inferrule*[Right=Subsume]%
              {
                \Tj{\Gamma}{e_2}{\tau_2}
                \\
                \tau_2 \le \tau_2'
              }%
              {\Tj{\Gamma}{e_2}{\tau_2'}}
            }%
            {\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}}
          \]\vspace{2mm}

    \item $\Tjm{\Gamma}{\expRec{x:\tau}{e}}{\tau}$ mit Typregel \RN{Rec-Subsume} bedingt
          $\Tjm{\Gamma\SUB{\tau}{x}}{e}{\tau'}$ und $\tau' \le \tau$. Mit Induktionsvoraussetzung
          folgt daraus $\Tj{\Gamma\SUB{\tau}{x}}{e}{\tau'}$, und die Behauptung l\"a"st sich
          folgenderma"sen herleiten:
          \vspace{2mm}\[
            \inferrule*[Right=Rec]%
            {
              \inferrule*[Right=Subsume]%
              {
                \Tj{\Gamma\SUB{\tau}{x}}{e}{\tau'}
                \\
                \tau' \le \tau
              }%
              {\Tj{\Gamma\SUB{\tau}{x}}{e}{\tau}}
            }%
            {\Tj{\Gamma}{\expRec{x:\tau}{e}}{\tau}}
          \]\vspace{2mm}

    \item F\"ur $\Tjm{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau_1 \vee \tau_2}$ gilt nach Voraussetzung
          $\Tjm{\Gamma}{e_0}{\typeBool}$, $\Tjm{\Gamma}{e_1}{\tau_1}$ und $\Tjm{\Gamma}{e_2}{\tau_2}$.
          Sei $\tau = \tau_1 \vee \tau_2$, dann gilt wegen Lemma~\ref{lemma:Lom:Suprema_und_Infima}
          $\tau_1 \le \tau$ und $\tau_2 \le \tau$, und wegen Induktionsvoraussetzung gilt
          $\Tj{\Gamma}{e_0}{\typeBool}$, $\Tj{\Gamma}{e_1}{\tau_1}$ und $\Tj{\Gamma}{e_2}{\tau_2}$.
          Damit l\"a"st sich die Behauptung wie folgt herleiten:
          \vspace{2mm}\[
            \inferrule*[Right=Cond]%
            {
              \Tj{\Gamma}{e_0}{\typeBool}
              \\
              \inferrule*[lab=Subsume]%
              {
                \Tj{\Gamma}{e_1}{\tau_1}
                \\
                \tau_1 \le \tau
              }%
              {\Tj{\Gamma}{e_1}{\tau}}
              \\
              \inferrule*[lab=Subsume]%
              {
                \Tj{\Gamma}{e_2}{\tau_2}
                \\
                \tau_2 \le \tau
              }%
              {\Tj{\Gamma}{e_2}{\tau}}
            }%
            {\Tj{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau}}
          \]\vspace{2mm}

    \item $\Tjm{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}$ mit Typregel \RN{Dupl-Subsume} kann
          ausschliesslich aus Pr\"amissen der Form
          \EQNbeg
            \Tjm{\Gamma}{\self}{\tau}
          \EQNend
          sowie
          \EQNbeg
            \forall i=1,\ldots,n: \Tjm{\Gamma}{a_i}{\tau_i}\ \wedge\ \Tjm{\Gamma}{e_i}{\tau_i'}\ \wedge\ \tau_i' \le \tau_i
          \EQNend
          folgen. Nach Induktionsvoraussetzung gilt
          \EQNbeg
            \Tj{\Gamma}{\self}{\tau}
          \EQNend
          und
          \EQNbeg
            \forall i=1,\ldots,n: \Tj{\Gamma}{a_i}{\tau_i}\ \wedge\ \Tj{\Gamma}{e_i}{\tau_i'}\ \wedge\ \tau_i' \le \tau_i,
          \EQNend
          und mit Typregel \RN{Subsume} folgt
          \EQNbeg
            \forall i=1,\ldots,n: \Tj{\Gamma}{a_i}{\tau_i}\ \wedge\ \Tj{\Gamma}{e_i}{\tau_i}.
          \EQNend
          Daraus schliesslich folgt $\Tj{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}$ mit Typregel
          \RN{Dupl}.

    \item Im Fall von $\Tjm{\Gamma}{\rowMethod{m}{e_1}{r_1}}{\phi}$ mit Typregel \RN{Method-Subsume} gilt nach
          Voraussetzung $\Tjm{\Gamma}{\self}{\typeObject{\rtypeMethod{m}{\tau}{\phi''}}}$, $\Tjm{\Gamma}{e_1}{\tau'}$,
          $\Tjm{\Gamma}{r_1}{\phi'}$ und $\tau' \le \tau$, wobei $\phi = (\rtypeMethod{m}{\tau}{\rtypeEmpty}) \oplus \phi'$.
          Nach Induktionsvoraussetzung folgt somit $\Tj{\Gamma}{e_1}{\tau'}$ und $\Tj{\Gamma}{r_1}{\phi'}$.
          Wegen Typregel \RN{Subsume} gilt ebenfalls $\Tj{\Gamma}{e_1}{\tau}$, und daraus schliesslich folgt
          mit \RN{Method} $\Tj{\Gamma}{\rowMethod{m}{e_1}{r_1}}{\phi}$.
  \PROOFCASEend
  Die \"ubrigen F\"alle folgen trivialerweise aus der \"Ubereinstimmung der Regeln (teilweise mit
  Induktionsvoraussetzung).
\end{beweis}
%
Wie bereits angedeutet, folgt aus der Korrektheit des Minimal Typing Kalk\"uls die Typsicherheit der
Programmiersprache \Lom.

\begin{satz}[Typsicherheit, "`Safety"'] \label{satz:Lom:Safety} \index{Typsicherheit!Safety}
  Wenn $\Tjm{[\,]}{e}{\tau}$, dann bleibt die Berechnung f\"ur $e$ nicht stecken.
\end{satz}

\begin{beweis}
  Folgt mit Satz~\ref{satz:Lom:Korrektheit} unmittelbar aus der Typsicherheit von \Losub\ (Satz~\ref{satz:Losub:Safety}),
  denn es gilt
  \EQNbeg
    &             & \Tjm{[\,]}{e}{\tau} \\
    & \stackrel{\text{Satz~\ref{satz:Lom:Korrektheit}}}{\Longrightarrow} & \Tj{[\,]}{e}{\tau}  \\
    & \stackrel{\text{Satz~\ref{satz:Losub:Safety}}}{\Longrightarrow} & \text{die Berechnung von $e$ bleibt nicht stecken.}
  \EQNend
\end{beweis}

{\bf TODO:} \"Uberleitung zur Vollst\"andigkeit

\begin{definition}
  $\setExp_P := \setExp \setminus \{\expSend{\omega}{m}\ |\ \omega\in\setVal,m\in\setMethod\}$
\end{definition}
%
$\setExp_P$ enth\"alt genau die Ausdr\"ucke, die der Programmierer im Quelltext von Programmen notieren kann.
\\ {\bf TODO:} Diese Definition ist Unfug, da nach dieser Definition $\expSend{\omega}{m}$ immer noch innerhalb
von Ausdr\"ucken vorkommen kann.

{\bf TODO:} Insbesondere kann also eine Reihe niemals ausserhalb eines Objekts erscheinen, da dies sonst nur durch
Ausdr\"ucke der Form $\expSend{\omega}{m}$ m\"oglich war. Entsprechend m\"ussen Typumgebungen f\"ur
Reihen in g\"ultigen Typurteilen stets einen Typ f\"ur $\self$ enthalten. Dazu definieren wir
eine Menge $\setTEnv_\phi \subseteq \setTEnv$, die alle Typumgebungen enth\"alt, in denen ein Typ
f\"ur $\self$ eingetragen ist, der l\"anger ist als $\typeObject{\phi}$.

\begin{definition} \label{definition:Lom:Typumgebungen_fuer_Reihen}
  $\setTEnv_\phi := \{\Gamma \in\setTEnv\ \vert\ \exists \phi',\phi''\in\setRType: \Gamma(\self)=\typeObject{\phi'}
                                                 \wedge \phi' = \phi \oplus \phi''\}$
\end{definition}
%
In Worten bedeutet $\phi' = \phi \oplus \phi''$, dass $\phi'$ eine Verl\"angerung von $\phi$ ist,
also dass $\phi'$ mindestens alle Methodennamen von $\phi$ enth\"alt, und $\phi'$ und $\phi$ auf
den gemeinsamen Methodentypen \"ubereinstimmen.

\begin{definition}[Typumgebungen und Subtyping] \label{definition:Lom:Typumgebungen_und_Subtyping}
  Seien $\Gamma,\Gamma'\in\setTEnv$. Dann definieren eine Subtyprelation auf $\setTEnv$ wie folgt
  komponentenweise:
  \EQNbeg
    \Gamma' \le \Gamma
    & :\Leftrightarrow &
    \dom{\Gamma} = \dom{\Gamma'} \wedge \forall \id\in\dom{\Gamma}: \Gamma(\id) \le \Gamma'(\id)
  \EQNend
\end{definition}

{\bf TODO:} Bla blub

\begin{lemma} \label{lemma:Lom:Typumgebungen_und_Subtyping} 
  Seien $\Gamma_1,\Gamma_2\in\setTEnv$. Dann gilt:
  \begin{enumerate}
    \item $\Gamma_1 \le \Gamma_2 \ \Rightarrow \ \Gamma_1^\star \le \Gamma_2^\star$
    \item $\forall \tau\in\setType: \forall \id\in\setId:
           \Gamma_1 \le \Gamma_2 \ \Rightarrow \ \Gamma_1\SUB{\tau}{\id} \le \Gamma_2\SUB{\tau}{\id}$
    \item $\forall \tau_1,\tau_2\in\setType: \forall\id\in\setId:
           \Gamma_1 \le \Gamma_2 \wedge \tau_1 \le \tau_2 \ \Rightarrow \ \Gamma_1\SUB{\tau_1}{\id} \le \Gamma_2\SUB{\tau_2}{\id}$
  \end{enumerate}
\end{lemma}

\begin{beweis} \
  \begin{enumerate}
    \item Folgt trivialerweise, denn es gilt
          \EQNbeg
            \dom{\Gamma_1^\star} = \dom{\Gamma_1} \cap \setVar = \dom{\Gamma_2}\cap\setVar = \dom{\Gamma_2^\star}
          \EQNend
          und
          \EQNbeg
            \Gamma_1^\star(\id) = \Gamma_1(\id) \le \Gamma_2(\id) = \Gamma_2^\star(\id)
          \EQNend
          f\"ur alle $\id\in\dom{\Gamma_1^\star}$.

    \item Ist lediglich ein Spezialfall von (c), denn es gilt $\tau \le \tau$ wegen Subtyping-Regel \RN{S-Refl}.

    \item Folgt ebenso einfach, denn es gilt
          \EQNbeg
            \dom{\Gamma_1\SUB{\tau_1}{\id}} = \dom{\Gamma_1}\cup\{\id\} = \dom{\Gamma_2}\cup\{\id\}
                = \dom{\Gamma_2\SUB{\tau_1}{\id}}
          \EQNend
          und
          \EQNbeg
            \Gamma_1\SUB{\tau_1}{\id}(\id) = \tau_1 \le \tau_2 = \Gamma_2\SUB{\tau_2}{\id}(\id),
          \EQNend
          sowie
          \EQNbeg
            \forall \id'\in\dom{\Gamma_1}:\Gamma_1(\id') \le \Gamma_2(\id'),
          \EQNend
          nach Voraussetzung, zusammenfassend also gilt $\Gamma_1\SUB{\tau_1}{\id} \le \Gamma_2\SUB{\tau_2}{\id}$.
  \end{enumerate}
\end{beweis}
%
{\bf TODO:} Prosa

\begin{satz}[Vollst\"andigkeit des Minimal Typing] \label{satz:Lom:Vollstaendigkeit} \
  \begin{enumerate}
    \item $\forall \tau\in\setType: \forall \Gamma,\Gamma'\in\setTEnv: \forall e\in\setExp_P:$ \\
          $\Tj{\Gamma}{e}{\tau}
           \wedge \Gamma' \le \Gamma
           \wedge \Gamma' =_{\dom{\Gamma}\cap\setAttribute} \Gamma
           \ \Rightarrow\ 
           \exists \tau'\in\setType: \Tjm{\Gamma'}{e}{\tau'} \wedge \tau' \le \tau$
    \item $\forall \phi\in\setRType: \forall \Gamma,\Gamma'\in\setTEnv_\phi: \forall r\in\setRow:$ \\
          $\Tj{\Gamma}{r}{\phi} \wedge \Gamma' \le \Gamma\ \Rightarrow\ \Tjm{\Gamma'}{r}{\phi}$
  \end{enumerate}
\end{satz}
%
Die Voraussetzungen scheinen auf den ersten Blick etwas viele zu sein. Wir werden jedoch im Verlauf des Beweises
sehen, warum jede einzelne dieser Voraussetzungen notwendig ist. Die Beschr\"ankung auf Ausdr\"ucke in $\setExp_P$,
also Ausdr\"ucke, die nicht von der Form $\expSend{\omega}{m}$ sind, sollte sofort ersichtlich sein, da diese
nur w\"ahrend der Auswertung eines Programms entstehen k\"onnen und dem Programmierer nicht zur Verf\"ugung stehen,
und folglich nicht durch den Minimal Typing Kalk\"ul abgedeckt werden. Die Einschr\"ankungen sind auch weniger
restriktiv als man zun\"achst annehmen k\"onnte, wie wir im Anschluss an den Beweis sehen werden.

\begin{beweis}
  Der Beweis der Vollst\"andigkeit erfolgt durch simultane Induktion \"uber die L\"ange der Herleitung der
  Typurteile $\Tj{\Gamma}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$, und Fallunterscheidung nach der zuletzt
  angewandten Typregel (der Programmiersprache \Losub). Wir betrachten dazu exemplarisch die folgenden
  F\"alle.
  \PROOFCASEbeg
    \item $\Tj{\Gamma}{c}{\tau}$ mit Typregel \RN{Const} kann nur mit $\tj{c}{\tau}$ folgen. Also folgt
          $\Tjm{\Gamma'}{c}{\tau}$ mit Typregel \RN{Const} der Programmiersprache \Lom.

    \item Im Fall von $\Tj{\Gamma}{\id}{\tau}$ mit Typregel \RN{Id} gilt nach Voraussetzung $\id\in\dom{\Gamma}$
          und $\Gamma(\id) = \tau$. Also gilt nach Definition~\ref{definition:Lom:Typumgebungen_und_Subtyping}
          $\id\in\dom{\Gamma'}$ und $\Gamma'(\id) = \tau' \le \tau$. Mit Typregel \RN{Id} aus dem Minimal Typing
          Kalk\"ul folgt somit $\Tjm{\Gamma'}{\id}{\tau'}$.

    \item F\"ur $\Tj{\Gamma}{e}{\tau}$ mit Typregel \RN{Subsume} existiert nach Voraussetzung ein $\tau'\in\setType$
          mit $\tau' \le \tau$ und $\Tj{\Gamma}{e}{\tau'}$. Nach Induktionsvoraussetzung existiert ein $\tau'' \le \tau'$,
          so dass $\Tjm{\Gamma'}{e}{\tau''}$ gilt. Wegen \RN{S-Trans} schliesslich folgt $\tau'' \le \tau$.

    \item $\Tj{\Gamma}{\expLet{x}{e_1}{e_2}}{\tau}$ mit Typregel \RN{Let} erfordert $\Tj{\Gamma}{e_1}{\tau_1}$
          und $\Tj{\Gamma\SUB{\tau_1}{x}}{e_2}{\tau}$. Nach Induktionsvoraussetzung existiert ein $\tau_1'\in\setType$
          mit $\tau_1' \le \tau_1$, so dass
          \EQNbeg
            \Tjm{\Gamma'}{e_1}{\tau_1'}
          \EQNend
          gilt. Nach Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping} ist
          $\Gamma'\SUB{\tau_1'}{x} \le \Gamma\SUB{\tau_1}{x}$, also existiert wiederum nach Induktionsvoraussetzung ein
          $\tau'$ mit $\tau' \le \tau$, so dass gilt
          \EQNbeg
            \Tjm{\Gamma'\SUB{\tau_1'}{x}}{e_2}{\tau'},
          \EQNend
          woraus dann mit Typregel \RN{Let} von \Lom\ schliesslich
          \EQNbeg
            \Tjm{\Gamma'}{\expLet{x}{e_1}{e_2}}{\tau'}
          \EQNend
          folgt.

    \item F\"ur $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1}{\tau_2}}$ mit Typregel \RN{Abstr} muss gelten
          $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$ gelten. Nach Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping}
          ist $\Gamma'\SUB{\tau_1}{x} \le \Gamma\SUB{\tau_1}{x}$, also existiert nach Induktionsvoraussetzung
          ein $\tau_2' \in\setType$ mit $\tau_2' \le \tau_2$ und
          \EQNbeg
            \Tjm{\Gamma'\SUB{\tau_1}{x}}{e}{\tau_2'},
          \EQNend
          und mit Typregel \RN{Abstr} des Minimal Typing Kalk\"uls folgt schliesslich
          \EQNbeg
            \Tjm{\Gamma'}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1}{\tau_2'}}.
          \EQNend
          Es bleibt zu zeigen, dass $\typeArrow{\tau_1}{\tau_2'} \le \typeArrow{\tau_1}{\tau_2}$ gilt. Dies folgt
          einfach mit Subtyping-Regeln \RN{S-Arrow}, \RN{S-Refl} und der Voraussetzung $\tau_2' \le \tau_2$.

    \item $\Tj{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau}$ kann mit Typregel \RN{Cond} nur aus Pr\"amissen der Form
          $\Tj{\Gamma}{e_0}{\typeBool}$, $\Tj{\Gamma}{e_1}{\tau}$ und $\Tj{\Gamma}{e_2}{\tau}$ folgen. Nach
          Induktionsvoraussetzung gilt also
          \EQNbeg
            \Tjm{\Gamma'}{e_0}{\typeBool},
          \EQNend
          denn nach dem Subtyping-Lemma (Lemma~\ref{lemma:Subtyping:Subtyping_Lemma}) ist $\typeBool$ selbst
          der einzige Subtyp von $\typeBool$. Weiterhin existiert nach Induktionsvoraussetzung ein $\tau_1\in\setType$
          mit $\tau_1 \le \tau$ und
          \EQNbeg
            \Tjm{\Gamma'}{e_1}{\tau_1},
          \EQNend
          sowie ein $\tau_2 \in \setType$ mit $\tau_2 \le \tau$ und
          \EQNbeg
            \Tjm{\Gamma'}{e_2}{\tau_2}.
          \EQNend
          Gem\"a"s Lemma~\ref{lemma:Lom:Existenz_des_Supremums} ist also das Supremum $\tau_1 \vee \tau_2$
          definiert und es gilt $\tau_1 \vee \tau_2 \le \tau$. Also folgt insgesamt
          \EQNbeg
            \Tjm{\Gamma'}{\expCond{e_0}{e_1}{e_2}}{\tau_1 \vee \tau_2}
          \EQNend
          mit Typregel \RN{Cond-Subsume}.

    \item $\Tj{\Gamma}{\expRec{x:\tau}{e}}{\tau}$ mit Typregel \RN{Rec} bedingt $\Tj{\Gamma\SUB{\tau}{x}}{e}{\tau}$.
          Wegen Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping} gilt $\Gamma'\SUB{\tau}{x}\le\Gamma\SUB{\tau}{x}$,
          also existiert nach Induktionsvoraussetzung ein $\tau'\in\setType$ mit $\tau' \le \tau$ und
          \EQNbeg
            \Tjm{\Gamma'\SUB{\tau}{x}}{e}{\tau'}.
          \EQNend
          Daraus folgt
          \EQNbeg
            \Tjm{\Gamma'}{\expRec{x:\tau}{e}}{\tau}
          \EQNend
          mit Typregel \RN{Rec-Subsume}, und trivialerweise gilt $\tau \le \tau$.

    \item Das Typurteil $\Tj{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}$ kann mit Typregel \RN{Dupl} nur
          aus Pr\"amissen der Form $\Tj{\Gamma}{\self}{\tau}$ sowie $\Gamma(a_i) = \tau_i$ und
          $\Tj{\Gamma}{e_i}{\tau_i}$ f\"ur $i=1,\ldots,n$ folgen. Nach Induktionsvoraussetzung existiert
          also ein $\tau'\in\setType$ mit $\tau' \le \tau$ und
          \EQNbeg
            \Tjm{\Gamma'}{\self}{\tau'}.
          \EQNend
          Dar\"uberhinaus existieren $\tau_1',\ldots,\tau_n'\in\setType$ mit $\tau_i' \le \tau_i$ und
          \EQNbeg
            \Tjm{\Gamma'}{e_i}{\tau_i'}
          \EQNend
          f\"ur $i=1,\ldots,n$. Wegen $\Gamma' =_{\dom{\Gamma}\cap\setAttribute} \Gamma$ gilt nach wie 
          vor\footnote{An dieser Stelle wird deutlich, warum die Voraussetzung
          $\Gamma' =_{\dom{\Gamma}\cap\setAttribute} \Gamma$ unbedingt notwendig ist.}
          \EQNbeg
            \Gamma'(a_i) = \tau_i
          \EQNend
          f\"ur $i=1,\ldots,n$ und somit folgt
          \EQNbeg
            \Tjm{\Gamma'}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau'}
          \EQNend
          mit Typregel \RN{Dupl-Subsume} der Programmiersprache \Lom.

    \item $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object} kann nur aus Pr\"amissen der Form
          $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$ folgen. Mit
          Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping} folgt aus $\Gamma \le \Gamma'$, dass gilt
          \EQNbeg
            \Gamma^\star\SUB{\tau}{\self} \le \Gamma'^\star\SUB{\tau}{\self},
          \EQNend
          also folgt nach Induktionsvoraussetzung
          $\Tjm{\Gamma'^\star\SUB{\tau}{\self}}{r}{\phi}$, denn
          \EQNbeg
            \Gamma'^\star\SUB{\tau}{\self}(\self) = \tau \le \typeObject{\phi}
          \EQNend
          gilt wegen \RN{S-Refl} und somit ist
          $\Gamma'^\star\SUB{\tau}{\self} \in \setTEnv_\phi$. Daraus schliesslich folgt
          \EQNbeg
            \Tjm{\Gamma'}{\expObject{\self:\tau}{r}}{\tau}
          \EQNend
          mit der Typregel \RN{Object} aus dem Minimal Typing
          Kalk\"ul, und $\tau \le \tau$ gilt trivialerweise wegen Subtyping-Regel \RN{S-Refl}.

    \item Falls das Typurteil $\Tj{\Gamma}{\expSend{e}{m}}{\tau}$ mit Typregel \RN{Send} hergeleitet wurde, muss gelten
          $\Tj{\Gamma}{e}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$. Nach Induktionsvoraussetzung
          existiert dann ein $\tau_m \in\setType$ mit $\tau_m \le \typeObject{\rtypeMethod{m}{\tau}{\phi}}$, so
          dass
          \EQNbeg
            \Tjm{\Gamma'}{e}{\tau_m}
          \EQNend
          gilt. Gem\"a"s dem Subtyping-Lemma (\ref{lemma:Subtyping:Subtyping_Lemma})
          existieren dann $\tau'\in\setType,\phi'\in\setRType$ mit $\tau_m = \typeObject{\rtypeMethod{m}{\tau'}{\phi'}}$,
          $\tau' \le \tau$ und $\typeObject{\phi'} \le \typeObject{\phi}$, und es gilt
          \EQNbeg
            \Tjm{\Gamma'}{\expSend{e}{m}}{\tau'}
          \EQNend
          wegen Typregel \RN{Send} der Programmiersprache \Lom.

    \item $\Tj{\Gamma_\phi}{\rowMethod{m}{e'}{r'}}{\phi}$ mit Typregel \RN{Method} bedingt $\Tj{\Gamma_\phi}{e'}{\tau'}$
          und $\Tj{\Gamma_\phi}{r'}{\phi'}$, wobei $\phi = (\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi'$. Nach
          Induktionsvoraussetzung existiert ein $\tau \in \setType$ mit $\tau \le \tau'$, so dass gilt
          \EQNbeg
            \Tjm{\Gamma_\phi'}{e'}{\tau}
          \EQNend
          und
          \EQNbeg
            \Tjm{\Gamma_\phi'}{r'}{\phi'},
          \EQNend
          denn $\phi'$ ist eine Verk\"urzung von $\phi$, also ist $\Gamma_\phi \in\setTEnv_{\phi'}$. Weiterhin
          existiert nach Definition~\ref{definition:Lom:Typumgebungen_fuer_Reihen} ein $\phi''\in\setRType$ mit
          $\Gamma_\phi'(\self) = \typeObject{(\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi'\oplus\phi''}$,
          und wegen Typregel \RN{Id} folgt daraus
          \EQNbeg
            \Tjm{\Gamma_\phi'}{\self}{\typeObject{(\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi'\oplus\phi''}}.
          \EQNend
          Insgesamt folgt also
          \EQNbeg
            \Tjm{\Gamma_\phi'}{\rowMethod{m}{e'}{r'}}{\phi}
          \EQNend
          mit der Typregel \RN{Method-Subsume} aus dem Minimal Typing Kalk\"ul.

    \item Wenn $\Tj{\Gamma_\phi}{\rowVal{a}{e'}{r'}}{\phi}$ mit Typregel \RN{Attr} hergeleitet worden ist, gilt
          nach Voraussetzung $\Tj{\Gamma_\phi^\star}{e'}{\tau}$ und $\Tj{\Gamma_\phi\SUB{\tau}{a}}{r'}{\phi}$.
          Nach Induktionsvoraussetzung existiert also ein $\tau'\in\setType$ mit $\tau' \le \tau$ und
          \EQNbeg
            \Tjm{{\Gamma_\phi'}^\star}{e'}{\tau'},
          \EQNend
          denn aus $\Gamma_\phi' \le \Gamma_\phi$ folgt ${\Gamma_\phi'}^\star \le \Gamma_\phi^\star$ mit
          Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping}. Ebenso gilt
          $\Gamma_\phi'\SUB{\tau'}{a} \le \Gamma_\phi\SUB{\tau}{a}$ wegen
          Lemma~\ref{lemma:Lom:Typumgebungen_und_Subtyping} und es folgt
          \EQNbeg
            \Tjm{\Gamma_\phi'\SUB{\tau'}{x}}{r'}{\phi}
          \EQNend
          mit Induktionsvoraussetzung, denn $\Gamma_\phi'\SUB{\tau'}{x} \in \setTEnv_\phi$. Zusammenfassend folgt
          also
          \EQNbeg
            \Tjm{\Gamma_\phi'}{\rowVal{a}{e'}{r'}}{\phi}
          \EQNend
          mit Typregel \RN{Attr} aus dem Minimal Typing Kalk\"ul.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen \"ahnlich.
\end{beweis}
%
Wie bereits angesprochen, ist damit die Vollst\"andigkeit des Minimal Typing Kalk\"uls gezeigt. Insbesondere
gilt das folgende Korollar, welches die wesentliche Aussage des Satzes noch einmal hervorhebt.

\begin{korollar}
  Sei $e\in\setExp_P$ ein abgeschlossener Ausdruck. Dann gilt:
  \EQNbeg
    \forall \tau\in\setType: \Tj{[\,]}{e}{\tau}\ \Rightarrow\ \exists \tau'\in\setType: \Tjm{[\,]}{e}{\tau'}
                                                                                   \wedge \tau' \le \tau
  \EQNend
\end{korollar}
%
Vereinfacht gesprochen gibt es zu jedem Typurteil der Programmiersprache \Losub, ein \"aquivalentes
in der Programmiersprache \Lom, wobei aber statt einem der m\"oglichen Typen stets der kleinst-m\"ogliche
Typ hergeleitet wird.

\begin{beweis}
  Klar.
\end{beweis}

Kommen wir abschliessend noch einmal auf die eigentliche Motivation f\"ur das Minimal Typing zur\"uck:
Ein deterministisches Regelwerk f\"ur ein Typsystem mit Subsumption. Die wesentlichen Hindernisse waren
zuvor die Tatsache, dass die \RN{Subsume}-Regel auf jeden Ausdruck anwendbar ist, und dass bei der
\RN{Subsume}-Regel der Supertyp $\tau$, zu dem mit der Anwendung dieser Regel \"ubergegangen wird,
durch den Typechecker "`geraten"' werden m\"usste. Intuitiv l\"o"st das Typsystem f\"ur die Programmiersprache
\Lom, welches in Definition~\ref{definition:Lom:Gueltige_Typurteile} beschrieben ist, diese beiden Probleme,
so dass wir nun in der Lage sind den folgenden Satz zu beweisen.

\begin{satz}[Eindeutigkeit des minimalen Typs] \label{satz:Lom:Typeindeutigkeit} \
  \begin{enumerate}
    \item F\"ur jede Typumgebung $\Gamma$ und jeden Ausdruck $e\in\setExp$ existiert h\"ochstens ein
          Typ $\tau\in\setType$ mit $\Tjm{\Gamma}{e}{\tau}$.
    \item F\"ur jede Typumgebung $\Gamma$ und jede Reihe $r \in\setRow$ existiert h\"ochstens ein
          Reihentyp $\phi\in\setRType$ mit $\Tjm{\Gamma}{r}{\phi}$.
  \end{enumerate}
\end{satz}
%
Statt beliebige Ausdr\"ucke aus $\setExp$ zuzulassen, k\"onnten wir uns hierbei ebenfalls auf $\setExp_P$
beschr\"anken, also auf Ausdr\"ucke, die der Programmierer im Quelltext des Programms notieren kann. Aber
diese Einschr\"ankung w\"are unn\"otig, da wir lediglich zeigen, dass h\"ochstens ein Typ existiert und
f\"ur Ausdr\"ucke der Form $\expSend{\omega}{m}$ existiert nach Definition kein Typ.

\begin{beweis}
  Die Behauptung wird durch simultane Induktion \"uber die Gr\"osse von $e$ und $r$, und
  Fallunterscheidung nach der syntaktischen Form von $e$ und $r$ bewiesen. Dazu ist f\"ur jeden Fall zu zeigen,
  dass h\"ochstens eine Typregel in Frage kommt, und der Typ eindeutig bestimmt ist durch die
  Typumgebung $\Gamma$ und den Ausdruck $e$ bzw. die Reihe $r$. Wir schon im Beweis der Typeindeutigkeit
  der Programmiersprache \Lot\ (Satz~\ref{satz:Lot:Typeindeutigkeit}) \"uberspringen wir die Details,
  da es sich um eine triviale Induktion handelt.
\end{beweis}

\begin{korollar}
  Sei $\Gamma$ eine Typumgebung.
  \begin{enumerate}
    \item Ist $e\in\setExp$ wohlgetypt in $\Gamma$, dann existiert genau ein $\tau\in\setType$
          mit $\Tjm{\Gamma}{e}{\tau}$.
    \item Ist $r\in\setRow$ wohlgetypt in $\Gamma$, dann existiert genau ein $\phi\in\setRType$
          mit $\Tjm{\Gamma}{r}{\phi}$.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt unmittelbar aus Satz~\ref{satz:Lom:Typeindeutigkeit}.
\end{beweis}

{\bf TODO:} Basierend auf dem Regelwerk aus Definition~\ref{definition:Lom:Gueltige_Typurteile} l\"a"st sich nun ein
Algorithmus f\"ur die Programmiersprache mit Subtyping angeben.


%%%%%%%%%%%%%%%
%% Coercions %%
%%%%%%%%%%%%%%%

\section{Coercions}
\label{abschnitt:Subtyping:Coercions}

Neben dem im vorangegangenen Abschnitt beschriebenen Minimal Typing Kalk\"ul existieren noch weitere Ans\"atze, ein
Typsystem mit Subtyping entscheidbar zu machen. In diesem Abschnitt beschreiben wir kurz den in \cite{Remy98} und
\cite{Remy02} f\"ur OCaml vorgestellten Ansatz. Dabei wird die Syntax und Semantik der Programmiersprache um
sogenannte {\em Coercions} erweitert, welche es dem Programmierer erm\"oglichen f\"ur einen bestimmten Ausdruck
im Typechecker zu einem gr\"osseren Typ \"uberzugehen.

In einem einfachen Typsystem gen\"ugt es die kontextfreie Grammatik von Ausdr\"ucken um die Produktion
\GRbeg
e \GRis \expCoerce{e_1}{\tau'}
\GRend
zu erweitern, w\"ahrend f\"ur ein Typsystem mit Typinferenz (vgl. \cite[S.317ff]{Pierce02}), wie zum Beispiel
das OCaml Typsystem, die allgemeinere Form
\GRbeg
e \GRis \expCoerce{e_1}{\tau <: \tau'}
\GRend
notwendig ist. Wir verwenden im folgenden die allgemeinere Form.

F\"ur die Programmiersprache \Losub\ existiert eine Subsumption-Regel, die es erm\"oglicht an beliebiger Stelle
in einer Typherleitung zu einem Supertyp \"uberzugehen. Gerade diese \RN{Subsume}-Regel war aber der Grund f\"ur
die Uneindeutigkeit des Typsystems von \Losub. Statt der \RN{Subsume}-Regel nimmt man deshalb die sogenannte
\RN{Coerce}-Regel zum Typsystem hinzu. \\[5mm]
\begin{tabular}{ll}
  \RN{Coerce} & $\RULE{\tau \le \tau' \quad \Tj{\Gamma}{e}{\tau}}
                      {\Tj{\Gamma}{\expCoerce{e}{\tau <: \tau'}}{\tau'}}$
\end{tabular} \\[7mm]
Hierdurch kann w\"ahrend der Typherleitung ebenfalls zu einem Supertyp \"ubergegangen werden, allerdings immer
nur an den Stellen, die der Programmierer explizit daf\"ur vorgesehen hat. Somit erh\"alt man auf recht einfache
Weise ein eindeutiges Typsystem mit Subtyping, welches sich im Gegensatz zum Typsystem der Programmiersprache
\Lom\ auch um Typinferenz und ML-Polymorphie erweiteren l\"a"st.

Dazu muss dann allerdings auch die Semantik erweitert werden, um eine Regel f\"ur den neuen Typ von Ausdruck.
Wie bisher f\"uhren wir keinerlei Typ\"uberpr\"ufung zur Laufzeit durch, so dass die small step Regel
entsprechend einfach aussieht: \\[5mm]
\begin{tabular}{ll}
  \RN{Coerce} & $\expCoerce{e}{\tau <: \tau'} \to e$
\end{tabular} \\[7mm]
Die im Ausdruck enthaltenen Typinformationen werden verworfen, und es erfolgt eine Auswertung des Ausdrucks
mit dem bisherigen small step Regelwerk.

Es ist ziemlich offensichtlich, dass eine solche Programmiersprache typsicher ist, denn f\"ur jede
Typherleitung im Typsystem dieser Programmiersprache l\"asst sich eine \"aquivalente Herleitung im
Typsystem der Sprache \Losub\ konstruieren, indem man
\begin{enumerate}
  \item alle coercions aus dem Programmtext entfernt, und
  \item an allen Stellen, an denen in der urspr\"unglichen Herleitung die \RN{Coerce}-Regel angewendet wurde,
        die \RN{Subsume}-Regel anwendet mit dem bekannten Supertyp.
\end{enumerate}
Das bedeutet, es gilt
\[\begin{array}{rcl}
  &             & \Tj{[\,]}{e}{\tau} \quad \text{ im \RN{Coerce}-Typsystem} \\
  & \Rightarrow & \Tj{[\,]}{e}{\tau} \quad \text{ im Typsystem von \Losub} \\
  & \Rightarrow & e \text{ divergiert oder terminiert mit einem Wert (Satz~\ref{satz:Losub:Safety}).}
\end{array}\]

Coercion-Ausdr\"ucke sind eingeschr\"ankt vergleichbar mit dem {\tt static\_cast} Konstrukt in C++ (vgl.
\cite[S. 440f]{Stroustrup98}), insofern als dass ein {\tt static\_cast} ausschliesslich zur Compile-Zeit
durch den Typechecker \"uberpr\"uft wird. Da jedoch in C++ f\"ur beliebige Zeigertypen ein {\tt static\_cast} 
von und nach {\tt void*} m\"oglich ist, kann hier nicht von einem typsicheren Cast die Rede sein.

Seien beispielsweise {\tt A} und {\tt B} Klassen, wobei {\tt B} von {\tt A} erbt, was in C++ impliziert, dass
$\mathtt{B} \le \mathtt{A}$ gilt, und sei {\tt a} eine Variable von Typ {\tt A*}, die auf eine g\"ultige
Instanz der Klasse {\tt A} zeigt. Dann ist die folgende Zeile ein g\"ultiges C++-Statement:
\[\begin{array}{l}
  \text{\tt B* b = static\_cast<B*> (static\_cast<void*> (a));}
\end{array}\]
Diese sogenannten Upcasts erfordern in C++ eigentlich einen {\tt reinterpret\_cast}, der als generell unsicher
deklariert ist. Wie man jedoch sieht, l\"a"st sich auch der scheinbar sichere {\tt static\_cast} Operator, der
zur Compile-Zeit durch den Typechecker gepr\"uft wird, mit einem einfachen Trick aushebeln. Grund daf\"ur ist,
dass {\tt void*} im C++-Typsystem f\"ur explizite Typkonversionen zugleich gr\"o"ster, wie auch kleinster
Zeigertyp ist\footnote{Eine der vielen Stellen, an der sich das unliebsame C-Erbe bemerkbar macht.}.

F\"ur implizite Typkonversionen -- das C++-Typsystem beinhaltet eine abgewandelte Form der Subsumption-Regel -- gilt
diese Eigenschaft nicht, so dass hier nur {\em sinnvolle} Casts erlaubt sind.


% vi:set ts=2 sw=2 et ai syntax=tex:
