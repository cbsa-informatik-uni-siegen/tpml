%%
%% Funktionale Objekte
%%


\chapter{Funktionale Objekte}
\label{kapitel:Funktionale_Objekte}


Basierend auf der einfachen funktionalen Programmiersprache \Lf, die im vorangegangenen
Kapitel vorgestellt wurde, soll nun die objektorientierte Programmiersprache \Lo\ entwickelt
werden, indem \Lf\ durch objektorientierte Konzepte erweitert wird. In diesem Kapitel werden
dazu zun\"achst einfache, funktionale Objekte in die Sprache eingef\"uhrt. Die Vorlesung
"`Theorie der Programmierung"' orientiert sich so weit m\"oglich an der Programmiersprache
O'Caml\footnote{\url{http://caml.inria.fr/ocaml/}}, entsprechend orientieren sich auch die in
diesem Kapitel entwickelten Erweiterungen syntaktisch und semantisch an O'Caml (vgl. \cite{Remy97},
\cite{Remy98} und \cite{Remy02}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax der Sprache Lo %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Syntax der Sprache \Lo}


{\bf TODO:} Prosa.

\begin{definition} \
  \begin{enumerate}
    \item Vorgegeben seien
          \begin{itemize}
            \item eine unendliche Menge $\setMethod$ von \Define{Methodennamen}{Methodenname} $m$,
            \item eine unendliche Menge $\setAttribute$ von \Define{Attributnamen}{Attributname} $a$
            \item und die einelementige Menge $\setSelf$ von \Define{Objektnamen}{Objektname} $\self$.
          \end{itemize}
          Die Mengen $\setVar$, $\setAttribute$ und $\setSelf$ werden als disjunkt angenommen.
    \item Die Menge $\setId$ aller \Define{Namen}{Name} $\id$ ist wie folgt definiert.
          \EQNbeg
            \setId & = & \setVar\,\cup\,\setAttribute\,\cup\,\setSelf
          \EQNend
  \end{enumerate}
\end{definition}

F\"ur $\setMethod$ gelten \"ahnlich wie f\"ur die Menge $\setVar$ keinerlei Einschr\"ankungen,
au"ser dass die Menge mindestens abz\"ahlbar unendlich sein muss. Eine Implementierung wird
\"ublicherweise $\setMethod = \setVar$ w\"ahlen.

{\bf TODO:} Was zu $\setAttribute$ und $\setSelf$ sagen.

{\bf TODO:} Noch ein bisschen einf\"uhrende Erl\"auterung zur Idee von Reihen.

\begin{definition}[Abstrakte Syntax von \Lo] \label{definition:Lo:Abstrakte_Syntax_von_Lo}
  Die Menge $\setRow$ aller \Define{Reihen}{Reihe} $r$ von \Lo\ ist
  definiert durch die kontextfreie Grammatik
  \GRbeg
  r \GRis \rowEpsilon           \GRtext{leere Reihe}
    \GRal \rowVal{a}{e}{r_1}    \GRtext{Attribut}
    \GRal \rowMethod{m}{e}{r_1} \GRtext{Methode}
  \GRend
  und die Menge $\setExp$ aller \Define{Ausdr\"ucke}{Ausdruck} $e$ von \Lo\ erh\"alt
  man, indem man die kontextfreie Grammatik f\"ur Ausdr\"ucke von \Lf\ wie folgt
  erweitert.
  \GRbeg
  e \GRis \id                               \GRtext{Variable, Attribut- oder Objektname}
    \GRal \expSend{e_1}{m}                  \GRtext{Methodenaufruf}
    \GRal \expObject{\self}{r}              \GRtext{Objekt}
    \GRal \expDupl{a_1=e_1;\ldots;a_n=e_n}  \GRtext{Duplikation}
  \GRend
\end{definition}

Zur Vereinfachung treffen wir f\"ur Reihen die folgende Vereinbarung.

\begin{konvention}
  Die Namen der in einer Reihe deklarierten Attribute sind paarweise verschieden.
\end{konvention}

Diese Vereinbarung stellt keine wirkliche Einschr\"ankung der Sprache dar. In der konkreten
Syntax k\"onnen mehrere Attributdeklarationen mit dem gleichen Namen in derselben Reihe
durchaus zugelassen werden. Bei der syntaktischen Analyse werden dann durch geeignete
Umbenennung die Namen der Attributdeklarationen in einer Reihe disjunkt gemacht.

{\bf TODO:} \"Uberleitung

\begin{definition}
  \label{definition:Lo:doma_und_domm}
  Sei $r \in \setRow$ eine Reihe.
  \begin{enumerate}
    \item Die Menge der Attributnamen $\doma{r}$ der Reihe $r$ ist wie folgt induktiv definiert.
          \EQNbeg
            \doma{\rowEpsilon}         & = & \emptyset \\
            \doma{\rowVal{a}{e}{r}}    & = & \{a\} \cup \doma{r} \\
            \doma{\rowMethod{m}{e}{r}} & = & \doma{r}
          \EQNend

    \item Die Menge der Methodennamen $\domm{r}$ der Reihe $r$ ist wie folgt induktiv definiert.
          \EQNbeg
            \domm{\rowEpsilon}         & = & \emptyset \\
            \domm{\rowVal{a}{e}{r}}    & = & \domm{r} \\
            \domm{\rowMethod{m}{e}{r}} & = & \{m\} \cup \domm{r}
          \EQNend

    \item F\"ur $a\in\doma{r}$ ist der Ausdruck $r(a)$ wie folgt induktiv definiert.
          \EQNbeg
            (\rowVal{a'}{e}{r})(a) & = &
              \CASEbeg
                e    & \text{falls } a' = a \\
                r(a) & \text{sonst}
              \CASEend
            \\[4mm]

            (\rowMethod{m}{e}{r})(a) & = & r(a)
          \EQNend

    \item {\bf TODO:} $r_1 \oplus r_2$ definieren (f\"ur die Typerhaltung von $\self$-Substitution)
  \end{enumerate}
\end{definition}

F\"ur Reihen treffen wir analog zu Ausdr\"ucken die folgende Vereinbarung
(vgl. Konvention~\ref{konvention:Lf:Ausdruecke_und_alpha_Konversion}).

\begin{konvention} \label{konvention:Lo:Reihen_und_alpha_Konversion}
  Reihen, die sich lediglich in den Namen von gebundenen Variablen unterscheiden, sind in
  jeder Beziehung austauschbar.
\end{konvention}

Diese Konvention bezieht sich ausschliesslich auf Variablen und gilt nicht f\"ur
Attributnamen oder Objektnamen.


%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntaktischer Zucker %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Syntaktischer Zucker}


\[
  \begin{array}{ccl}
    \rowMethod{m\ x_1 \ldots x_n}{e}{r} &
      \text{f\"ur} &
      \rowMethod{m}{\expAbstr{x_1}{\ldots\expAbstr{x_n}{e}}}{r}
  \end{array}
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Operationelle Semantik der Sprache Lo %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Operationelle Semantik der Sprache \Lo}

{\bf TODO:} Prosa. \\
{\bf TODO:} Einleitende Worte mit Bezug auf \Lf

Zun\"achst wollen wir pr\"azisieren, was wir in der operationellen Semantik der Sprache \Lo\ unter
einem Wert verstehen ({\bf TODO:} das geht auch besser).

\begin{definition}[Werte und Reihenwerte] \
  \label{definition:Lo:Werte_und_Reihenwerte}
  \begin{enumerate}
    \item Die Menge $\setRVal \subseteq \setRow$ aller \Define{Reihenwerte}{Reihenwert} $\omega$
          von \Lo\ ist durch die folgende kontextfreie Grammatik definiert.
          \GRbeg
          \omega \GRis \rowEpsilon
                 \GRal \rowVal{a}{v}{\omega}
                 \GRal \rowMethod{m}{e}{\omega}
          \GRend
    \item Die Menge $\setVal \subseteq \setExp$ aller \Define{Werte}{Wert} $v$ von \Lo\ erh\"alt
          man, indem man die Produktionen
          \GRbeg
          v \GRis \id                       \GRtext{Name}
            \GRal \expObject{\self}{\omega} \GRtext{Objektwert}
          \GRend
          zur kontextfreien Grammatik von \Lf\ (vgl. Definition~\ref{definition:Lf:Werte}) hinzunimmt.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa

Zur Definition der operationellen Semantik der Sprache \Lo\ ben\"otigen wir noch den Hilfsausdruck
\GRbeg
e \GRis \expSend{\omega}{m}
\GRend
in der abstrakten Syntax, der als Zwischenschritt der Berechnung auftritt, dem Programmierer
in der konkreten Syntax aber nicht zur Verf\"ugung steht.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Frei vorkommende Namen und Substitution %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Frei vorkommende Namen und Substitution}

\begin{definition}[Frei vorkommende Namen] \
  \label{definition:Lo:Frei_vorkommende_Namen}
  \begin{enumerate}
    \item Die Menge $\free{e}$ aller im Ausdruck $e\in\setExp$ \Define{frei vorkommenden
          Namen}{Frei vorkommende Namen} erh\"alt man durch folgende Verallgemeinerung von
          Definition~\ref{definition:Lf:Frei_vorkommende_Variablen}.
          \EQNbeg
            \free{c}                                  & = & \emptyset \\
            \free{\id}                                & = & \{\id\} \\
            \free{\expSend{e}{m}}                     & = & \free{e} \\
            \free{\expSend{\omega}{m}}                & = & \free{\omega} \\
            \free{\expObject{\self}{r}}               & = & \free{r} \setminus \{\self\} \\
            \free{\expDupl{{a_i=e_i}^{i=1 \ldots n}}} & = & \{\self\} \cup \bigcup_{i=1}^n (\free{e_i}\cup\{a_i\})
          \EQNend

    \item Die Menge $\free{r}$ aller in der Reihe $r\in\setRow$ \Define{frei vorkommenden
          Namen}{Frei vorkommende Namen} wird wie folgt induktiv definiert.
          \EQNbeg
            \free{\rowEpsilon}         & = & \emptyset \\
            \free{\rowVal{a}{e}{r}}    & = & \free{e}\,\cup\,(\free{r} \setminus \{a\}) \\
            \free{\rowMethod{m}{e}{r}} & = & \free{e}\,\cup\,\free{r}\,\{\self\}
          \EQNend
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa, zum Beispiel, dass Methodennamen nicht in $\free{e}$ auftauchen.
Weiterhin erkl\"aren, warum $\self$ frei in Duplikationen und Methoden ist (mit
Verweis auf das Typsystem, insb. \RN{Dupl} und \RN{Method} Regeln).

\begin{definition} \label{definition:Lo:Exp_star}
  Die Menge $\setExp^\star \subseteq \setExp$ aller Ausdr\"ucken, die keine freien Vorkommen
  von Attribut- und Objektnamen enthalten, ist wie folgt definiert.
  \[\begin{array}{rcl}
    \setExp^\star & = & \bigl\{e \in \setExp\ \big|\ \free{e} \subseteq \setVar\bigr\}
  \end{array}\]
\end{definition}

{\bf TODO:} \"Uberleitung

\begin{definition}[Reiheneinsetzung] \label{definition:Lo:Reiheneinsetzung}
  F\"ur $r\in\setRow$, $e\in\setExp^\star$ und $a\in\doma{r}$ ist die Reihe $r\RINS{e}{a}$, die
  durch \define{Reiheneinsetzung} aus $r$ entsteht, indem die rechte Seite der Deklaration des
  Attributs $a$ durch den Ausdruck $e$ ersetzt wird, wie folgt definiert.
  \EQNbeg
    (\rowVal{a'}{e'}{r})\RINS{e}{a} & = &
      \CASEbeg
        \rowVal{a'}{e}{r}             & \text{falls } a' = a \\
        \rowVal{a'}{e'}{r\RINS{e}{a}} & \text{sonst}
      \CASEend
    \\[4mm]

    (\rowMethod{m}{e'}{r})\RINS{e}{a} & = & \rowMethod{m}{e'}{r\RINS{e}{a}}
  \EQNend
\end{definition}

{\bf TODO:} \"Uberleitung

\begin{definition}[Substitution] \
  \label{definition:Lo:Substitution}
  \begin{enumerate}
    \item F\"ur $e'\in\setExp$, $e\in\setExp^\star$ und $\id\in\setId$ erh\"alt man
          den Ausdruck $e'\SUB{e}{\id}$, der aus $e'$ durch \define{Substitution} von $e$ f\"ur $\id$
          entsteht, durch folgende Verallgemeinerung von Definition~\ref{definition:Lf:Substitution}.
          \EQNbeg
            \id'\SUB{e}{\id} & = &
              \CASEbeg
                e    & \text{falls } \id = \id' \\
                \id' & \text{sonst}
              \CASEend
            \\[4mm]

            \expSend{e'}{m}\SUB{e}{\id} & = &
              \expSend{(e'\SUB{e}{\id})}{m}
            \\[1mm]

            \expSend{\omega}{m}\SUB{e}{\id} & = &
              \expSend{(\omega\SUB{e}{\id})}{m}
            \\[1mm]

            \expObject{\self}{r}\SUB{e}{\id} & = &
              \CASEbeg
                \expObject{\self}{r}             & \text{falls } \id = \self \\
                \expObject{\self}{r\SUB{e}{\id}} & \text{sonst}
              \CASEend
            \\[4mm]

            \expDupl{{a_i=e_i}^{i=1 \ldots n}}\SUB{e}{\id} & = &
              \CASEbeg
                \LONGbeg
                  \expLet{\vec{x}}{\vec{e}\SUB{e}{\id}}{\expObject{\self}{r\RINS{x_i}{a_i}^{i=1 \ldots n}}} \\
                  \text{ falls } \id = \self \wedge e = \expObject{\self}{r}
                \LONGend \\
                \LONGbeg
                  \expDupl{{a_i=e_i\SUB{e}{\id}}^{i=1 \ldots n}} \\
                  \text{ sonst}
                \LONGend
              \CASEend \\
              && \text{ mit } x_1,\ldots,x_n \not\in \free{r}\cup\bigcup_{i=1}^n \free{e}
          \EQNend

    \item F\"ur $r\in\setRow$, $e\in\setExp^\star$ und $\id\in\setId$ ist die Reihe $r\SUB{e}{\id}$,
          die aus $r$ durch \define{Substitution} von $e$ f\"ur $\id$ entsteht, wie folgt induktiv definiert.
          \EQNbeg
            \rowEpsilon\SUB{e}{\id} & = &
              \rowEpsilon
            \\[1mm]

            (\rowVal{a}{e'}{r})\SUB{e}{\id} & = &
              \CASEbeg
                \rowVal{a}{e'\SUB{e}{\id}}{r}             & \text{falls } \id = a \\
                \rowVal{a}{e'\SUB{e}{\id}}{r\SUB{e}{\id}} & \text{sonst}
              \CASEend
            \\[4mm]

            (\rowMethod{m}{e'}{r})\SUB{e}{\id} & = &
              \rowMethod{m}{e'\SUB{e}{\id}}{r\SUB{e}{\id}}
          \EQNend
  \end{enumerate}
\end{definition}

Es ist wieder zu beachten, dass gem\"a"s Konvention~\ref{konvention:Lf:Ausdruecke_und_alpha_Konversion}
und Konvention~\ref{konvention:Lo:Reihen_und_alpha_Konversion} die Substitution total ist, wenn der
substituierte Ausdruck keine freien Vorkommen von Attribut- oder Objektnamen enth\"alt. Insbesondere
gilt aber zu beachten, dass die Substitution f\"ur Ausdr\"ucke $e \in \setExp \setminus \setExp^\star$
undefiniert ist.

Hiermit l\"asst sich nun unmittelbar das folgende Lemma formulieren, welches uns zusichert, dass das
Ergebnis der Anwendung einer Substitution auf einen Ausdruck oder eine Reihe stets eindeutig definiert
ist durch den Ausdruck oder die Reihe, den Namen, der ersetzt werden soll, und den Ausdruck, der
f\"ur den Namen eingesetzt wird.

\begin{lemma} \label{lemma:Lo:Eindeutigkeit_von_Substitution} \
  \begin{enumerate}
    \item F\"ur $e'\in\setExp$, $e\in\setExp^\star$ und $\id\in\setId$ ist $e'\SUB{e}{\id}$ eindeutig bestimmt.
    \item F\"ur $r\in\setRow$, $e\in\setExp^\star$ und $\id\in\setId$ ist $r\SUB{e}{\id}$ eindeutig bestimmt.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Folgt wegen Konvention~\ref{konvention:Lf:Ausdruecke_und_alpha_Konversion} und
  Konvention~\ref{konvention:Lo:Reihen_und_alpha_Konversion} unmittelbar aus
  Definition~\ref{definition:Lo:Substitution}.
\end{beweis}

{\bf TODO:} Noch ein Satz zum Lemma, vielleicht mit Beispiel, dass es nicht auf syntaktische
Gleichheit ankommt.

Das n\"achste Lemma beschreibt den Zusammenhang zwischen Substitution und frei vorkommenden Namen.

\begin{lemma} \label{lemma:Lo:Substitution_und_free} \
  \begin{enumerate}
    \item $\forall e'\in\setExp, e\in\setExp^\star, \id\in\setId:\,
           \id\not\in\free{e'}\,\Rightarrow\,e'=e'\SUB{e}{\id}$
    \item $\forall r\in\setRow, e\in\setExp^\star, \id\in\setId:\,
           \id\not\in\free{r}\,\Rightarrow\,r=r\SUB{e}{\id}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wir f\"uhren den Beweis durch simultane Induktion \"uber die Gr\"osse von $e'$ und $r$ und
  Fallunterscheidung nach der syntaktischen Form von $e'$ und $r$. Dazu betrachten wir
  exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur Konstanten $c$ gilt bereits wegen Definition~\ref{definition:Lo:Substitution} $c\SUB{e}{\id} = c$.

    \item F\"ur Namen $\id'$ gilt $\id' \ne \id$ wegen $\id\not\in\free{\id'}=\{\id'\}$, also
          insbesondere $\id'\SUB{e}{\id} = \id'$ wegen Definition~\ref{definition:Lo:Substitution}.

    \item F\"ur Applikationen $\expApp{e_1}{e_2}$ gilt $\id \not\in \free{e_1}$ und $\id\not\in\free{e_2}$.
          Wegen $(\expApp{e_1}{e_2})\SUB{e}{\id} = \expApp{e_1\SUB{e}{\id}}{e_2\SUB{e}{\id}}$ folgt nach
          Induktionsvoraussetzung $e_1 = e_1\SUB{e}{\id}$ und $e_2 = e_2\SUB{e}{\id}$. Nach
          Definition~\ref{definition:Lo:Substitution} also $(\expApp{e_1}{e_2})\SUB{e}{\id} = \expApp{e_1}{e_2}$.

    \item Bei Objekten $\expObject{\self}{r}$ sind zwei F\"alle zu unterscheiden.

          F\"ur $\id = \self$ folgt $(\expObject{\self}{r})\SUB{e}{\id} = \expObject{\self}{r}$
          bereits aus Definition~\ref{definition:Lo:Substitution}.

          F\"ur $\id \ne \self$ ist $(\expObject{\self}{r})\SUB{e}{\id} = \expObject{\self}{r\SUB{e}{\id}}$
          und $\id \not\in \free{r} \subseteq \free{\expObject{\self}{r}} \cup \{\self\}$. Es gilt
          $r = r\SUB{e}{\id}$ nach Induktionsvoraussetzung, also
          $(\expObject{\self}{r})\SUB{e}{\id} = \expObject{\self}{r}$.

    \item F\"ur Duplikationen $\expDupl{{a_i=e_i}^{i=1 \ldots n}}$ gilt $\id \ne \self$ nach
          Definition~\ref{definition:Lo:Frei_vorkommende_Namen}. Folglich ist
          $\expDupl{{a_i=e_i}^{i=1 \ldots n}}\SUB{e}{\id} = \expDupl{{a_i=e_i\SUB{e}{\id}}^{i=1 \ldots n}}$
          und nach Induktionsvoraussetzung $e_i = e_i\SUB{e}{\id}$ f\"ur alle $i=1 \ldots n$. Somit
          gilt $\expDupl{{a_i=e_i}^{i=1 \ldots n}}\SUB{e}{\id} = \expDupl{{a_i=e_i}^{i=1 \ldots n}}$.

    \item Bei Attributdeklarationen $\rowVal{a}{e'}{r}$ sind wieder zwei F\"alle zu unterscheiden.

          F\"ur $a = \id$ ist $(\rowVal{a}{e'}{r})\SUB{e}{\id} = \rowVal{a}{e'\SUB{e}{\id}}{r}$
          und nach Definition~\ref{definition:Lo:Frei_vorkommende_Namen} $\id\not\in\free{e'}$. Also
          folgt mit Induktionsvoraussetzung $e' = e'\SUB{e}{\id}$ und somit
          $(\rowVal{a}{e'}{r})\SUB{e}{\id} = \rowVal{a}{e'}{r}$.

          F\"ur $a \ne \id$ ist $(\rowVal{a}{e'}{r})\SUB{e}{\id} = \rowVal{a}{e'\SUB{e}{\id}}{r\SUB{e}{\id}}$
          und analog zum vorhergehenden Fall gilt $\id\not\in\free{e'}\cup\free{r}\cup\{a\}$. Nach
          Induktionsvoraussetzung folgt $e'=e'\SUB{e}{\id}$ und $r=r\SUB{e}{\id}$, also
          $(\rowVal{a}{e'}{r})\SUB{e}{\id} = \rowVal{a}{e'}{r}$.

  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

\begin{korollar} \
  \begin{enumerate}
    \item $\forall e'\in\setExp,e\in\setExp^\star,\id\in\setId:\,
           \free{e'}=\emptyset\,\Rightarrow\,e'=e'\SUB{e}{\id}$
    \item $\forall r\in\setRow,e\in\setExp^\star,\id\in\setId:\,
           \free{r}=\emptyset\,\Rightarrow\,r=r\SUB{e}{\id}$
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt wegen $\id\not\in\emptyset$ unmittelbar aus Lemma~\ref{lemma:Lo:Substitution_und_free}.
\end{beweis}

{\bf TODO:} Prosa


%%%%%%%%%%%%%%%%%%%%%%%%%
%% Small step Semantik %%
%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Small step Semantik}


{\bf TODO:} Einleitende Worte, mit Verweis auf \Lf

\begin{definition}
  Ein \define{small step} f\"ur \Lo\ ist eine Formel der Gestalt $e \to_e e'$ mit
  $e,e' \in \setExp$ oder $r \to_r r'$ mit $r,r' \in \setRow$.
\end{definition}

{\bf TODO:} Ein bisschen Erl\"auterung

\begin{definition}[G\"ultige small steps f"ur \Lo] \label{definition:Lo:Gueltige_small_steps}
  Ein \Index{small step}, $e \to_e e'$ mit $e,e'\in\setExp$ oder $r \to_r r'$ mit $r,r'\in\setRow$,
  hei"st {\em g\"ultig} f\"ur \Lo, wenn er sich mit den small step Regeln von \Lf\ (vgl.
  Definition~\ref{definition:Lf:Gueltige_small_steps}), sowie den folgenden small step Regeln
  f\"ur Objekte \\[5mm]
  \begin{tabular}{ll}
    \RN{Object-Eval}  & $\RULE{r \to_r r'}
                              {\expObject{\self}{r} \to_e \expObject{\self}{r'}}$ \\[3mm]
    \RN{Send-Eval}    & $\RULE{e \to_e e'}
                              {\expSend{e}{m} \to_e \expSend{e'}{m}}$ \\[5mm]
    \RN{Send-Unfold}  & $\expSend{\expObject{\self}{\omega}}{m}
                         \to_e \expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m}$ \\[3mm]
    \RN{Send-Attr}    & $\expSend{(\rowVal{a}{v}{\omega})}{m}
                         \to_e \expSend{\omega\SUB{v}{a}}{m}$ \\[3mm]
    \RN{Send-Skip}    & $\expSend{(\rowMethod{m'}{e}{\omega})}{m} \to_e \expSend{\omega}{m}
                         \quad \text{falls } m \ne m' \vee m\in\domm{\omega}$ \\[3mm]
    \RN{Send-Exec}    & $\expSend{(\rowMethod{m'}{e}{\omega})}{m} \to_e e
                         \quad \quad \quad \text{falls } m = m' \wedge m\not\in\domm{\omega}$
  \end{tabular} \\[7mm]
  und den small step Regeln f\"ur Reihen \\[5mm]
  \begin{tabular}{ll}
    \RN{Attr-Left}    & $\RULE{e \to_e e'}
                              {\rowVal{a}{e}{r} \to_r \rowVal{a}{e'}{r}}$ \\[3mm]
    \RN{Attr-Right}   & $\RULE{r \to_r r'}
                              {\rowVal{a}{v}{r} \to_r \rowVal{a}{v}{r'}}$ \\[5mm]
    \RN{Method-Right} & $\RULE{r \to_r r'}
                              {\rowMethod{m}{e}{r} \to_r \rowMethod{m}{e}{r'}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst.
\end{definition}

{\bf TODO:} Erl\"auterung der Regeln, insbesondere bei \RN{Beta-V}, \RN{Unfold}, \RN{Let-Exec},
\RN{Send-Unfold} und \RN{Send-Attr} zu beachten, dass der small step nur dann existiert, wenn
der zu substituierende Ausdruck aus $\setExp^\star$ ist, ansonsten bleibt der Interpreter stecken.

Im Folgenden betrachten wir $\to_e$ als eine Relation
\[
  \to_e \subseteq \setExp \times \setExp
\]
und $\to_r$ als eine Relation
\[
  \to_r \subseteq \setRow \times \setRow
\]
und benutzen die Infixnotation $e \to_e e'$ anstelle von $(e,e') \in \to_e$ und $r \to_r r'$
anstelle von $(r,r') \in \to_r$. Statt $\to_e$ und $\to_r$ schreiben wir auch $\to$, wenn wir
uns auf beide Relationen beziehen oder es aus dem Zusammenhang hervorgeht, welche Relation
gemeint ist.

Wir schreiben $\xrightarrow+$ f\"ur den transitiven und $\xrightarrow*$ f\"ur den reflexiven
transitiven Abschluss der Relation $\to$, d.h. $\xrightarrow*$ bezeichnet eine endliche, m\"oglicherweise
leere Folge von small steps, und $\xrightarrow+$ eine endliche, nicht-leere Folge von small steps.

Ferner schreiben wir $e \not\to_e$, wenn kein $e'$ existiert, so dass $(e,e') \in \to_e$, und
$r \not\to_r$, wenn kein $r'$ existiert, so dass $(r,r') \in \to_r$. Damit sind wir nun in
der Lage die erste einfache Eigenschaft der small step Semantik zu formulieren.

\begin{lemma} \
  \label{lemma:Lo:Werte_und_small_steps}
  \begin{enumerate}
    \item $v \not\to$ f\"ur alle $v \in \setVal$.
    \item $\omega \not\to$ f\"ur alle $\omega \in \setRVal$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Der Beweis ergibt sich durch simultane Induktion \"uber die
  Gr\"osse von Werten $v$ und Reihenwerten $\omega$: F\"ur Konstanten, Namen,
  Abstraktionen und die leere Reihe ist die Behauptung unmittelbar klar, da
  diese weder in den Axiomen noch in den Konklusionen der Regeln links von $\to$
  stehen.

  F\"ur $v = \expApp{\op}{v'}$ kommt nur ein small step mit \RN{App-Left} oder
  \RN{App-Right} in Frage. Dann m\"usste aber in der Pr\"amisse dieser Regel ein
  small step f\"ur $\op$ oder $v'$ stehen, was nach Induktionsvorraussetzung
  nicht m\"oglich ist.

  Im Fall von $v = \expObject{\self}{\omega'}$ kommt nur ein small step mit \RN{Object-Eval}
  in Frage. Nach Induktionsvorraussetzung existiert aber kein small step f\"ur
  $\omega'$.

  F\"ur $\omega = \rowVal{a}{v'}{\omega'}$ kommt nur ein small step mit
  \RN{Attr-Left} oder \RN{Attr-Right} in Frage. Nach Induktionsvoraussetzung
  existiert aber weder f\"ur $\omega'$ noch f\"ur $v'$ ein small step, folglich
  ist keine der beiden Regeln anwendbar.

  Es bleibt der Fall $\omega = \rowMethod{m}{e}{\omega'}$, in dem nur ein small
  step mit \RN{Method-Right} in Frage kommt. Nach Induktionsvoraussetzung existiert
  aber kein small step f\"ur $\omega'$.
\end{beweis}

Die Auswertung eines Ausdrucks beschreibt man als eine Aneinanderreihung g\"ultiger small steps,
die sich mit den small step Regeln herleiten lassen. Die folgende Definition beschreibt diesen
Zusammenhang.

\begin{definition}[Berechnung] \
  \begin{enumerate}
    \item Eine \define{Berechnungsfolge} ist eine endliche oder unendliche Folge von small
          steps \linebreak[4] $e_1 \to e_2 \to \ldots$.
    \item Eine \define{Berechnung} des Ausdrucks $e$ ist eine {\em maximale}, mit $e$
          beginnende Berechnungsfolge, d.h., eine Berechnungsfolge, die sich nicht
          weiter fortsetzen l\"asst.
  \end{enumerate}
\end{definition}
%
Im Falle einer unendlichen Berechnung f\"ur einen Ausdrucks, sagt man auch die Berechnung {\em divergiert}.
Im Falle einer endlichen Berechnung, an deren Ende ein Wert steht, sagt man die Berechnung {\em terminiert}.

Damit kommen wir nun zum wichtigstens Satz \"uber die small step Semantik der Programmiersprache
\Lo, welcher ein deterministisches Verhalten bei der Auswertung von Ausdr\"ucken und Reihen
sichert. Das bedeutet insbesondere, dass f\"ur jeden Ausdruck und jede Reihe h\"ochstens eine
Berechnung existiert.

\begin{satz}[Eindeutigkeit des \"Ubergangsschritts] \label{satz:Lo:Eindeutigkeit_des_Uebergangsschritts}
  F\"ur jeden Ausdruck $e \in \setExp$ existiert h\"ochstens ein $e' \in \setExp$ mit
  $e \to e'$ und f\"ur jede Reihe $r\in\setRow$ existiert h\"ochstens ein $r' \in \setRow$
  mit $r \to r'$.
\end{satz}

\begin{beweis}
  Wir f\"uhren den Beweis durch simultane Induktion \"uber die Gr\"osse von Ausdr\"ucken $e$ und Reihen $r$,
  und Fallunterscheidung nach der syntaktischen Form von $e$ und $r$.
  \PROOFCASEbeg
    \item $e$ ist von der Form $c$, $\id$ oder $\expAbstr{x}{e'}$.

          Wegen Lemma~\ref{lemma:Lo:Werte_und_small_steps} existiert in diesen F\"allen kein
          small step f\"ur $e$.

    \item $e$ ist von der Form $\expApp{e_1}{e_2}$.

          F\"ur Applikationen kommen nur die vier small step Regeln \RN{Op}, \RN{Beta-V}, \RN{App-Left}
          und \RN{App-Right} in Frage.

          Falls ein small step $e_1 \to e_1'$ existiert kann nur die Regel \RN{App-Left} angewandt
          werden, denn \RN{Op}, \RN{Beta-V} und \RN{App-Right} erfordern einen Wert auf der
          linken Seite der Applikation. Nach Induktionsvoraussetzung ist $e_1'$ eindeutig
          durch $e_1$ bestimmt, also ist auch $\expApp{e_1'}{e_2}$ eindeutig durch
          $\expApp{e_1}{e_2}$ bestimmt.

          Wenn $e_1 \not\to$, aber ein small step $e_2 \to e_2'$ existiert, dann kommt nur
          \RN{App-Right} in Frage, denn \RN{Op} und \RN{Beta-V} erfordern einen Wert auf der
          rechten Seite der Applikation. Nach Induktionsvoraussetzung ist $e_2'$ eindeutig
          bestimmt durch $e_2$, folglich ist auch $\expApp{e_1}{e_2'}$ eindeutig bestimmt
          durch $\expApp{e_1}{e_2}$.

          Es bleibt noch der Fall $e_1 \not\to$ und $e_2 \not\to$. Hier kommen h\"ochstens
          \RN{Op} und \RN{Beta-V} in Frage. Diese schliessen sich offensichtlich gegenseitig
          aus, und f\"uhren beide zu einem eindeutigen Ergebnis.

    \item $e$ ist von der Form $\expRec{x}{e'}$.

          Dann kommt ausschliesslich die small step Regel \RN{Unfold} in Frage, deren Ergebnis nach
          Lemma~\ref{lemma:Lo:Eindeutigkeit_von_Substitution} eindeutig ist.

    \item $e$ ist von der Form $\expLet{x}{e_1}{e_2}$.

          F\"ur $\blet$-Ausdr\"ucke kommen nur die beiden small step Regeln \RN{Let-Eval} und
          \RN{Let-Exec} in Frage.

          Existiert ein small step $e_1 \to e_1'$ kann nur die Regel \RN{Let-Eval} angewandt
          werden, da \RN{Let-Exec} als ersten Teilausdruck einen Wert erfordert. Nach
          Induktionsvoraussetzung ist $e_1'$ eindeutig durch $e_1$ bestimmt, also ist auch
          $\expLet{x}{e_1'}{e_2}$ eindeutig bestimmt durch $\expLet{x}{e_1}{e_2}$.

          Gilt andererseits $e_1 \not\to$, dann kann \RN{Let-Eval} nicht angewandt werden,
          und \RN{Let-Exec} nur, falls $e_1 \in \setVal$. Wenn \RN{Let-Exec} anwendbar ist,
          so ist das Ergebnis nach Lemma~\ref{lemma:Lo:Eindeutigkeit_von_Substitution} eindeutig.

    \item $e$ ist von der Form $\expCond{e_0}{e_1}{e_2}$.

          F\"ur bedingte Ausdr\"ucke kommen nur die drei small step Regeln \RN{Cond-Eval},
          \RN{Cond-True} und \RN{Cond-False} in Frage.

          Wenn ein small step $e_0 \to e_0'$ existiert, kann nur die Regel \RN{Cond-Eval}
          angewendet werden, da \RN{Cond-True} und \RN{Cond-False} als ersten Teilausdruck
          eine Konstante erfordern. Nach Induktionsvoraussetzung ist $e_0'$ eindeutig
          durch $e_0$ bestimmt, folglich ist auch $\expCond{e_0'}{e_1}{e_2}$ eindeutig
          bestimmt durch $\expCond{e_0}{e_1}{e_2}$.

          F\"ur $e_0 \not\to$ kommen nur die Regeln \RN{Cond-True} und \RN{Cond-False}
          in Frage, da \RN{Cond-Eval} erfordert, dass ein small step f\"ur $e_0$
          existiert. Diese beiden Regeln schliessen sich aus offensichtlichen
          Gr\"unden gegenseitig aus, und das Ergebnis ist stets eindeutig.

    \item $e$ ist von der Form $\expSend{e_1}{m}$.

          Dann kommen nur die beiden small step Regeln \RN{Send-Eval} und \RN{Send-Unfold}
          in Frage.

          Existiert ein small step $e_1 \to e_1'$, so ist nur \RN{Send-Eval} anwendbar,
          da \RN{Send-Unfold} einen Objektwert auf der linken Seite der Nachricht erfordert.
          Nach Induktionsvoraussetzung ist $e_1'$ eindeutig bestimmt durch $e_1$, also ist
          auch $\expSend{e_1'}{m}$ eindeutig durch $\expSend{e_1}{m}$ bestimmt.

          Gilt andererseits $e_1 \not\to$, dann ist \RN{Send-Eval} nicht anwendbar, und
          \RN{Send-Exec} kann nur angewendet werden, wenn $e_1$ ein Objektwert ist. In
          diesem Fall ist das Ergebnis wegen Lemma~\ref{lemma:Lo:Eindeutigkeit_von_Substitution}
          eindeutig bestimmt.

    \item $e$ ist von der Form $\expSend{\omega}{m}$.

          Dann kommen ausschliesslich die drei small step Regeln \RN{Send-Attr}, \RN{Send-Skip} und
          \RN{Send-Exec} in Frage.

          Falls $\omega = \rowEpsilon$ ist, kann keine der Regeln angewandt werden und
          es ist kein small step m\"oglich.

          Falls $\omega$ von der Form $\rowVal{a}{v}{\omega'}$ ist, dann kann nur Regel
          \RN{Send-Attr} angewandt werden, und das Ergebnis ist nach
          Lemma~\ref{lemma:Lo:Eindeutigkeit_von_Substitution} eindeutig.

          Wenn $r$ von der Form $\rowMethod{m'}{e}{\omega'}$ ist, dann ist aus
          offensichtlichen Gr\"unden nur exakt eine der beiden Regeln \RN{Send-Skip}
          und \RN{Send-Exec} anwendbar, und das Ergebnis ist mit Induktionsvoraussetzung
          eindeutig.

    \item $r$ ist von der Form $\rowEpsilon$.

          Dann existiert nach Lemma~\ref{lemma:Lo:Werte_und_small_steps} kein small step f\"ur $r$.

    \item $r$ ist von der Form $\rowVal{a}{e}{r_1}$.

          F\"ur Attributdeklarationen kommen nur die beiden small step Regeln \RN{Attr-Left}
          und \RN{Attr-Right} in Frage.

          Falls ein small step $e \to e'$ existiert, dann kann nur \RN{Attr-Left} angewendet
          werden, da \RN{Attr-Right} einen Wert auf der linken Seite der Attributdeklaration
          erfordert. Nach Induktionsvoraussetzung ist $e'$ eindeutig bestimmt durch $e$, also
          ist auch $\rowVal{a}{e'}{r_1}$ durch $\rowVal{a}{e}{r_1}$ eindeutig bestimmt.

          Falls $e \in \setVal$ und ein small step $r_1 \to r_1'$ existiert, kommt nur
          \RN{Attr-Right} in Frage. Nach Induktionsvoraussetzung ist $r_1'$
          durch $r_1$ eindeutig bestimmt, also ist auch $\rowVal{a}{e}{r_1'}$ eindeutig
          durch $\rowVal{a}{e}{r_1}$ bestimmt.

          F\"ur $e \in \setVal$ und $r_1 \in \setRVal$ gilt nach Lemma~\ref{lemma:Lo:Werte_und_small_steps}
          $\rowVal{a}{e}{r_1} \not\to$.

    \item $r$ ist von der Form $\rowMethod{m}{e}{r_1}$.

          Hier kommt lediglich die small step Regel \RN{Method-Right} in Frage. Falls ein
          small step $r_1 \to r_1'$ existiert, ist nach Induktionsvoraussetzung $r_1'$
          durch $r_1$ eindeutig bestimmt, also ist auch $\rowMethod{m}{e}{r_1'}$ eindeutig
          durch $\rowMethod{m}{e}{r_1}$ bestimmt.

          F\"ur $r_1 \in \setRVal$ gilt nach Lemma~\ref{lemma:Lo:Werte_und_small_steps}
          $\rowMethod{m}{e}{r_1} \not\to$.
  \PROOFCASEend
\end{beweis}
%
Die bereits angedeutete Eindeutigkeit von Berechnungen l\"a"st sich nun einfach als Korollar
des vorangegangenen Satzes formulieren.

\begin{korollar} \
  \begin{enumerate}
    \item F\"ur jeden Ausdruck $e$ existiert genau eine Berechnung.
    \item F\"ur jede endliche Berechnung $e_1 \to \ldots \to e_n$ ist das
          Resultat $e_n$ eindeutig durch $e_1$ bestimmt.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt trivialerweise aus der Eindeutigkeit des \"Ubergangsschritts.
\end{beweis}

Nun stellt sich sicherlich die Frage, warum die Eigenschaft der Eindeutigkeit der small step Semantik so
entscheidend ist. Neben dem offensichtlichen praktischen Nutzen, n\"amlich der Existenz eines Interpreters
f\"ur die Programmiersprache \Lo, ist die Eindeutigkeit f\"ur die sp\"ateren Beweise eine erhebliche
Erleichterung\footnote{Teilweise erm\"oglicht sie \"uberhaupt erst den Beweis von Eigenschaften.}.


%%%%%%%%%%%%%%%%%%%%%%%
%% Big step Semantik %%
%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Big step Semantik}


Wie bereits in Kapitel~\ref{chapter:Grundlagen} angedeutet wurde, existiert neben dem {\em iterativen
Ansatz} zur Definition von Semantiken noch ein {\em rekursiver Ansatz}, der als \define{big step Semantik}
bezeichnet wird. Hierbei wird das Ergebnis einer Umformung auf die Ergebnisse von Teilumformungen
zur\"uckgef\"uhrt. In der Praxis wird f\"ur Interpreter fast ausschliesslich der rekursive Ansatz benutzt,
da dieser eher der intuitiven Interpretation von Programmen entspricht.

In diesem Abschnitt wollen wir eine big step Semantik f\"ur die Programmiersprache \Lo\ entwickeln,
die \"aquivalent zu der im vorangegangenen Abschnitt definierten small step Semantik ist. Dazu
legen wir zun\"achst fest, was wir unter einem big step verstehen.

\begin{definition}
  Ein \define{big step} ist eine Formel der Form $e \Downarrow_e v$ mit $e \in \setExp,
  v \in \setVal$ oder $r \Downarrow_r \omega$ mit $r \in \setRow, \omega \in \setRVal$.
\end{definition}
%
Analog zur small step Semantik geben wir nun ein System von Regeln an, mit denen sich
g\"ultige big steps der Form $e \Downarrow_e e'$ und $r \Downarrow_r r'$ herleiten
lassen.

\begin{definition}[G\"ultige big steps]
  Ein \Index{big step}, $e \Downarrow_e v$ mit $e \in \setExp, v \in \setVal$ oder
  $r \Downarrow_r \omega$ mit $r \in \setRow, \omega \in \setRVal$, heisst {\em g\"ultig},
  wenn er sich mit den big step Regeln f\"ur die funktionale Sprache \Lf \\[5mm]
  \begin{tabular}{ll}
    \RN{Val}        & $v \Downarrow_e v$ \\[3mm]
    \RN{Op}         & $\expApp{\expApp{\op}{n_1}}{n_2} \Downarrow_e \op^I(n_1, n_2)$ \\[3mm]
    \RN{Beta-V}     & $\RULE{e\SUB{v}{x} \Downarrow_e v'}
                            {\expApp{(\expAbstr{x}{e})}{v} \Downarrow_e v'}$ \\[3mm]
    \RN{App}        & $\RULE{e_1 \Downarrow_e v_1
                             \quad
                             e_2 \Downarrow_e v_2
                             \quad
                             \expApp{v_1}{v_2} \Downarrow_e v}
                            {\expApp{e_1}{e_2} \Downarrow_e v}$ \\[3mm]
    \RN{Unfold}     & $\RULE{e\SUB{\expRec{x}{e}}{x} \Downarrow_e v}
                            {\expRec{x}{e} \Downarrow_e v}$ \\[3mm]
    \RN{Let}        & $\RULE{e_1 \Downarrow_e v_1
                             \quad
                             e_2\SUB{v_1}{x} \Downarrow_e v_2}
                            {\expLet{x}{e_1}{e_2} \Downarrow_e v_2}$ \\[3mm]
    \RN{Cond-True}  & $\RULE{e_0 \Downarrow_e \true \quad e_1 \Downarrow_e v}
                            {\expCond{e_0}{e_1}{e_2} \Downarrow_e v}$ \\[3mm]
    \RN{Cond-False} & $\RULE{e_0 \Downarrow_e \false \quad e_2 \Downarrow_e v}
                            {\expCond{e_0}{e_1}{e_2} \Downarrow_e v}$
  \end{tabular} \\[7mm]
  sowie den big step Regeln f\"ur Objekte \\[5mm]
  \begin{tabular}{ll}
    \RN{Object}     & $\RULE{r \Downarrow_r \omega}
                            {\expObject{\self}{r} \Downarrow_e \expObject{\self}{\omega}}$ \\[3mm]
    \RN{Send}       & $\RULE{e \Downarrow_e \expObject{\self}{\omega}
                             \quad
                             \expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m} \Downarrow_e v}
                            {\expSend{e}{m} \Downarrow_e v}$ \\[3mm]
    \RN{Send-Attr}  & $\RULE{\expSend{\omega\SUB{v}{a}}{m} \Downarrow_e v'}
                            {\expSend{(\rowVal{a}{v}{\omega})}{m} \Downarrow_e v'}$ \\[3mm]
    \RN{Send-Skip}  & $\RULE{m' \ne m \vee m \in \domm{\omega}
                             \quad
                             \expSend{\omega}{m} \Downarrow_e v}
                            {\expSend{(\rowMethod{m'}{e}{\omega})}{m} \Downarrow_e v}$ \\[3mm]
    \RN{Send-Exec}  & $\RULE{m' = m \wedge m \not\in \domm{\omega}
                             \quad
                             e \Downarrow_e v}
                            {\expSend{(\rowMethod{m'}{e}{\omega})}{m} \Downarrow_e v}$
  \end{tabular} \\[7mm]
  und den big step Regeln f\"ur Reihen \\[5mm]
  \begin{tabular}{ll}
    \RN{Omega}  & $\omega \Downarrow_r \omega$ \\[2mm]
    \RN{Attr}   & $\RULE{e \Downarrow_e v
                             \quad
                             r \Downarrow_r \omega}
                            {\rowVal{a}{e}{r} \Downarrow_r \rowVal{a}{v}{\omega}}$ \\[3mm]
    \RN{Method} & $\RULE{r \Downarrow_r \omega}
                            {\rowMethod{m}{e}{r} \Downarrow_r \rowMethod{m}{e}{\omega}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst.
\end{definition}

Analog zur small step Semantik betrachten wir $\Downarrow_e~\subseteq~\setExp~\times~\setVal$
und $\Downarrow_r~\subseteq~\setRow~\times~\setRVal$ als Relationen und schreiben lediglich
$\Downarrow$, wenn wir uns auf beide Relationen beziehen oder wenn aus dem Zusammenhang hervorgeht
welche Relation gemeint ist.  Weiter schreiben wir $e \not\Downarrow$, falls kein big step f\"ur $e$
existiert, und $r \not\Downarrow$, falls kein big step f\"ur $r$ existiert.

Intuitiv wird sofort ein elementarer Zusammenhang zwischen den small step Regeln und den
big step Regeln ersichtlich, so dass man vermuten kann, dass die beiden Semantik das gleiche
Laufzeitverhalten mit Blick auf das Ergebnis einer Berechnung aufweisen sollten. Der
\"Aquivalenzsatz sichert genau diese \"Ubereinstimmung der beiden Semantiken.

\begin{satz}[\"Aquivalenzsatz] \label{satz:Lo:Aequivalenzsatz} \
  \begin{enumerate}
    \item $\forall e\in\setExp:\forall v\in\setVal:\,
           e \Downarrow v\,\Leftrightarrow\,e \xrightarrow* v$
    \item $\forall r\in\setRow:\forall \omega \in\setRVal:\,
           r \Downarrow \omega\,\Leftrightarrow\,r \xrightarrow* \omega$
  \end{enumerate}
\end{satz}
%
Der Begriff der \"Aquivalenz besagt in diesem Zusammenhang lediglich, dass eine terminierende
Ausf\"uhrung eines Programms mit den unterschiedlichen Semantiken zum gleichen Ergebnis f\"uhrt.

\begin{beweis}
  Der Beweis erfolgt in zwei Schritten. Zun\"achst zeigen wir, dass f\"ur jeden big step
  eine \"aquivalente endliche Berechnung, d.h. eine maximale, endliche Berechnungsfolge
  von small steps, existiert. Anschliessend zeigen wir, dass f\"ur jede endliche Berechnung
  ein \"aquivalenter big step existiert.
  \begin{itemize}
    \item["`$\Rightarrow$"']
          Diese Richtung beweisen wir durch simultane Induktion \"uber die
          L\"ange der Herleitungen der big steps $e \Downarrow v$ und $r \Downarrow \omega$, und
          Fallunterscheidung nach der zuletzt angewandten big step Regel.
          \PROOFCASEbeg
            \item Im Fall von $v \Downarrow v$ mit big step Regel \RN{Val} gilt $v \xrightarrow* v$
                  wegen der Reflexivit\"at von $\xrightarrow*$.

            \item F\"ur $\expApp{\expApp{\op}{n_1}}{n_2} \Downarrow \op^I(n_1,n_2)$ mit big step
                  Regel \RN{Op} folgt $\expApp{\expApp{\op}{n_1}}{n_2} \to \op^I(n_1,n_2)$ mit
                  small step Regel \RN{Op}.

            \item $\expApp{(\expAbstr{x}{e})}{v} \Downarrow v'$ mit big step Regel \RN{Beta-V}
                  bedingt $e\SUB{v}{x} \Downarrow v'$. Nach Induktionsvoraussetzung existiert
                  also eine Berechnung $e\SUB{v}{x} \xrightarrow* v'$, mit small step Regel
                  \RN{Beta-V} gilt also $\expApp{(\expAbstr{x}{e})}{v} \to e\SUB{v}{x} \xrightarrow* v'$.

            \item $\expApp{e_1}{e_2} \Downarrow v$ mit big step Regel \RN{App} kann nur aus
                  Pr\"amissen der Form $e_1 \Downarrow v_1$, $e_2 \Downarrow v_2$ und
                  $\expApp{v_1}{v_2} \Downarrow v$ folgen. Wegen Induktionsvoraussetzung gilt
                  $e_1 \xrightarrow* v_1$, $e_2 \xrightarrow* v_2$ und $\expApp{v_1}{v_2} \xrightarrow* v$.
                  Dann existiert eine Berechnungsfolge $\expApp{e_1}{e_2} \xrightarrow* \expApp{v_1}{e_2}$
                  mit small step Regel \RN{App-Left}, und eine Berechnungsfolge
                  $\expApp{v_1}{e_2} \xrightarrow* \expApp{v_1}{v_2}$ mit small step Regel \RN{App-Right}.
                  Also existiert insgesamt eine Berechnung
                  $\expApp{e_1}{e_2} \xrightarrow* \expApp{v_1}{e_2} \xrightarrow* \expApp{v_1}{v_2} \xrightarrow* v$.

            \item F\"ur $\expSend{e}{m} \Downarrow v$ mit big step Regel \RN{Send} muss gelten
                  $e \Downarrow \expObject{\self}{\omega}$ und
                  $\expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m} \Downarrow v$, also gilt
                  nach Induktionsvoraussetzung $e \xrightarrow* \expObject{\self}{\omega}$ und
                  $\expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m} \xrightarrow* v$.
                  Wegen Regel \RN{Send-Unfold} gilt
                  $\expObject{\self}{\omega} \to \expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m}$,
                  weiter existiert eine Berechnungsfolge
                  $\expSend{e}{m} \xrightarrow* \expSend{\expObject{\self}{\omega}}{m}$ mit
                  small step Regel \RN{Send-Eval}, also existiert insgesamt eine Berechnung
                  \EQNbeg
                    &               & \expSend{e}{m} \\
                    & \xrightarrow* & \expSend{\expObject{\self}{\omega}}{m} \\
                    & \to           & \expSend{\omega\SUB{\expObject{\self}{\omega}}{\self}}{m} \\
                    & \xrightarrow* & v.
                  \EQNend
          \PROOFCASEend
          Die restlichen F\"alle sind ebenso einfach zu beweisen.

    \item["`$\Leftarrow$"']
          Der zweite Teil des Beweises erfolgt mittels simultaner Induktion \"uber
          die L\"ange der Berechnungen $e \xrightarrow{n} v$ und $r \xrightarrow{n} \omega$, und
          Fallunterscheidung nach der Form von $e$ und $r$.
          \PROOFCASEbeg
            \item F\"ur $e \xrightarrow{0} v$ gilt $e = v$, also existiert ein big step $e \Downarrow v$
                  mit Regel \RN{Val}, und entsprechend f\"ur $r \xrightarrow{0} \omega$ mit big step
                  Regel \RN{Omega}.

            \item Im Falle einer Applikation $e = \expApp{e_1}{e_2}$ mit $\expApp{e_1}{e_2} \xrightarrow{n+1} v$
                  unterscheiden wir nach der semantischen Form von $e_1$ und $e_2$.
                  \begin{enumerate}
                    \item Wenn $e_1,e_2\in\setVal$, dann kommen f\"ur den ersten small step der Herleitung
                          nur \RN{Op} und \RN{Beta-V} in Frage.

                          F\"ur \RN{Op} folgt die Behauptung trivialerweise mit big step Regel \RN{Op}.

                          F\"ur \RN{Beta-V} muss $e_1$ eine $\lambda$-Abstraktion sein, also $e_1=\expAbstr{x}{e_1'}$,
                          und die Berechnungsfolge die Form
                          \EQNbeg
                            \expApp{(\expAbstr{x}{e_1'})}{e_2} \to e_1'\SUB{e_2}{x} \xrightarrow{n} v
                          \EQNend
                          haben. Nach Induktionsvoraussetzung existiert ein big step
                          $e_1'\SUB{e_2}{x} \Downarrow v$ und mit big step Regel \RN{Beta-V} folgt
                          $\expApp{(\expAbstr{x}{e_1'})}{e_2} \Downarrow v$.

                    \item Es bleibt der Fall zu betrachten, dass $e_1$ oder $e_2$ kein Wert ist. Dann existieren
                          $v_1,v_2\in\setVal$, so dass die Berechnungsfolge wie folgt aussieht:
                          \EQNbeg
                            \expApp{e_1}{e_2} \xrightarrow* \expApp{v_1}{e_2} \xrightarrow* \expApp{v_1}{v_2} \xrightarrow* v
                          \EQNend
                          Die Berechnungsfolge $\expApp{e_1}{e_2} \xrightarrow* \expApp{v_1}{e_2}$ kann, sofern
                          nicht leer, ausschliesslich mit small step Regel \RN{App-Left} aus $e_1 \xrightarrow* v_1$ folgen.
                          Entsprechend kann $\expApp{v_1}{e_2} \xrightarrow* \expApp{v_1}{v_2}$, sofern nicht
                          leer, nur mit small step Regel \RN{App-Right} aus $e_2 \xrightarrow* v_2$ folgen.

                          Je nachdem, ob $e_1\in\setVal$ bzw. $e_2\in\setVal$, folgt $e_1\Downarrow v_1$ bzw.
                          $e_2 \Downarrow v_2$ entweder mit big step Regel \RN{Val} oder nach Induktionsvoraussetzung.
                          $\expApp{v_1}{v_2} \Downarrow v$ jedoch folgt in jedem Fall mit Induktionsvoraussetzung, da
                          zumindest einer der Ausdr\"ucke noch kein Wert ist, und somit die Berechnungsfolge
                          $\expApp{v_1}{v_2} \xrightarrow* v$ echt k\"urzer ist als $\expApp{e_1}{e_2} \xrightarrow* v$.

                          Insgesamt folgt also $\expApp{e_1}{e_2} \Downarrow v$ mit big step Regel \RN{App}.
                  \end{enumerate}

            \item F\"ur $e = \expCond{e_0}{e_1}{e_2}$ ist die Berechnungsfolge $e \xrightarrow* v$ von
                  der Form
                  \EQNbeg
                    \expCond{e_0}{e_1}{e_2} \xrightarrow* \expCond{v_0}{e_1}{e_2} \xrightarrow* v,
                  \EQNend
                  wobei sich $\expCond{e_0}{e_1}{e_2} \xrightarrow* \expCond{v_0}{e_1}{e_2}$ mit small
                  step Regel \RN{Cond-Eval} aus $e_0 \xrightarrow* v_0$ ergibt, und die Berechnungsfolge
                  \EQNbeg
                    \expCond{v_0}{e_1}{e_2} \xrightarrow* v
                  \EQNend
                  entweder mit small step Regel \RN{Cond-True},
                  f\"ur $v_0 = \true$, oder mit small step Regel \RN{Cond-False}, f\"ur $v_0 = \false$,
                  beginnen muss. F\"ur $e_0 \xrightarrow* v_0$ existiert nach Induktionsvoraussetzung ein
                  big step $e_0 \Downarrow v_0$.

                  Wenn $e_0 = \true$, dann hat die restliche Berechnungsfolge die Form
                  \EQNbeg
                    \expCond{\true}{e_1}{e_2} \to e_1 \xrightarrow* v
                  \EQNend
                  mit \RN{Cond-True} als erster small step Regel und nach Induktionsvoraussetzung
                  existiert ein big step $e_1 \Downarrow v$. Zusammengefasst folgt also
                  \EQNbeg
                    \expCond{e_0}{e_1}{e_2} \Downarrow v
                  \EQNend
                  mit big step Regel \RN{Cond-True}.

                  Entsprechend folgt f\"ur $v_0 = \false$ die Behauptung wegen big step Regel
                  \RN{Cond-False}.
          \PROOFCASEend
          Die weiteren F\"alle verlaufen \"ahnlich.
  \end{itemize}
\end{beweis}
%
Wie bereits angedeutet lassen sich mit Hilfe des \"Aquivalenzsatzes bereits bewiesene
Eigenschaften der small step Semantik auf die big step Semantik \"ubertragen.

\begin{korollar} \
  \begin{enumerate}
    \item Existiert ein big step $e \Downarrow v$ mit $e \in \setExp, v \in \setVal$, so ist
          $v$ durch $e$ eindeutig bestimmt.
    \item Existiert ein big step $r \Downarrow \omega$ mit $r \in \setRow, \omega \in \setRVal$, so ist
          $\omega$ durch $r$ eindeutig bestimmt.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt mit dem \"Aquivalenzsatz unmittelbar aus Satz~\ref{satz:Lo:Eindeutigkeit_des_Uebergangsschritts}
  \"uber die Eindeutigkeit des \"Ubergangsschritts.
\end{beweis}
%
In Anhang~\ref{anhang:Big_step_Interpreter} findet sich eine Implementierung eines Interpreters basierend
auf der in diesem Abschnitt entwickelten big step Semantik. Im weiteren Verlauf werden wir allerdings
ausschliesslich die f\"ur Beweise einfacher zu handhabende small step Semantik betrachten, dieser Abschnitt
sollte lediglich zeigen, wie eine aus theoretischen \"Uberlegungen entstandene Programmiersprache auf
eine praktische Implementierung \"ubertragen werden kann.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ein Interpreter für Lo %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Ein Interpreter f\"ur \Lo}
%
%
%%% BEGIN: Interpreter
%\index{Interpreter|(}
%
%
%Basierend auf der big step Semantik l\"asst sich ein Algorithmus zur Berechnung von \Lo-Programmen,
%ein sogenannter \Index{Interpreter}, formulieren. Dieser Interpreter erh\"alt als Eingabe ein
%\Lo-Programm, einen Ausdruck $e \in \setExp$, und liefert als Ausgabe einen Wert $v \in \setVal$,
%genau dann wenn ein big step $e \Downarrow v$ existiert.
%
%\begin{definition}
%  Seien ${\cal I}_e:\setExp \pto \setVal$ und ${\cal I}_r:\setRow \pto \setRVal$ die wie
%  folgt induktiv definierten, partiellen Funktionen.
%  \EQNbeg
%    \Ie{v} & = &
%      v
%    \\[1mm]
%
%    \Ie{\expApp{e_1}{e_2}} & = &
%      \CASEbeg
%        \op^I(n_1, n_2),       & \mbox{falls } \Ie{e_1} \downarrow= \expApp{\op}{n_1} \\
%                               & \mbox{und } \Ie{e_2} \downarrow= n_2 \\
%        \Ie{e\SUB{v}{\id}}, & \mbox{falls } \Ie{e_1} \downarrow= \expAbstr{\id}{e} \\
%                               & \mbox{und } \Ie{e_2} \downarrow= v \\
%        \uparrow,              & \mbox{sonst}
%      \CASEend
%    \\[11mm]
%
%    \Ie{\expRec{\id}{e}} & = &
%      \Ie{e\SUB{\expRec{\id}{e}}{\id}}
%    \\[1mm]
%
%    \Ie{\expLet{\id}{e_1}{e_2}} & = &
%      \CASEbeg
%        \Ie{e_2\SUB{v_1}{\id}}, & \mbox{falls } \Ie{e_1} \downarrow= v_1 \\
%        \uparrow,                  & \mbox{sonst}
%      \CASEend
%    \\[5mm]
%
%    \Ie{\expCond{e_0}{e_1}{e_2}} & = &
%      \CASEbeg
%        \Ie{e_1}, & \mbox{falls } \Ie{e_0} \downarrow= \true \\
%        \Ie{e_2}, & \mbox{falls } \Ie{e_0} \downarrow= \false \\
%        \uparrow,    & \mbox{sonst}
%      \CASEend
%    \\[8mm]
%
%    \Ie{\expObject{\id}{r}} & = &
%      \CASEbeg
%        \expObject{\id}{\omega}, & \mbox{falls } \Ir{r} \downarrow= \omega \\
%        \uparrow,                & \mbox{sonst}
%      \CASEend
%    \\[5mm]
%
%    \Ie{\expSend{e}{m}} & = &
%      \CASEbeg
%        \LONGbeg
%          \Ie{\expSend{\omega\SUB{\expObject{\id}{\omega}}{\id}}{m}}, \\
%          \mbox{ falls } \Ie{e} \downarrow= \expObject{\id}{\omega}
%        \LONGend \\
%        \LONGbeg
%          \uparrow, \\
%          \mbox{ sonst}
%        \LONGend
%      \CASEend
%    \\[11mm]
%
%    \Ie{\expSend{\omega}{m}} & = &
%      \CASEbeg
%        \LONGbeg
%          \Ie{\expSend{\omega'\SUB{v}{\id}}{m}}, \\
%          \mbox{ falls } \omega = \rowVal{\id}{v}{\omega'}
%        \LONGend \\
%        \LONGbeg
%          \Ie{\expSend{\omega'}{m}}, \\
%          \mbox{ falls } \omega = \rowMethod{m'}{e}{\omega'} \\
%          \mbox{ und } (m' \ne m \vee (\bmethod:m)\in\dom{\omega'})
%        \LONGend \\
%        \LONGbeg
%          \Ie{e}, \\
%          \mbox{ falls } \omega = \rowMethod{m'}{e}{\omega'} \\
%          \mbox{ und } (m' = m \wedge (\bmethod:m)\not\in\dom{\omega'})
%        \LONGend \\
%        \LONGbeg
%          \uparrow, \\
%          \mbox{ sonst}
%        \LONGend
%      \CASEend
%    \\[24mm]
%
%    \Ir{\omega} & = &
%      \omega
%    \\[1mm]
%
%    \Ir{\rowVal{\id}{e}{r}} & = &
%      \CASEbeg
%        \rowVal{\id}{v}{\omega},  & \mbox{falls } \Ie{e} \downarrow= v \\
%                                  & \mbox{und } \Ir{r} \downarrow= \omega \\
%                                  & \mbox{und } (\battr:\id) \not\in \dom{v} \\
%        \rowVal{\id'}{v}{\omega}, & \mbox{falls } \Ie{e} \downarrow= v \\
%                                  & \mbox{und } \Ir{r\SUBR{\id'}{\id}} \downarrow= \omega \\
%                                  & \mbox{und } (\battr:\id) \in \dom{v} \\
%                                  & \mbox{mit "`neuem"' } \id' \\
%        \uparrow,                 & \mbox{sonst}
%      \CASEend
%    \\[20mm]
%
%    \Ir{\rowMethod{m}{e}{r}} & = &
%      \CASEbeg
%        \rowMethod{m}{e}{\omega}, & \mbox{falls } \Ir{r} \downarrow= \omega \\
%        \uparrow,                 & \mbox{sonst}
%      \CASEend
%  \EQNend
%  Die Funktion ${\cal I}_e$ heisst \define{Interpreter f\"ur Ausdr\"ucke} und die
%  Funktion ${\cal I}_r$ heisst \define{Interpreter f\"ur Reihen}.
%\end{definition}
%
%{\bf TODO:} Prosa, Verweis auf die O'Caml Implementierung, etc.
%
%\begin{lemma}\label{lemma:korrektheit_von_evale_und_evalr} \
%  \begin{enumerate}
%    \item $\forall e\in\setExp:\forall v\in\setVal: \Ie{e} \downarrow= v \Leftrightarrow e \Downarrow_e v$
%    \item $\forall r\in\setRow:\forall\omega\in\setRVal:\Ir{r}\downarrow=\omega\Leftrightarrow r\Downarrow_r\omega$
%  \end{enumerate}
%\end{lemma}
%
%\begin{beweis}
%  {\bf TODO:} Oha, simultane Induktion \"uber $e$ und $r$
%\end{beweis}
%
%\begin{definition}[Interpreter f\"ur \Lo]
%  Die partielle Funktion
%  \[
%    \name{eval}:\setExp \pto \setVal, e \mapsto \Ie{e}
%  \] heisst \define{Interpreter f\"ur \Lo}.
%\end{definition}
%
%Damit k\"onnen wir nun den folgenden Satz \"uber die Korrektheit des
%Interpreters formulieren.
%
%\begin{satz}
%  $\forall e \in \setExp:\forall v \in \setVal: \I{e} \downarrow= v \Leftrightarrow e \Downarrow v$
%\end{satz}
%
%\begin{beweis}
%  Folgt direkt aus Lemma~\ref{lemma:korrektheit_von_evale_und_evalr} wegen $\I{e} = \Ie{e}$ f\"ur
%  alle \linebreak[4] $e~\in~\setExp$.
%\end{beweis}
%
%
%\index{Interpreter|)}
%% END: Interpreter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ein einfaches Typsystem %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ein einfaches Typsystem}


{\bf TODO:} Einfach -- entspricht dem {\em einfach getypten $\lambda$-Kalk\"ul} -- explizit getypt, keine
komplizierten Mechanismen wie rekursive Typen, Subtyping oder Polymorphie.

{\em structual typing} statt {\em opaque typing} (wie z.B. in Java oder C++), da dies in der
Theorie traditionell der verbreitetere Ansatz ist. Gewinnt aber auch in der Praxis im Bereich
von verteilten Systemen zunehmend an Bedeutung; z.B. bei Java RMI problematisch Objekte zu
versenden, beide Seiten m\"ussen \"uber die Klasse (und alle beteiligten Klassen verf\"ugen).
Einfacher/flexibler w\"are "`klassenlose"' Objekte zu versenden, und strukturelle Typen
zu verwenden.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax der Sprache Lot %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Syntax der Sprache \Lot}

\begin{definition}[Typen] \label{definition:Lot:Typen}
  Die Menge $\setType$ aller \Define{Typen}{Typ} $\tau$ von \Lot\ ist
  durch die kontextfreie Grammatik
  \GRbeg
  \tau \GRis \typeBool \GRmid \typeInt \GRmid \typeUnit \GRtext{Basistypen}
       \GRal \typeArrow{\tau_1}{\tau_2}                 \GRtext{Funktionstypen}
       \GRal \typeObject{\phi}                          \GRtext{Objekttypen}
  \GRend
  und die Menge $\setRType$ aller \Define{Reihentypen}{Reihentyp} $\phi$ von \Lot\ ist durch
  \GRbeg
  \phi \GRis \rtypeEmpty
       \GRal \rtypeMethod{m}{\tau}{\phi_1}
  \GRend
  definiert, wobei die Methodennamen in einem Reihentyp $\phi$ paarweise verschieden
  sein m\"ussen.
\end{definition}

Explizit getypt, d.h. Typen m\"ussen in die Syntax der Programmiersprache aufgenommen werden,
indem die Produktionen f\"ur Abstraktion, Rekursion und Objekte durch die folgenden
"`getypten Versionen"' ersetzt werden.
\GRbeg
e \GRis \expAbstr{x:\tau}{e_1}
  \GRal \expRec{x:\tau}{e_1}
  \GRal \expObject{\self:\tau}{r}
\GRend
F\"ur Reihentypen treffen wir die folgende Vereinbarung.
\begin{konvention}
  Die Reihenfolge in der die Methodentypen in einem Reihentypen aufgelistet werden ist irrelevant,
  d.h. es gilt
  \[
    \rtypeMethod{m_1}{\tau_1}{\rtypeMethod{m_2}{\tau_2}{\phi}}
    =
    \rtypeMethod{m_2}{\tau_2}{\rtypeMethod{m_1}{\tau_1}{\phi}}
  \]
  f\"ur alle $m_1,m_2 \in \setMethod$, $\tau_1,\tau_2 \in \setType$ und $\phi \in \setRType$.
\end{konvention}

{\bf TODO:} \"Uberleitung

\begin{definition} \label{definition:Lot:Vereinigung_von_Reihentypen}
  Die \define{Vereinigung} $\phi_1 \oplus \phi_2$ der beiden Reihentypen
  \[
    \phi_1 = \rtypeMethod{m_1}{\tau_1}{\ldots\rtypeMethod{m_n}{\tau_n}{\rtypeEmpty}}
  \]
  und
  \[
    \phi_2 = \rtypeMethod{m_1'}{\tau_1'}{\ldots\rtypeMethod{m_l'}{\tau_l'}{\rtypeEmpty}}
  \]
  ist definiert als
  \[
    \begin{array}{rcll}
      \phi_1 \oplus \phi_2
      & = & \rtypeMethod{m_{i_1}}{\tau_{i_1}}{\ldots\rtypeMethod{m_{i_x}}{\tau_{i_x}}{ 
        & \quad \text{(gemeinsame Methodentypen)} \\
      &   & \rtypeMethod{m_{j_1}}{\tau_{j_1}}{\ldots\rtypeMethod{m_{j_y}}{\tau_{j_y}}{
        & \quad \text{(Methodentypen exklusiv in $\phi_1$)} \\
      &   & \rtypeMethod{m_{k_1}'}{\tau_{k_1}'}{\ldots\rtypeMethod{m_{k_z}'}{\tau_{k_z}'}}{
        & \quad \text{(Methodentypen exklusiv in $\phi_2$)} \\
      &   & \rtypeEmpty}}}}}
    \end{array}
  \]
  mit
  \[
    \begin{array}{ccl}
      \{m_{i_1},\ldots,m_{i_x}\} & = & \{m_1,\ldots,m_n\} \cap \{m_1',\ldots,m_l'\}, \\
      \{m_{j_1},\ldots,m_{j_y}\} & = & \{m_1,\ldots,m_n\} \setminus \{m_{i_1},\ldots,m_{i_x}\}
        \text{ und} \\
      \{m_{k_1}',\ldots,m_{k_z}'\} & = & \{m_1',\ldots,m_l'\} \setminus \{m_{i_1},\ldots,m_{i_x}\},
    \end{array}
  \]
  falls $\forall i \in \{i_1,\ldots,i_x\}: \tau_i = \tau_i'$.
\end{definition}

Insbesondere f\"uhrt die Vereinigung zweier inkompatibler Reihentypen, die also auf dem Schnitt
ihrer Methodentypen nicht \"ubereinstimmen, w\"ahrend der Typ\"uberpr\"ufung zu einem Typfehler,
da in diesem Fall kein Vereinigungstyp definiert ist. Wir werden auch im Rahmen der Beweise der
S\"atze \"uber die Typsicherheit auf diese Definition zur\"uckgreifen.

\begin{definition} \label{definition:Lot:Disjunkte_Reihentypen}
  Zwei Reihentypen
  \[
    \phi_1 = \rtypeMethod{m_1}{\tau_1}{\ldots\rtypeMethod{m_n}{\tau_n}{\rtypeEmpty}}
  \]
  und
  \[
    \phi_2 = \rtypeMethod{m_1'}{\tau_1'}{\ldots\rtypeMethod{m_l'}{\tau_l'}{\rtypeEmpty}}
  \]
  heissen {\em disjunkt}, wenn $\{m_1,\ldots,m_n\} \cap \{m_1',\ldots,m_l'\} = \emptyset$.
\end{definition}

Hiermit l\"asst sich nun die erste einfache Eigenschaft unserer getypten Programmiersprache \Lot\
formulieren.

\begin{proposition}
  Die Vereinigung $\phi_1 \oplus \phi_2$ zweier disjunkter Reihentypen $\phi_1,\phi_2 \in \setRType$
  ist stets definiert.
\end{proposition}

\begin{beweis}
  Folgt verm\"oge Definition~\ref{definition:Lot:Disjunkte_Reihentypen} unmittelbar aus
  Definition~\ref{definition:Lot:Vereinigung_von_Reihentypen}, da
  \[
    \forall i \in \emptyset:\tau_i = \tau_i'
  \]
  allgemeing\"ultig ist.
\end{beweis}


%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntaktischer Zucker %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Syntaktischer Zucker}

{\bf TODO:} Syntaktischer Zucker entsprechend mit Typen versehen.

\[
  \begin{array}{ccll}
    \rowMethod{m\ (x_1:\tau_1)\ldots(x_n:\tau_n)}{e}{r} &
      \text{f\"ur} &
      \rowMethod{m}{\expAbstr{x_1:\tau_1}{\ldots\expAbstr{x_n:\tau_n}{e}}}{r}
  \end{array}
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typsystem der Sprache Lot %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Typsystem der Sprache \Lot}

\begin{definition}[Typurteile f\"ur Konstanten] \label{definition:Lot:Typurteile_fuer_Konstanten}
  Ein {\em Typurteil f\"ur Konstanten}\index{Typurteile!f\"ur Konstante} ist eine Formel der Gestalt $\tj{c}{\tau}$
  mit $c \in \setConst, \tau \in \setType$.
  Die {\em g\"ultigen} Typurteile sind durch die folgenden Axiome festgelegt. \\[5mm]
  \begin{tabular}{lll}
    \RN{Bool} & $\tj{b}{\typeBool}$ \\
    \RN{Int}  & $\tj{n}{\typeInt}$ \\
    \RN{Unit} & $\tj{()}{\typeUnit}$ \\
    \RN{Aop}  & $\tj{\op}{\typeIntIntInt}$  & falls $\op \in \{+,-,*\}$ \\
    \RN{Rop}  & $\tj{\op}{\typeIntIntBool}$ & falls $\op \in \{<,>,\le,\ge,=\}$
  \end{tabular}
\end{definition}

Das Typurteil $\tj{c}{\tau}$ liest man als "`$c$ hat Typ $\tau$"'. Man beachte, dass
gem\"ass obiger Definition jede Konstante $c \in \setConst$ einen eindeutigen Typ
$\tau \in \setType$ hat.

\begin{definition}[Typumgebungen] \label{definition:Lot:Typumgebungen} \
  \begin{enumerate}
    \item Eine \define{Typumgebung} ist eine partielle Funktion $\Gamma:\setId\pto\setType$
          mit endlichem Definitionsbereich.

    \item Sei $\Gamma$ eine Typumgebung, dann bezeichnet $\Gamma^\star$ die Typumgebung mit
          den folgenden Eigenschaften.
          \begin{itemize}
            \item $\dom{\Gamma^\star} = \dom{\Gamma}\,\cap\,\setVar$
            \item $\forall \id\in\dom{\Gamma^\star}:\,\Gamma^\star(\id) = \Gamma(\id)$
          \end{itemize}

    \item Sei $\Gamma$ eine Typumgebung, dann bezeichnet $\Gamma^+$ die Typumgebung mit
          den folgenden Eigenschaften.
          \begin{itemize}
            \item $\dom{\Gamma^+} = \dom{\Gamma}\,\setminus\,\dom{\Gamma^\star}$
            \item $\forall \id\in\dom{\Gamma^+}:\,\Gamma^+(\id) = \Gamma(\id)$
          \end{itemize}

    \item Die Menge $\setTEnv = \{ \Gamma\ |\ \Gamma \text{ ist eine Typumgebung}\}$ enth\"alt
          alle Typumgebungen.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa.

\begin{bemerkung}
  Wir verwenden die Listenschreibweise $[\id_1:\tau_1,\ldots,\id_n:\tau_n]$
  mit $n \ge 0$ f\"ur die Typumgebung $\Gamma$ mit den Eigenschaften
  \begin{enumerate}
    \item $\dom{\Gamma} = \{\id_1,\ldots,\id_n\}$ und
    \item $\forall i \in \{1,\ldots,n\}:\,\Gamma(\id_i) = \tau_i$.
  \end{enumerate}
\end{bemerkung}

Die Listenschreibweise verdeutlicht, dass eine Typumgebung letztlich nichts anderes ist als eine
"`Tabelle"', in der die Typen der bereits bekannten Namen eingetragen sind\footnote{In der
Compilerbau-Literatur findet man deshalb h\"aufig die Bezeichnung "`Symboltabelle"'.}. Das
"`Nachschlagen"' in der Tabelle $\Gamma$ k\"onnen wir durch die Funktionsanwendung zum Ausdruck
bringen: Falls $\id \in \dom{\Gamma}$, dann liefert $\Gamma(\id)$ den Typ $\tau$, die f\"ur den
Namen $\id$ in der Tabelle $\Gamma$ eingetragen wurden, sonst ist $\Gamma(\id)$ undefiniert.

Nach diesen Vorbereitungen k\"onnen wir nun die Wohlgetyptheit von Ausdr\"ucken und Reihen
der Programmiersprache \Lot\ formulieren. Dazu definieren wir zun\"achst was wir unter
einem Typurteil verstehen wollen und geben anschliessend ein Regelwerk an, mit dem sich
g\"ultige Typurteile f\"ur \Lot\ herleiten lassen.

\begin{definition}[Typurteile f\"ur Ausdr\"ucke und Reihen] \
  \begin{enumerate}
    \item Ein {\em Typurteil f\"ur Ausdr\"ucke}\index{Typurteile!f\"ur Ausdr\"ucke} ist eine Formel der
          Gestalt $\Tje{\Gamma}{e}{\tau}$ mit \linebreak[4] $\Gamma:\setId\pto\setType$, $e\in\setExp$ und
          $\tau\in\setType$.
    \item Ein {\em Typurteil f\"ur Reihen}\index{Typurteile!f\"ur Reihen} ist eine Formel der Gestalt
          $\Tjr{\Gamma}{r}{\phi}$ mit $\Gamma:\setId\pto\setType$, $r\in\setRow$ und $\phi\in\setRType$.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa

\begin{definition}[G\"ultige Typurteile f\"ur \Lot] \label{definition:Lot:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Lot}
  Ein Typurteil $\Tje{\Gamma}{e}{\tau}$ oder $\Tjr{\Gamma}{r}{\phi}$ heisst {\em g\"ultig} f\"ur
  \Lot, wenn es sich mit den Typregeln f\"ur die funktionale Kernsprache \\[5mm]
  \begin{tabular}{ll}
    \RN{Id}     & $\Tje{\Gamma}{\id}{\tau} \quad \text{falls } \id\in\dom{\Gamma} \wedge \Gamma(\id) = \tau$ \\[1mm]
    \RN{Const}  & $\RULE{\tj{c}{\tau}}
                        {\Tje{\Gamma}{c}{\tau}}$ \\[4mm]
    \RN{App}    & $\RULE{\Tje{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau}} \quad \Tj{\Gamma}{e_2}{\tau_2}}
                        {\Tje{\Gamma}{\expApp{e_1}{e_2}}{\tau}}$ \\[4mm]
    \RN{Abstr}  & $\RULE{\Tje{\Gamma\SUB{\tau}{x}}{e}{\tau'}}
                        {\Tje{\Gamma}{\expAbstr{x:\tau}{e}}{\typeArrow{\tau}{\tau'}}}$ \\[4mm]
    \RN{Rec}    & $\RULE{\Tje{\Gamma\SUB{\tau}{x}}{e}{\tau}}
                        {\Tje{\Gamma}{\expRec{x:\tau}{e}}{\tau}}$ \\[4mm]
    \RN{Let}    & $\RULE{\Tje{\Gamma}{e_1}{\tau_1}
                         \quad
                         \Tje{\Gamma\SUB{\tau_1}{x}}{e_2}{\tau_2}}
                        {\Tje{\Gamma}{\expLet{x}{e_1}{e_2}}{\tau_2}}$ \\[4mm]
    \RN{Cond}   & $\RULE{\Tje{\Gamma}{e_0}{\typeBool}
                         \quad
                         \Tje{\Gamma}{e_1}{\tau}
                         \quad
                         \Tje{\Gamma}{e_2}{\tau}}
                        {\Tje{\Gamma}{\expCond{e_0}{e_1}{e_2}}{\tau}}$
  \end{tabular} \\[7mm]
  sowie den Typregeln f\"ur Objekte \\[5mm]
  \begin{tabular}{ll}
    \RN{Send}   & $\RULE{\Tje{\Gamma}{e}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}}
                        {\Tje{\Gamma}{\expSend{e}{m}}{\tau}}$ \\[4mm]
    \RN{Send'}  & $\RULE{\Tjr{\Gamma}{\omega}{(\rtypeMethod{m}{\tau}{\phi})}}
                        {\Tje{\Gamma}{\expSend{\omega}{m}}{\tau}}$ \\[4mm]
    \RN{Object} & $\RULE{\Tjr{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}
                         \quad
                         \tau = \typeObject{\phi}}
                        {\Tje{\Gamma}{\expObject{\self:\tau}{r}}{\tau}}$ \\[4mm]
    \RN{Dupl}   & $\RULE{\Tje{\Gamma}{\self}{\tau}
                         \quad
                         \forall i=1 \ldots n:\Tje{\Gamma}{a_i}{\tau_i} \wedge \Tje{\Gamma}{e_i}{\tau_i}}
                        {\Tje{\Gamma}{\expDupl{a_1=e_1;\ldots;a_n=e_n}}{\tau}}$
  \end{tabular} \\[7mm]
  und den Typregeln f\"ur Reihen \\[5mm]
  \begin{tabular}{ll}
    \RN{Empty}  & $\Tjr{\Gamma}{\rowEpsilon}{\rtypeEmpty}$ \\[2mm]
    \RN{Attr}   & $\RULE{\Tje{\Gamma^\star}{e}{\tau}
                         \quad
                         \Tjr{\Gamma\SUB{\tau}{a}}{r_1}{\phi}}
                        {\Tjr{\Gamma}{\rowVal{a}{e}{r_1}}{\phi}}$ \\[4mm]
    \RN{Method} & $\RULE{\Tje{\Gamma}{e}{\tau}
                         \quad
                         \Tjr{\Gamma}{r_1}{\phi}}
                        {\Tjr{\Gamma}{\rowMethod{m}{e}{r_1}}
                             {(\rtypeMethod{m}{\tau}{\rtypeEmpty}) \oplus \phi}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst. Hierbei wird die spezielle Typregel \RN{Send'} ausschliesslich
  f\"ur den Beweis der Typsicherheit ben\"otigt.
\end{definition}

{\bf TODO:} Erl\"auterung des Regelwerks, Beispiel einer Typherleitung

Im Folgenden schreiben wir statt $\Tje{\Gamma}{e}{\tau}$ kurz $\Tj{\Gamma}{e}{\tau}$ und
statt $\Tjr{\Gamma}{r}{\phi}$ kurz $\Tj{\Gamma}{r}{\phi}$, da es aus dem Zusammenhang
stets ersichtlich ist, ob es sich um ein Typurteil f\"ur Ausdr\"ucke oder ein Typurteil
f\"ur Reihen handelt.

\begin{definition}[Wohlgetyptheit] \label{definition:Lot:Wohlgetyptheit} \
  \begin{enumerate}
    \item Ein Ausdruck $e \in \setExp$ heisst {\em wohlgetypt in $\Gamma$}, wenn es
          ein $\tau \in \setType$ gibt, so dass gilt: $\Tj{\Gamma}{e}{\tau}$.
    \item Eine Reihe $r \in \setRow$ heisst {\em wohlgetypt in $\Gamma$}, wenn es
          ein $\phi \in \setRType$ gibt, so dass gilt: $\Tj{\Gamma}{r}{\phi}$.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa

\begin{satz}[Typeindeutigkeit] \label{satz:Lot:Typeindeutigkeit} \
  \begin{enumerate}
    \item F\"ur jede Typumgebung $\Gamma$ und jeden Ausdruck $e \in \setExp$ existiert
          h\"ochstens ein Typ $\tau \in \setType$ mit $\Tj{\Gamma}{e}{\tau}$.
    \item F\"ur jede Typumgebung $\Gamma$ und jede Reihe $r \in \setRow$ existiert
          h\"ochstens ein Reihentyp $\phi \in \setRType$ mit $\Tj{\Gamma}{r}{\phi}$.
  \end{enumerate}
\end{satz}

\begin{beweis}
  Der Beweis erfolgt durch simultane Induktion \"uber die Gr\"osse von $e$ und $r$ und
  Fallunterscheidung nach der Form von $e$ und $r$. Im einzelnen ist zu zeigen, dass
  f\"ur jeden Ausdruck und jede Reihe h\"ochstens eine Typregel anwendbar ist, was
  unmittelbar aus der Definition der g\"ultigen Typregeln folgt, da f\"ur jede syntaktische
  Form nur jeweils genau eine Typregel existiert.
\end{beweis}

\begin{korollar}
  Sei $\Gamma$ eine Typumgebung.
  \begin{enumerate}
    \item Ist $e\in\setExp$ wohlgetypt in $\Gamma$, dann existiert genau ein $\tau \in \setType$
          mit $\Tj{\Gamma}{e}{\tau}$.
    \item Ist $r\in\setRow$ wohlgetypt in $\Gamma$, dann existiert genau ein $\phi \in \setRType$
          mit $\Tj{\Gamma}{e}{\phi}$.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt verm\"oge Definition~\ref{definition:Lot:Wohlgetyptheit} direkt aus
  Satz~\ref{satz:Lot:Typeindeutigkeit}.
\end{beweis}

Diese Erkenntnis erlaubt es uns einen Algorithmus zu formulieren, der \"uberpr\"uft, ob ein
Ausdruck in einer gegebenen Typumgebung wohlgetypt ist, und falls ja, den eindeutigen Typ
des Ausdrucks liefert.

{\bf TODO:} Typalgorithmus


%%%%%%%%%%%%%%%%%%%
%% Typsicherheit %%
%%%%%%%%%%%%%%%%%%%

\subsection{Typsicherheit}
\index{Typsicherheit}

Nach diesen einleitenden Betrachtung wollen wir nun zeigen, dass die Programmiersprache
\Lot\ typsicher ist. Typsicherheit bedeutet in diesem Zusammenhang, dass die Berechnung
eines wohlgetypten abgeschlossenen Ausdrucks nicht steckenbleiben kann. Das bedeutet,
das Typsystem soll m\"oglichst alle Ausdr\"ucke identifizieren, deren Berechnung
stecken bleiben w\"urde.

Wichtig zu bemerken ist hierbei, dass durch ein Typsystem, welches ausschliesslich auf
syntaktischen Informationen arbeitet\footnote{Dies trifft auf alle in diesem Dokument
vorgestellten Typsysteme zu.}, keine strikte Trennung zwischen Programmen, deren
Berechnung stecken bleibt, und Programmen, die mit einem Wert terminieren oder divergieren,
m\"oglich ist. Eine derartige eindeutige Trennung widerspricht der Unentscheidbarkeit des
Halteproblems, da die Programmiersprache \Lot\ turing-vollst\"andig ist
(vgl. \cite{Spreen92}, \cite[S.93ff]{Wagner94} und \cite[S.21ff]{Wegener93}).

Man muss sich also damit abfinden, dass ein Typsystem f\"ur eine turing-vollst\"andige
Programmiersprache immer auch Programme ablehnen wird, die w\"ahrend der Auswertung
nicht stecken bleiben w\"urden. Man versucht deshalb Typsysteme immer weiter zu
verbessern, so dass immer weniger korrekte Programme abgelehnt werden. Wichtiger
f\"ur unsere Betrachtung jedoch ist die Eigenschaft, dass das Typsystem definitiv
alle Programme identifiziert, die stecken bleiben w\"urden.

Dazu sei die Berechnung eines Ausdrucks in \Lot\ wie in \Lo\ definiert. Die Definition der
Menge $\setVal$ muss an die neue Syntax angepasst werden, in dem die Produktionen
durch die entsprechenden Produktionen mit Typen ersetzt werden.
\GRbeg
v \GRis \expAbstr{x:\tau}{e}
  \GRal \expObject{\self:\tau}{\omega}
\GRend
Die small step Regeln aus \Lo\ werden \"ubernommen, wobei die Regeln \RN{Beta-V}, \RN{Unfold},
\RN{Object-Eval} und \RN{Send-Unfold} an die neue Syntax angepasst
werden m\"ussen. \\[5mm]
\begin{tabular}{ll}
  \RN{Beta-V}       & $\expApp{(\expAbstr{x:\tau}{e})}{v} \to_e e\SUB{v}{x}$ \\[3mm]
  \RN{Unfold}       & $\expRec{x:\tau}{e} \to_e e\SUB{\expRec{x:\tau}{e}}{x}$ \\[2mm]
  \RN{Object-Eval}  & $\RULE{r \to_r r'}
                            {\expObject{\self:\tau}{r} \to_e \expObject{\self:\tau}{r'}}$ \\[5mm]
  \RN{Send-Unfold}  & $\expSend{\expObject{\self:\tau}{\omega}}{m}
                       \to_e \expSend{\omega\SUB{\expObject{\self:\tau}{\omega}}{\self}}{m}$
\end{tabular} \\[7mm]
Es gilt zu beachten, dass der Typ in diesen Ausdr\"ucken keinerlei Einfluss auf den
small step hat, d.h. Typen spielen zur Laufzeit keine Rolle. Sie werden lediglich
zur Compilezeit w\"ahrend der statischen Typ\"uberpr\"ufung ben\"otigt. Die folgende
Definition verdeutlicht diese Sachverhalt.

\begin{definition}
  F\"ur jeden Ausdruck $e \in \setExp(\Lot)$ sei $\erase{e} \in \setExp(\Lo)$ der Ausdruck, der aus $e$
  durch Entfernen aller Typen entsteht\footnote{Wir benutzen im Folgenden die Schreibweise $M({\cal L})$ zur
  Verdeutlichung, dass wir uns auf die Definition der Menge $M$ in der Sprache $\mathcal{L}$
  beziehen.}, also
  \EQNbeg
    \erase{c} & = &
      c
    \\

    \erase{\id} & = &
      \id
    \\

    \erase{\expApp{e_1}{e_2}} & = &
      \expApp{\erase{e_1}}{\erase{e_2}}
    \\

    \erase{\expAbstr{x:\tau}{e}} & = &
      \expAbstr{x}{\erase{e}}
    \\

    \erase{\expRec{x:\tau}{e}} & = &
      \expRec{x}{\erase{e}}
    \\

    \erase{\expLet{x}{e_1}{e_2}} & = &
      \expLet{x}{\erase{e_1}}{\erase{e_2}}
    \\

    \erase{\expCond{e_0}{e_1}{e_2}} & = &
      \expCond{\erase{e_0}}{\erase{e_1}}{\erase{e_2}}
    \\

    \erase{\expSend{e}{m}} & = &
      \expSend{\erase{e}}{m}
    \\

    \erase{\expSend{\omega}{m}} & = &
      \expSend{\erase{\omega}}{m}
    \\

    \erase{\expObject{\self:\tau}{r}} & = &
      \expObject{\self}{\erase{r}}
    \\

    \erase{\expDupl{{a_i=e_i}^{i=1 \ldots n}}} & = &
      \expDupl{{a_i=\erase{e_i}}^{i=1 \ldots n}}
  \EQNend
  und f\"ur jede Reihe $r \in \setRow(\Lot)$ sei $\erase{r} \in \setRow(\Lo)$ die Reihe, die aus $r$
  durch Entfernen aller Typen ensteht, also
  \EQNbeg
    \erase{\rowEpsilon} & = &
      \rowEpsilon
    \\

    \erase{\rowVal{a}{e}{r}} & = &
      \rowVal{a}{\erase{e}}{\erase{r}}
    \\

    \erase{\rowMethod{m}{e}{r}} & = &
      \rowMethod{m}{\erase{e}}{\erase{r}}.
  \EQNend
\end{definition}

Bei der Funktion $\name{erase}: \setExp(\Lot) \to \setExp(\Lo)$ handelt es sich also offensichtlich
um einen \"Ubersetzer zwischen der Sprache \Lot\ und der Sprache \Lo. Bei \"Ubersetzern zwischen
Programmiersprachen interessieren wir uns im wesentlichen daf\"ur, dass diese {\em semantikerhaltend}
sind, d.h. dass ein Ausdruck durch eine \"Ubersetzung in eine andere Programmiersprache keine neue
Bedeutung erlangt. Der folgende Satz sichert diese Eigenschaft f\"ur die Funktion $\name{erase}$.

\begin{satz} \
  \begin{enumerate}
    \item $\forall e,e' \in \setExp(\Lot):\,e \to e' \Leftrightarrow \erase{e} \to \erase{e'}$
    \item $\forall r,r' \in \setRow(\Lot):\,r \to r' \Leftrightarrow \erase{r} \to \erase{r'}$
  \end{enumerate}
\end{satz}

\begin{beweis}
  {\bf TODO:} Nicht sch\"on, k\"onnte man allerdings wie folgt argumentieren:\\
  Folgt unmittelbar aus der Tatsache, dass die small step Semantik f\"ur \Lot\ mit der small
  step Semantik f\"ur \Lo\ bis auf syntaktische Details -- die Typen -- \"ubereinstimmt.
\end{beweis}

\begin{korollar}
  $\forall e \in \setExp(\Lot), v \in \setVal(\Lot):\,
   e \xrightarrow* v \Leftrightarrow \erase{e} \xrightarrow* \erase{v}$
\end{korollar}

\begin{beweis}
  Trivial.
\end{beweis}

{\bf TODO:} Erkl\"aren warum macht man das?

{\bf TODO:} Prosa

{\bf TODO:} Lemmata

\begin{definition} \label{definition:Lot:Uebereinstimmung_von_Typumgebungen}
  Seien $\Gamma_1, \Gamma_2 \in \setTEnv$ und $A \subseteq \setId$. $\Gamma_1$ und $\Gamma_2$
  {\em stimmen \"uberein auf $A$}, wenn gilt:
  \begin{itemize}
    \item $A \subseteq \dom{\Gamma_1}$
    \item $A \subseteq \dom{\Gamma_2}$
    \item $\forall \id \in A:\,\Gamma_1(\id) = \Gamma_2(\id)$
  \end{itemize}
  In diesem Fall schreiben wir $\Gamma_1 =_A \Gamma_2$.
\end{definition}

{\bf TODO:} Eigentlich zu trivial f\"ur ein Lemma...

\begin{lemma} \label{lemma:Lot:Uebereinstimmung_von_Typumgebungen}
  Sei $\Gamma_1,\Gamma_2 \in \setTEnv$. Dann gilt:
  \begin{enumerate}
    \item $\forall A\subseteq\setId, B\subseteq A:\,
           \Gamma_1 =_A \Gamma_2\,\Rightarrow\,\Gamma_1 =_B \Gamma_2$
    \item $\forall A\subseteq\setVar:\,
           \Gamma_1 =_A \Gamma_2\,\Rightarrow\,\Gamma_1^\star =_A \Gamma_2^\star$
    \item $\forall A\subseteq\setId, \id\in\setId, \tau\in\setType:\,
           \Gamma_1 =_A \Gamma_2\,\Rightarrow\,\Gamma_1\SUB{\tau}{\id} =_{A\cup\{\id\}} \Gamma_2\SUB{\tau}{\id}$
  \end{enumerate}
\end{lemma}

\begin{beweis} \
  \begin{enumerate}
    \item Sei $B \subseteq A$. Dann folgt unmittelbar $B \subseteq A \subseteq \dom{\Gamma_1}$,
          $B \subseteq A \subseteq \dom{\Gamma_2}$ und \linebreak[4]
          $\forall \id \in B \subseteq A:\,\Gamma_1(\id) = \Gamma_2(\id)$.

    \item Folgt unmittelbar aus der Definition, da $\dom{\Gamma^\star} = \dom{\Gamma} \cap \setVar$.

    \item Folgt ebenso problemlos aus $A\cup\{\id\} \subseteq \dom{\Gamma_1\SUB{\tau}{\id}}$,
          $A\cup\{\id\} \subseteq \dom{\Gamma_2\SUB{\tau}{\id}}$ und
          $\Gamma_1\SUB{\tau}{\id}(\id) = \tau = \Gamma_2\SUB{\tau}{\id}(\id)$.
  \end{enumerate}
\end{beweis}

{\bf TODO:} \"Uberleitung

\begin{lemma}[Typumgebungen und frei vorkommende Namen] \label{lemma:Lot:free_und_dom_Gamma} \
  \begin{enumerate}
    \item $\forall \Gamma \in \setTEnv, e\in\setExp,\tau\in\setType:\,
           \Tj{\Gamma}{e}{\tau}\,\Rightarrow\,\free{e}\subseteq\dom{\Gamma}$
    \item $\forall \Gamma \in \setTEnv, r\in\setRow,\phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\Rightarrow\,\free{r}\subseteq\dom{\Gamma}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wir f\"uhren den Beweis durch simultane Induktion \"uber die L\"ange der Herleitung
  der Typurteile $\Tj{\Gamma}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$ und Fallunterscheidung
  nach der zuletzt angewandten Typregel. Dazu betrachten wir exemplarisch die folgenden
  F\"alle.
  \PROOFCASEbeg
    \item $\Tj{\Gamma}{c}{\tau}$ mit Typregel \RN{Const}. Dann gilt $\free{c} = \emptyset \subseteq \dom{\Gamma}$.

    \item $\Tj{\Gamma}{\id}{\tau}$ mit Typregel \RN{Id}. Dann gilt $\id\in\dom{\Gamma}$ und
          $\Gamma(\id) = \tau$, also folgt $\free{\id} = \{\id\} \subseteq \dom{\Gamma}$.

    \item $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} kann nur aus Pr\"amissen
          der Form $\Tj{\Gamma}{e_1}{\typeArrow{\tau'}{\tau}}$ und $\Tj{\Gamma}{e_2}{\tau'}$
          folgen. Nach Induktionsvoraussetzung gilt $\free{e_1} \subseteq \dom{\Gamma}$ und
          $\free{e_2} \subseteq \dom{\Gamma}$. Wegen Definition~\ref{definition:Lo:Frei_vorkommende_Namen}
          folgt schliesslich $\free{\expApp{e_1}{e_2}} \subseteq \dom{\Gamma}$.

    \item $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object} kann ausschliesslich aus
          $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$ folgen.
          Nach Induktionsvoraussetzung gilt
          $\free{r} \subseteq \dom{\Gamma^\star\SUB{\tau}{\self}}$ und
          wegen $\dom{\Gamma^\star\SUB{\tau}{\self}} \subseteq \dom{\Gamma} \cup \{\self\}$
          folgt $\free{r} \setminus \{\self\} \subseteq \dom{\Gamma}$.
          Verm\"oge Definition~\ref{definition:Lo:Frei_vorkommende_Namen} gilt folglich
          $\free{\expObject{\self:\tau}{r}} \subseteq \dom{\Gamma}$.

    \item $\Tj{\Gamma}{\expDupl{{a_i=e_i}^{i=1 \ldots n}}}{\tau}$ mit Typregel \RN{Dupl} kann nur aus
          $\Tj{\Gamma}{\self}{\tau}$ und $\Tj{\Gamma}{a_i}{\tau_i} \wedge \Tj{\Gamma}{e_i}{\tau_i}$
          f\"ur alle $i=1,\ldots,n$ folgen. Nach Induktionsvoraussetzung gilt dann einerseits
          $\free{\self} \subseteq \dom{\Gamma}$, also insbesondere $\self\in\dom{\Gamma}$, und andererseits
          $\free{a_i} \subseteq \dom{\Gamma}$ und $\free{e_i} \subseteq \dom{\Gamma}$ f\"ur $i=1,\ldots,n$.
          Nach Definition~\ref{definition:Lo:Frei_vorkommende_Namen} folgt somit
          $\free{\expDupl{{a_i=e_i}^{i=1 \ldots n}}} \subseteq \dom{\Gamma}$.

    \item $\Tj{\Gamma}{\rowVal{a}{e}{r}}{\phi}$ mit Typregel \RN{Attr} kann nur aus Pr\"amissen der
          Form $\Tj{\Gamma^\star}{e}{\tau}$ und $\Tj{\Gamma\SUB{\tau}{a}}{r}{\phi}$ folgen. Mit
          Induktionsvoraussetzung folgt hieraus \linebreak[4] $\free{e} \subseteq \dom{\Gamma^\star}$ und
          $\free{r} \subseteq \dom{\Gamma\SUB{\tau}{a}}$. Wegen $\dom{\Gamma^\star} \subseteq \dom{\Gamma}$
          und $\dom{\Gamma\SUB{\tau}{a}} = \dom{\Gamma}\cup\{a\}$ folgt
          $\free{e} \cup (\free{r} \setminus \{a\}) \subseteq \dom{\Gamma}$, und gem\"a"s
          Definition~\ref{definition:Lo:Frei_vorkommende_Namen} gilt somit
          $\free{\rowVal{a}{e}{r}} \subseteq \dom{\Gamma}$.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen analog.
\end{beweis}
%
Insbesondere folgt, dass Ausdr\"ucke, die in einer Typumgebung $\Gamma^\star$ wohlgetypt sind, keine freien
Vorkommen von Attribut- oder Objektnamen enthalten k\"onnen. Diese Folgerung des Lemmas werden wir in den
folgenden Beweisen h\"aufiger benutzen, und formulieren sie deshalb als Korollar.

\begin{korollar}
  $\forall \Gamma\in\setTEnv,e\in\setExp,\tau\in\setType:\,
   \Tj{\Gamma^\star}{e}{\tau}\,\Rightarrow\,e\in\setExp^\star$
\end{korollar}

\begin{beweis}
  Folgt unmittelbar aus Lemma~\ref{lemma:Lot:free_und_dom_Gamma}.
\end{beweis}

{\bf TODO:} \"Uberleitung

\begin{lemma}[Koinzidenzlemma f\"ur \Lot] \label{lemma:Lot:Koinzidenzlemma} \
  \begin{enumerate}
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, e \in \setExp, \tau \in \setType:\,
           \Tj{\Gamma_1}{e}{\tau}\,\wedge\,\Gamma_1 =_{\free{e}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{e}{\tau}$
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, r \in \setRow, \phi \in \setRType:\,
           \Tj{\Gamma_1}{r}{\phi}\,\wedge\,\Gamma_1 =_{\free{r}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{r}{\phi}$
  \end{enumerate}
\end{lemma}
%
In Worten ausgedr\"uckt besagt das Lemma lediglich, dass Typumgebungen, die auf
den frei vorkommenden Namen eines Ausdrucks oder einer Reihe \"ubereinstimmen, bez\"uglich
der Typurteile \"uber diesen Ausdr\"ucke oder Reihen austauschbar sind.

\begin{beweis}
  Erfolgt durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{\Gamma_1}{e}{\tau}$ und $\Tj{\Gamma_1}{r}{\phi}$ und Fallunterscheidung nach
  der zuletzt angewandten Typregel. Dazu betrachten wir exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item $\Tj{\Gamma_1}{c}{\tau}$ mit Typregel \RN{Const} kann nur aus $\tj{c}{\tau}$ folgen.
          Dann gilt aber ebenfalls $\Tj{\Gamma_2}{c}{\tau}$.

    \item $\Tj{\Gamma_1}{\id}{\tau}$ mit Typregel \RN{Id} kann ausschliesslich aus $\id\in\dom{\Gamma_1}$
          und $\Gamma_1(\id)=\tau$ folgen. Da $\free{\id}=\{\id\}$ gilt nach
          Definition~\ref{definition:Lot:Uebereinstimmung_von_Typumgebungen} aber ebenfalls
          $\id\in\dom{\Gamma_2}$ und $\Gamma_2(\id)=\Gamma_1(\id)=\tau$. Also folgt mit
          Typregel \RN{Id} $\Tj{\Gamma_2}{\id}{\tau}$.

    \item $\Tj{\Gamma_1}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} kann nur aus
          Pr\"amissen der Form $\Tj{\Gamma_1}{e_1}{\typeArrow{\tau'}{\tau}}$ und $\Tj{\Gamma_1}{e_2}{\tau'}$
          folgen. Wegen Lemma~\ref{lemma:Lot:Uebereinstimmung_von_Typumgebungen} gilt nach
          Induktionsvoraussetzung $\Tj{\Gamma_2}{e_1}{\typeArrow{\tau'}{\tau}}$ und $\Tj{\Gamma_2}{e_2}{\tau'}$,
          also $\Tj{\Gamma_2}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App}.

    \item $\Tj{\Gamma_1}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object} kann nur
          aus $\Tj{\Gamma_1^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$ folgen.
          Wegen Lemma~\ref{lemma:Lot:Uebereinstimmung_von_Typumgebungen} folgt mit Induktionsvoraussetzung
          $\Tj{\Gamma_2^\star\SUB{\tau}{\self}}{r}{\phi}$, und mit Typregel \RN{Object} folgt daraus
          $\Tj{\Gamma_2}{\expObject{\self:\tau}{r}}{\tau}$.

    \item $\Tj{\Gamma_1}{\expDupl{{a_i=e_i}^{i=1 \ldots n}}}{\tau}$ mit Typregel \RN{Dupl} kann nur
          aus $\Tj{\Gamma_1}{\self}{\tau}$ und $\Tj{\Gamma_1}{a_i}{\tau_i}\,\wedge\,\Tj{\Gamma_1}{e_i}{\tau_i}$
          f\"ur $i=1,\ldots,n$ folgen. Mit Lemma~\ref{lemma:Lot:Uebereinstimmung_von_Typumgebungen} gilt nach
          Induktionsvoraussetzung $\Tj{\Gamma_2}{\self}{\tau}$ und
          $\Tj{\Gamma_2}{a_i}{\tau_i}\,\wedge\,\Tj{\Gamma_2}{e_i}{\tau_i}$ f\"ur alle $i=1,\ldots,n$. Also
          folgt mit Typregel \RN{Dupl} $\Tj{\Gamma_2}{\expDupl{{a_i=e_i}^{i=1 \ldots n}}}{\tau}$.

    \item F\"ur $\Tj{\Gamma_1}{\rowMethod{m}{e}{r}}{(\rtypeMethod{m}{\tau}{\rtypeEmpty}) \oplus \phi}$ mit
          Typregel \RN{Method} gilt nach Voraussetzung $\Tj{\Gamma_1}{e}{\tau}$ und $\Tj{\Gamma_1}{r}{\phi}$.
          Wegen Induktionsvoraussetzung folgt somit $\Tj{\Gamma_2}{e}{\tau}$ und
          $\Tj{\Gamma_2}{r}{\phi}$, und mit Typregel \RN{Method} schliesslich die Behauptung.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

\begin{korollar} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv, e\in\setExp, \tau\in\setType:\,
           \Tj{\Gamma^\star}{e}{\tau}\,\Rightarrow\,\Tj{\Gamma}{e}{\tau}$.
    \item $\forall \Gamma\in\setTEnv, r\in\setRow, \phi\in\setRType:\,
           \Tj{\Gamma^\star}{r}{\phi}\,\Rightarrow\,\Tj{\Gamma}{r}{\phi}$.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt mit Lemma~\ref{lemma:Lot:free_und_dom_Gamma} unmittelbar aus
  Lemma~\ref{lemma:Lot:Koinzidenzlemma}.
\end{beweis}

{\bf TODO:} \"Uberleitung

\begin{lemma}[Typurteile und Substitution] \label{lemma:Lot:Typurteile_und_Substitution}
  Sei $\id \in \setAttribute \cup \setVar$, $\Gamma \in \setTEnv$, $\tau \in \setType$
  und $e \in \setExp$. Dann gilt:
  \begin{enumerate}
    \item $\forall e' \in \setExp:
           \forall \tau' \in \setType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$
    \item $\forall r \in \setRow:
           \forall \phi \in \setRType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{r\SUB{e}{\id}}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Zun\"achst ist festzuhalten, dass verm\"oge Lemma~\ref{lemma:Lot:free_und_dom_Gamma} die
  Substitution $e'\SUB{e}{\id}$ bzw. $r\SUB{e}{\id}$ stets definiert ist. Damit k\"onnen
  wir dann den Beweis durch simultane Induktion \"uber die L\"ange der Herleitung der
  Typurteile $\Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi}$
  und Fallunterscheidung nach der zuletzt angewandten Typregel f\"uhren. Wir betrachten
  dazu die folgenden F\"alle.
  \PROOFCASEbeg
    \item $\Tj{\Gamma\SUB{\tau}{\id}}{c}{\tau'}$ mit Typregel \RN{Const}.

          Nach Voraussetzung gilt $\tj{c}{\tau'}$ und wegen Definition~\ref{definition:Lo:Substitution}
          ist $c = c\SUB{e}{\id}$. Also folgt $\Tj{\Gamma}{c\SUB{e}{\id}}{\tau'}$ mit Typregel \RN{Const}.

    \item $\Tj{\Gamma\SUB{\tau}{\id}}{\id'}{\tau'}$ mit Typregel \RN{Id}.

          Nach Voraussetzung gilt $\id' \in \dom{\Gamma}$ und $\Gamma(\id') = \tau'$.

          F\"ur $\id = \id'$ gilt nach Definition~\ref{definition:Lot:Typumgebungen} $\tau = \tau'$. Wegen
          Definition~\ref{definition:Lo:Substitution} ist $\id'\SUB{e}{\id}$ = $e$ und aus
          $\free{e} \subseteq \dom{\Gamma^\star} \subseteq \dom{\Gamma}$ folgt mit
          Lemma~\ref{lemma:Lot:Koinzidenzlemma} $\Tj{\Gamma}{\id'\SUB{e}{\id}}{\tau'}$.

          F\"ur $\id \ne \id'$ ist wegen Definition~\ref{definition:Lo:Substitution} $\id'\SUB{e}{\id} = \id'$
          und wegen Definition~\ref{definition:Lot:Typumgebungen} folgt $\Tj{\Gamma}{\id'\SUB{e}{\id}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\id}}{\expApp{e_1}{e_2}}{\tau'}$ mit Typregel \RN{App}.

          Dann gilt nach Voraussetzung $\Tj{\Gamma\SUB{\tau}{\id}}{e_1}{\typeArrow{\tau''}{\tau'}}$ und
          $\Tj{\Gamma\SUB{\tau}{\id}}{e_2}{\tau''}$. Mit Induktionsvoraussetzung folgt
          $\Tj{\Gamma}{e_1\SUB{e}{\id}}{\typeArrow{\tau''}{\tau'}}$ und $\Tj{\Gamma}{e_2\SUB{e}{\id}}{\tau''}$,
          mit Typregel \RN{App} also $\Tj{\Gamma}{\expApp{e_1\SUB{e}{\id}}{e_2\SUB{e}{\id}}}{\tau'}$ und
          wegen Definition~\ref{definition:Lo:Substitution} folgt schliesslich
          $\Tj{\Gamma}{(\expApp{e_1}{e_2})\SUB{e}{\id}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\id}}{\expAbstr{x:\tau'}{e'}}{\typeArrow{\tau'}{\tau''}}$ mit Typregel \RN{Abstr}.

          Dann gilt $\Tj{\Gamma\SUB{\tau}{\id}\SUB{\tau'}{x}}{e'}{\tau''}$ und durch gebundene Umbenennung
          l\"asst sich die Voraussetzung $x \not\in \{\id\} \cup \free{e}$ f\"ur die Substitution herstellen.
          Wegen $x \ne \id$ folgt $\Tj{\Gamma\SUB{\tau'}{x}\SUB{\tau}{\id}}{e'}{\tau''}$ und nach
          Induktionsvoraussetzung gilt dann $\Tj{\Gamma\SUB{\tau'}{x}}{e'\SUB{e}{\id}}{\tau''}$. Mit Typregel
          \RN{Abstr} folgt daraus $\Tj{\Gamma}{\expAbstr{x:\tau'}{e'\SUB{e}{\id}}}{\typeArrow{\tau'}{\tau''}}$
          und wegen $\id \not\in \{\id\}\cup\free{e}$ mit Definition~\ref{definition:Lo:Substitution} schliesslich
          $\Tj{\Gamma}{(\expAbstr{x:\tau'}{e'})\SUB{e}{\id}}{\typeArrow{\tau'}{\tau''}}$.

    \item $\Tj{\Gamma\SUB{\tau}{\id}}{\rowVal{a}{e'}{r}}{\phi}$ mit Typregel \RN{Attr}.

          Nach Voraussetzung gilt $\Tj{(\Gamma\SUB{\tau}{\id})^\star}{e'}{\tau'}$ und
          $\Tj{\Gamma\SUB{\tau}{\id}\SUB{\tau'}{a}}{r}{\phi}$.

          F\"ur $\id \in \setVar$ gilt insbesondere $\Tj{\Gamma^\star\SUB{\tau}{\id}}{e'}{\tau'}$, nach
          Induktionsvoraussetzung also $\Tj{\Gamma^\star}{e'\SUB{e}{\id}}{\tau'}$. Gilt andererseits
          $\id \not\in \setVar$ folgt daraus $\Tj{\Gamma^\star}{e'}{\tau'}$, und da $\id \not\in \dom{\Gamma^\star}$
          muss nach Lemma~\ref{lemma:Lot:free_und_dom_Gamma} ebenfalls $\id \not\in \free{e'}$ gelten,
          somit also $e' = e'\SUB{e}{\id}$ nach Lemma~\ref{lemma:Lo:Substitution_und_free}.

          F\"ur $\id = a$ gilt dann $\Tj{\Gamma\SUB{\tau'}{a}}{r}{\phi}$, also
          $\Tj{\Gamma}{\rowVal{a}{e'\SUB{e}{\id}}{r}}{\phi}$ wegen Typregel \RN{Attr}, und mit
          Definition~\ref{definition:Lo:Substitution} folgt schliesslich
          $\Tj{\Gamma}{(\rowVal{a}{e'}{r})\SUB{e}{\id}}{\phi}$.

          F\"ur $\id \ne a$ andererseits gilt $\Tj{\Gamma\SUB{\tau'}{a}\SUB{\tau}{\id}}{r}{\phi}$ und
          nach Induktionsvoraussetzung $\Tj{\Gamma\SUB{\tau'}{a}}{r\SUB{e}{\id}}{\phi}$. Mit Typregel
          \RN{Attr} somit $\Tj{\Gamma}{\rowVal{a}{e'\SUB{e}{\id}}{r\SUB{e}{\id}}}{\phi}$ und wegen
          Definition~\ref{definition:Lo:Substitution} gilt dann $\Tj{\Gamma}{(\rowVal{a}{e'}{r})\SUB{e}{\id}}{\phi}$.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

{\bf TODO:} \"Uberleitung, das folgende Lemma braucht man zum Beweis der Typerhaltung von $\self$-Substitution

\begin{lemma}[Typurteile und Reiheneinsetzung] \label{lemma:Lot:Typurteile_und_Reiheneinsetzung}
  Sei $\Gamma\in\setTEnv$, $r\in\setRow$, \linebreak[4] $\phi\in\setRType$, $a\in\setAttribute$, $\tau\in\setType$
  und $e\in\setExp$. Dann gilt:
  \[
    \Tj{\Gamma}{r}{\phi}\,\wedge\,\Tj{\Gamma^\star}{r(a)}{\tau}\,\wedge\,\Tj{\Gamma^\star}{e}{\tau}
    \ \Rightarrow\ 
    \Tj{\Gamma}{r\RINS{e}{a}}{\phi}
  \]
\end{lemma}

\begin{beweis}
  Wegen $\Tj{\Gamma^\star}{e}{\tau}$ ist nach Lemma~\ref{lemma:Lot:free_und_dom_Gamma} $e\in\setExp^\star$,
  und wegen $\Tj{\Gamma^\star}{r(a)}{\tau}$ ist $a\in\doma{r}$. Also ist die Reiheneinsetzung
  $r\RINS{e}{a}$ gem\"ass den Voraussetzungen stets definiert.  Damit k\"onnen wir dann den Beweis mittels
  Induktion \"uber die Gr\"osse von $r$ und Fallunterscheidung nach der syntaktischen Form von $r$ f\"uhren.
  \PROOFCASEbeg
    \item F\"ur die leere Reihe $\rowEpsilon$ ist $a\not\in\doma{\rowEpsilon}=\emptyset$ und somit
          kann $\Tj{\Gamma^\star}{\rowEpsilon(a)}{\tau}$ nicht gelten.

    \item $\Tj{\Gamma}{\rowVal{a'}{e'}{r'}}{\phi}$ kann nur mit Typregel \RN{Attr} aus
          $\Tj{\Gamma^\star}{e'}{\tau'}$ und $\Tj{\Gamma\SUB{\tau'}{a'}}{r'}{\phi}$ folgen. Es
          sind zwei F\"alle zu unterscheiden.

          F\"ur $a = a'$ gilt $(\rowVal{a'}{e'}{r'})(a) = e'$ und somit $\tau = \tau'$. Mit Typregel
          \RN{Attr} folgt daraus $\Tj{\Gamma}{\rowVal{a'}{e}{r'}}{\phi}$ und gem\"ass
          Definition~\ref{definition:Lo:Reiheneinsetzung} also $\Tj{\Gamma}{(\rowVal{a'}{e'}{r'})\RINS{e}{a}}{\phi}$.

          F\"ur $a \ne a'$ ist $(\rowVal{a'}{e'}{r'})\RINS{e}{a} = \rowVal{a'}{e'}{r'\RINS{e}{a}}$ und
          $(\rowVal{a'}{e'}{r'})(a) = r'(a)$. Wegen $(\Gamma\SUB{\tau'}{a'})^\star = \Gamma^\star$ folgt
          nach Induktionsvoraussetzung $\tj{\Gamma\SUB{\tau'}{a'}}{r'\RINS{e}{a}}{\phi}$, mit Typregel
          \RN{Attr} also $\Tj{\Gamma}{\rowVal{a'}{e'}{r'\RINS{e}{a}}}{\phi}$ und mit
          Definition~\ref{definition:Lo:Reiheneinsetzung} schliesslich
          $\Tj{\Gamma}{(\rowVal{a'}{e'}{r'})\RINS{e}{a}}{\phi}$.

    \item $\Tj{\Gamma}{\rowMethod{m}{e'}{r'}}{(\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi}$ kann nur mit
          Typregel \RN{Method} aus Pr\"amissen der Form $\Tj{\Gamma}{e'}{\tau'}$ und $\Tj{\Gamma}{r'}{\phi}$ folgen.
          Nach Definition~\ref{definition:Lo:Reiheneinsetzung} ist
          $(\rowMethod{m}{e'}{r'})\RINS{e}{a} = \rowMethod{m}{e'}{r'\RINS{e}{a}}$
          und mit Induktionsvoraussetzung folgt $\Tj{\Gamma}{r'\RINS{e}{a}}{\phi}$. Wegen Typregel \RN{Method} gilt also
          $\Tj{\Gamma}{\rowMethod{m}{e'}{r'\RINS{e}{a}}}{(\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi}$
          und somit gem\"a"s Definition~\ref{definition:Lo:Reiheneinsetzung}
          $\Tj{\Gamma}{(\rowMethod{m}{e'}{r'})\RINS{e}{a}}{(\rtypeMethod{m}{\tau'}{\rtypeEmpty})\oplus\phi}$.
  \PROOFCASEend
\end{beweis}
%
Weiterhin brauchen wir f\"ur den Beweis des Preservation-Theorems noch das nachfolgende Lemma, welches die Typerhaltung
f\"ur die $\self$-Substitution sichert, da dieser Fall noch nicht durch das allgemeine Lemma \"uber Typurteile
und Substitution (\ref{lemma:Lot:Typurteile_und_Substitution}) abgedeckt wird.

\begin{lemma}[Typurteile und $\self$-Substitution] \label{lemma:Lot:Typurteile_und_self_Substitution}
  Sei $\Gamma \in \setTEnv$, $\self\in\setSelf$,\linebreak[4] $\tau\in\setType$ und $r\in\setRow$. Dann gilt:
  \renewcommand{\labelenumii}{(\arabic{enumii})}
  \begin{enumerate}
    \item F\"ur alle $e\in\setExp$ und $\tau'\in\setType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          \end{enumerate}

    \item F\"ur alle $r'\in\setRow$ und $\phi\in\setRType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r \oplus r'}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{r'\SUB{\expObject{\self:\tau}{r \oplus r'}}{\self}}{\phi}$
          \end{enumerate}
  \end{enumerate}
  \renewcommand{\labelenumii}{\arabic{enumii}.}
\end{lemma}

\begin{beweis}
  Wegen Lemma~\ref{lemma:Lot:free_und_dom_Gamma} gilt, dass die Substitution stets definiert ist. Den
  Beweis f\"uhren wir dann durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$, und Fallunterscheidung
  nach der zuletzt angewandten Typregel. Dazu betrachten wir exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item $\Tj{\Gamma\SUB{\tau}{\self}}{c}{\tau'}$ mit \RN{Const}.

          Wegen $\free{c} = \emptyset$ gilt nach Lemma~\ref{lemma:Lot:Koinzidenzlemma}
          $\Tj{\Gamma}{c}{\tau'}$ und wegen Definition~\ref{definition:Lo:Substitution} ist
          $c = c\SUB{\expObject{\self:\tau}{r}}{\self}$, also gilt
          $\Tj{\Gamma}{c\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\id}{\tau'}$ mit \RN{Id}.

          Nach Voraussetzung gilt $\id\in\dom{\Gamma\SUB{\tau}{\self}}$ und $\Gamma\SUB{\tau}{\self}(\id) = \tau'$.
          Dann sind zwei F\"alle zu unterscheiden.

          F\"ur $\id = \self$ ist $\id\SUB{\expObject{\self:\tau}{r}}{\self} = \expObject{\self:\tau}{r}$ und
          $\tau = \tau'$. \linebreak[4] Also gilt $\Tj{\Gamma^\star}{\id\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          und wegen Lemma~\ref{lemma:Lot:Koinzidenzlemma} ebenfalls \linebreak[4]
          $\Tj{\Gamma}{\id\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$.

          F\"ur $\id \ne \self$ ist $\id\SUB{\expObject{\self:\tau}{r}}{\self} = \id$ und insbesondere
          $\self\not\in\free{\id}$. Es folgt unmittelbar $\Tj{\Gamma}{\id\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\expApp{e_1}{e_2}}{\tau'}$ mit \RN{App}.

          Nach Voraussetzung gilt $\Tj{\Gamma\SUB{\tau}{\self}}{e_1}{\typeArrow{\tau''}{\tau'}}$ und
          $\Tj{\Gamma\SUB{\tau}{\self}}{e_2}{\tau''}$, und mit Induktionsvoraussetzung folgt
          $\Tj{\Gamma}{e_1\SUB{\expObject{\self:\tau}{r}}{\self}}{\typeArrow{\tau''}{\tau'}}$ und
          $\Tj{\Gamma}{e_2\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau''}$. Mit Typregel \RN{App} und
          Definition~\ref{definition:Lo:Substitution} folgt daraus
          $\Tj{\Gamma}{(\expApp{e_1}{e_2})\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\expDupl{{a_i=e_i}^{i=1 \ldots n}}}{\tau'}$ mit \RN{Dupl}.

          Wir schreiben $\tilde{o}$ f\"ur $\expObject{\self:\tau}{r}$. Nach Voraussetzung gilt dann\linebreak[4]
          $\Tj{\Gamma\SUB{\tau}{\self}}{\self}{\tau'}$, also $\tau = \tau'$, sowie
          $\Tj{\Gamma\SUB{\tau}{\self}}{a_i}{\tau_i}$ und $\Tj{\Gamma\SUB{\tau}{\self}}{e_i}{\tau_i}$
          f\"ur $i=1,\ldots,n$. $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$ andererseits kann
          nur mit Typregel \RN{Object} aus Pr\"amissen der Form
          $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$ folgen.

          Dann gilt $\Tj{\Gamma}{e_i\SUB{\tilde{o}}{\self}}{\tau_i}$ nach Induktionsvoraussetzung
          f\"ur alle $i=1,\ldots,n$.

          Seien nun $x_1,\ldots,x_n\not\in\free{r}\cup\bigcup_{i=1}^n\free{e_i}$. Dann folgt mit $n$-facher
          Anwendung von Lemma~\ref{lemma:Lot:Typurteile_und_Reiheneinsetzung} aus
          $\Tj{\Gamma^\star\SUB{\tau}{\self}\SUB{\vec{\tau}}{\vec{x}}}{x_i}{\tau_i}$ und
          $\Tj{\Gamma^\star\SUB{\vec{\tau}}{\vec{x}}}{a_i}{\tau_i}$ f\"ur alle $i=1,\ldots,n$, sowie
          $\Tj{\Gamma^\star\SUB{\tau}{\self}\SUB{\vec{\tau}}{\vec{x}}}{r}{\phi}$, dass
          $\Tj{\Gamma^\star\SUB{\tau}{\self}\SUB{\vec{\tau}}{\vec{x}}}{r\RINS{x_i}{a_i}^{i=1 \ldots n}}{\phi}$ gilt.

          Wegen $\setSelf \cap \setAttribute = \emptyset$,
          $\Gamma^\star\SUB{\vec{\tau}}{\vec{x}} = (\Gamma\SUB{\vec{\tau}}{\vec{x}})^\star$ und
          $\tau = \typeObject{\phi}$ folgt dann mit Typregel \RN{Object}
          $\Tj{\Gamma\SUB{\vec{\tau}}{\vec{x}}}{\expObject{\self:\tau}{r\RINS{x_i}{a_i}^{i=1 \ldots n}}}{\tau}$,
          also mit Typregel \RN{Let}
          $\Tj{\Gamma}{\expLet{\vec{x}}{\vec{e}\SUB{\tilde{o}}{\self}}
                              {\expObject{\self:\tau}{r\RINS{x_i}{a_i}^{i=1 \ldots n}}}}{\tau}$.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\rowVal{a}{e}{r'}}{\phi}$ mit \RN{Attr}.

          Wir schreiben $\tilde{o}$ f\"ur $\expObject{\self:\tau}{r\oplus\rowVal{a}{e}{r'}}$. Nach Voraussetzung
          gilt $\Tj{\Gamma^\star}{e}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\self}\SUB{\tau'}{a}}{r'}{\phi}$,
          da $(\Gamma\SUB{\tau}{\self})^\star = \Gamma^\star$.

          Wegen $\self \not\in\dom{\Gamma^\star}$ folgt nach Lemma~\ref{lemma:Lot:free_und_dom_Gamma}
          $\self\not\in\free{e}$ und mit Lemma~\ref{lemma:Lo:Substitution_und_free} also
          $e = e\SUB{\tilde{o}}{\self}$.

          Desweiteren folgt $(r\oplus\rowVal{a}{e}{r'})(a) = e$ wegen $a\not\in\doma{r}\cup\doma{r'}$,
          also $\Tj{\Gamma}{(r\oplus\rowVal{a}{e}{r'})(a)}{\tau'}$ und wegen $\setSelf\cap\setAttribute=\emptyset$
          gilt $\Tj{\Gamma\SUB{\tau'}{a}\SUB{\tau}{\self}}{r'}{\phi}$. Nach Induktionsvoraussetzung gilt
          dann $\Tj{\Gamma\SUB{\tau'}{a}}{r'\SUB{\tilde{o}}{\self}}{\phi}$.

          Mit Typregel \RN{Attr} folgt daraus
          $\Tj{\Gamma}{\rowVal{a}{e\SUB{\tilde{o}}{\self}}{r'\SUB{\tilde{o}}{\self}}}{\phi}$,
          also nach Definition~\ref{definition:Lo:Substitution}
          $\Tj{\Gamma}{(\rowVal{a}{e}{r'})\SUB{\tilde{o}}{\self}}{\phi}$.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\rowMethod{m}{e}{r'}}{\phi\oplus(\rtypeMethod{m}{\tau'}{\rtypeEmpty})}$
          mit \RN{Method}.

          Wir schreiben $\tilde{o}$ f\"ur $\expObject{\self:\tau}{r\oplus\rowMethod{m}{e}{r'}}$. Nach Voraussetzung
          gilt $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$. Mit
          Induktionsvoraussetzung folgt daraus $\Tj{\Gamma}{e\SUB{\tilde{o}}{\self}}{\tau'}$ und
          $\Tj{\Gamma}{r'\SUB{\tilde{o}}{\self}}{\phi}$. Wegen Typregel \RN{Method} gilt also
          $\Tj{\Gamma}{\rowMethod{m}{e\SUB{\tilde{o}}{\self}}{r'\SUB{\tilde{o}}{\self}}}
              {\phi\oplus(\rtypeMethod{m}{\tau'}{\rtypeEmpty})}$, und nach Definition~\ref{definition:Lo:Substitution}
          $\Tj{\Gamma}{(\rowMethod{m}{e}{r'})\SUB{\tilde{o}}{\self}}{\phi\oplus(\rtypeMethod{m}{\tau'}{\rtypeEmpty})}$.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen \"ahnlich.
\end{beweis}

Nach diesen Vorbereitungen k\"onnen wir nun daran gehen das {\em Preservation-Theorem} zu formulieren
und beweisen, welches uns die erste wichtige Eigenschaft f\"ur die Typsicherheit der Programmiersprache
\Lot\ liefert: Die Wohlgetyptheit und der Typ eines Ausdrucks oder einer Reihe bleibt \"uber small steps
hinweg erhalten. Anders ausgedr\"uckt, wenn sich f\"ur einen Ausdruck $e$ in einer Typumgebung $\Gamma$
der Typ $\tau$ herleiten l\"a"st, und f\"ur diesen Ausdruck existiert ein small step $e \to e'$, dann
l\"a"st sich auch f\"ur $e'$ in der Typumgebung $\Gamma$ der Typ $\tau$ herleiten.

\begin{satz}[Typerhaltung, "`Preservation"'] \label{satz:Lot:Preservation} \index{Typsicherheit!Preservation} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv:\forall e,e'\in\setExp:\forall \tau\in\setType:\,
           \Tj{\Gamma^\star}{e}{\tau}\,\wedge\,e \to e'\ \Rightarrow\ \Tj{\Gamma^\star}{e'}{\tau}$
    \item $\forall \Gamma\in\setTEnv:\forall r,r'\in\setRow:\forall \phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\wedge\,r \to r'\ \Rightarrow\ \Tj{\Gamma}{r'}{\phi}$
  \end{enumerate}
\end{satz}
%
Wir w\"ahlen $\Gamma^\star$ statt $\Gamma$, da die Substitution nur definiert ist, wenn
$e \in \setExp^\star$, also $\Tj{\Gamma^\star}{e}{\tau}$. F\"ur \RN{Send-Unfold} und \RN{Send-Attr}
wird dies bereits durch die entsprechenden Typregeln sichergestellt. Aber f\"ur \RN{Let-Exec},
\RN{Beta-V} und \RN{Unfold} w\"are das Preservation-Theorem andernfalls nicht zu beweisen.
Dies entspricht der \"ublichen Vorgehensweise beliebige freie Variablen im Ausdruck zuzulassen
(vgl. \cite[S.~7]{Remy98}, \cite[S.~106]{Pierce02}).

\begin{beweis}
  Der Beweis erfolgt durch simultane Induktion \"uber die L\"ange der Herleitung der small steps
  $e \to e'$ und $r \to r'$, und Fallunterscheidung nach der zuletzt angewandten small step
  Regel. Wir betrachten dazu exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item $\expApp{\expApp{\op}{n_1}}{n_2} \to \op^I(n_1,n_2)$ mit \RN{Op}.

          Dann ist zu unterscheiden zwischen arithmetischen und relationalen Operatoren. Sei also
          $\op \in \{+,-,*\}$, dann gilt nach Voraussetzung $\Tj{\Gamma^\star}{\expApp{\expApp{\op}{n_1}}{n_2}}{\typeInt}$
          und insbesondere $\tj{\op}{\typeIntIntInt}$ wegen \RN{Aop}. Folglich ist $\op^I(n_1,n_2)\in\setInt$,
          und es gilt $\Tj{\Gamma^\star}{\op^I(n_1,n_2)}{\typeInt}$.

          Sei andererseits $\op\in\{<,>,\le,\ge,=\}$. Nach Voraussetzung gilt
          $\Tj{\Gamma^\star}{\expApp{\expApp{\op}{n_1}}{n_2}}{\typeBool}$ und insbesondere
          $\tj{\op}{\typeIntIntBool}$ wegen \RN{Rop}. Dann muss also gelten $\op^I(n_1,n_2)\in\setBool$
          und somit $\Tj{\Gamma^\star}{\op^I(n_1,n_2)}{\typeBool}$.

    \item $\expApp{(\expAbstr{x:\tau}{e})}{v} \to e\SUB{v}{x}$ mit \RN{Beta-V}.

          $\Tj{\Gamma^\star}{\expApp{(\expAbstr{x:\tau}{e})}{v}}{\tau'}$ kann nur mit Typregel \RN{App} aus
          Pr\"amissen der Form $\Tj{\Gamma^\star}{v}{\tau}$ und
          $\Tj{\Gamma^\star}{\expAbstr{x:\tau}{e}}{\typeArrow{\tau}{\tau'}}$
          folgen. Letzteres kann wiederum nur mit Typregel \RN{Abstr} aus
          $\Tj{\Gamma^\star\SUB{\tau}{x}}{e}{\tau'}$ folgen. Mit Lemma~\ref{lemma:Lot:Typurteile_und_Substitution}
          folgt daraus $\Tj{\Gamma^\star}{e\SUB{v}{x}}{\tau'}$.

    \item $\expApp{e_1}{e_2} \to \expApp{e_1'}{e_2}$ mit \RN{App-Left} aus $e_1 \to e_1'$.

          $\Tj{\Gamma^\star}{\expApp{e_1}{e_2}}{\tau}$ kann nur mit Typregel \RN{App} aus $\Tj{\Gamma^\star}{e_2}{\tau'}$
          und $\Tj{\Gamma^\star}{e_1}{\typeArrow{\tau'}{\tau}}$ folgen. Nach Induktionsvoraussetzung gilt 
          $\Tj{\Gamma^\star}{e_1'}{\typeArrow{\tau'}{\tau}}$ und mit Typregel \RN{App} folgt dann
          $\Tj{\Gamma^\star}{\expApp{e_1'}{e_2}}{\tau}$.

    \item $\expObject{\self:\tau}{r} \to \expObject{\self:\tau}{r'}$ mit \RN{Object-Eval} aus $r \to r'$.

          $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$ kann nur mit Typregel \RN{Object} aus Pr\"amissen
          der Form $\Tj{(\Gamma^\star)^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$ folgen.
          Nach Induktionsvoraussetzung gilt dann $\Tj{(\Gamma^\star)^\star\SUB{\tau}{\self}}{r'}{\phi}$ und
          mit Typregel \RN{Object} folgt $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r'}}{\tau}$.

    \item $\rowVal{a}{e}{r} \to \rowVal{a}{e'}{r}$ mit \RN{Attr-Eval} aus $e \to e'$.

          $\Tj{\Gamma}{\rowVal{a}{e}{r}}{\phi}$ kann nur mit Typregel \RN{Attr} aus Pr\"amissen der Form
          $\Tj{\Gamma^\star}{e}{\tau}$ und $\Tj{\Gamma\SUB{\tau}{a}}{r}{\phi}$ folgen. Nach Induktionsvoraussetzung
          gilt also $\Tj{\Gamma^\star}{e'}{\tau}$, und somit wegen \RN{Attr}
          $\Tj{\Gamma}{\rowVal{a}{e'}{r}}{\phi}$.

    \item $\expSend{\expObject{\self:\tau}{\omega}}{m} \to
           \expSend{\omega\SUB{\expObject{\self:\tau}{\omega}}{\self}}{m}$ mit \RN{Send-Unfold}.

          $\Tj{\Gamma^\star}{\expSend{\expObject{\self:\tau}{\omega}}{m}}{\tau'}$ kann nur mit Typregel \RN{Send}
          folgen aus
          $\Tj{\Gamma^\star}{\expObject{\self:\tau}{\omega}}{\typeObject{\rtypeMethod{m}{\tau'}{\phi}}}$, was
          wiederum nur
          mit Typregel \RN{Object} aus $\Tj{(\Gamma^\star)^\star\SUB{\tau}{\self}}{\omega}{(\rtypeMethod{m}{\tau'}{\phi})}$
          folgen kann. Wegen $\dom{\Gamma^\star} \cap \setAttribute = \emptyset$ gilt
          $\Tj{\Gamma^\star}{\omega\SUB{\expObject{\self:\tau}{\omega}}{\self}}{(\rtypeMethod{m}{\tau'}{\phi})}$
          nach Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution}.
          Hieraus wiederum folgt $\Tj{\Gamma^\star}{\expSend{\omega\SUB{\expObject{\self:\tau}{\omega}}{\self}}{m}}{\tau'}$
          mit Typregel \RN{Send'}.

    \item $\expSend{(\rowVal{a}{v}{\omega})}{m} \to \expSend{\omega\SUB{v}{a}}{m}$ mit \RN{Send-Attr}.

          $\Tj{\Gamma^\star}{\expSend{(\rowVal{a}{v}{\omega})}{m}}{\tau}$ kann ausschliesslich mit Typregel \RN{Send'}
          aus $\Tj{\Gamma^\star}{\rowVal{a}{v}{\omega}}{(\rtypeMethod{m}{\tau}{\phi})}$ folgen. Dies wiederum
          kann nur mit Typregel \RN{Attr} aus Pr\"amissen der Form $\Tj{(\Gamma^\star)^\star}{v}{\tau'}$ und
          $\Tj{\Gamma^\star\SUB{\tau'}{a}}{\omega}{(\rtypeMethod{m}{\tau}{\phi})}$ folgen. Wegen 
          Lemma~\ref{lemma:Lot:Typurteile_und_Substitution} gilt dann
          $\Tj{\Gamma^\star}{\omega\SUB{v}{a}}{(\rtypeMethod{m}{\tau}{\phi})}$ und mit Typregel \RN{Send'} folgt
          schliesslich $\Tj{\Gamma^\star}{\expSend{\omega\SUB{v}{a}}{m}}{\tau}$.

    \item $\expSend{(\rowMethod{m}{e}{\omega})}{m} \to e$ mit \RN{Send-Exec}.

          $\Tj{\Gamma^\star}{\expSend{(\rowMethod{m}{e}{\omega})}{m}}{\tau}$ kann wieder nur mit Typregel \RN{Send'}
          aus $\Tj{\Gamma^\star}{\rowMethod{m}{e}{\omega}}{(\rtypeMethod{m}{\tau}{\rtypeEmpty})\oplus\phi}$ folgen. Dies
          kann nur mit Typregel \RN{Method} aus Pr\"amissen der Form $\Tj{\Gamma^\star}{e}{\tau}$ und
          $\Tj{\Gamma^\star}{\omega}{\phi}$ folgen. Die erste Pr\"amisse sichert somit die Typerhaltung.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

\begin{korollar}
  $\forall e,e'\in\setExp:\forall \tau\in\setType:\,
   \Tj{[\,]}{e}{\tau}\,\wedge\,e \to e'\ \Rightarrow\ \Tj{[\,]}{e'}{\tau}$
\end{korollar}

\begin{beweis}
  Folgt unmittelbar aus Satz~\ref{satz:Lot:Preservation}.
\end{beweis}

{\bf TODO:} \"Uberleitung, wir beschr\"anken uns hierbei auf die interessanten Aussagen,
die wir im Beweis des Progress-Theorems benutzen werden.

\begin{lemma}[Canonical Forms] \label{lemma:Lot:Canonical_Forms} \
  \begin{enumerate}
    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeInt}$ gilt $v\in\setInt$.

    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeArrow{\tau}{\tau'}}$ gilt genau eine
          der folgenden Aussagen:
          \begin{enumerate}
            \item $v \in \setOp$
            \item $v = \expApp{\op}{v_1}$ mit $\op \in \setOp$ und $v_1 \in \setVal$
            \item $v = \expAbstr{x:\tau}{e}$ mit $x\in\setVar$ und $e\in\setExp$.
          \end{enumerate}

    \item F\"ur alle $v\in\setVal$ mit $\Tj{[\,]}{v}{\typeObject{\phi}}$ gilt
          $v = \expObject{\self:\typeObject{\phi}}{\omega}$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Trivial.
\end{beweis}

\begin{satz}[Existenz des \"Ubergangsschritts, "`Progress"'] \label{satz:Lot:Progress} \index{Typsicherheit!Progress} \
  \begin{enumerate}
    \item $\forall e\in\setExp, \tau\in\setType:\, \Tj{[\,]}{e}{\tau}
           \,\Rightarrow\,(e\in\setVal\,\vee\,\exists e'\in\setExp: e \to e')$
    \item $\forall \Gamma\in\setTEnv,r\in\setRow, \phi\in\setRType:\, \Tj{\Gamma^+}{r}{\phi}
           \,\Rightarrow\,(r\in\setRVal\,\vee\,\exists r'\in\setRow: r \to r')$
  \end{enumerate}
\end{satz}
%
In Worten besagt das {\em Progress-Theorem} letztlich, dass f\"ur ein abgeschlossener, wohlgetypter Ausdruck
entweder bereits ein Wert ist, oder f\"ur diesen Ausdruck ein small step existiert. Wegen
Lemma~\ref{lemma:Lo:Werte_und_small_steps} ist auch klar, dass sich diese beiden M\"oglichkeiten
gegenseitig ausschliessen. Entsprechendes gilt f\"ur Reihen, wobei hier allerdings keine Abgeschlossenheit
f\"ur die Reihe gefordert wird, sondern lediglich keine freien Variablen. Im Beweis wird beim Fall
f\"ur die \RN{Object} klar, warum der Satz sonst nicht zu beweisen w\"are.

\begin{beweis}
  Wir f\"uhren den Beweis durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{[\,]}{e}{\tau}$ und $\Tj{\Gamma^+}{r}{\phi}$ und Fallunterscheidung nach der Form von $e$ und $r$.
  Wir betrachten exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur alle Konstanten $c$ gilt $c \in \setVal$.

    \item F\"ur Namen $\id$ existiert kein $\tau$ mit $\Tj{[\,]}{\id}{\tau}$.

    \item F\"ur Abstraktionen $\expAbstr{\id:\tau'}{e'}$ gilt $(\expAbstr{\id:\tau'}{e'}) \in \setVal$.

    \item F\"ur Applikationen $\expApp{e_1}{e_2}$ kann $\Tj{[\,]}{\expApp{e_1}{e_2}}{\tau}$ nur mit
          Typregel \RN{App} aus Pr\"amissen der Form $\Tj{[\,]}{e_1}{\typeArrow{\tau'}{\tau}}$ und
          $\Tj{[\,]}{e_2}{\tau'}$ folgen.

          Wenn $e_1 \not\in \setVal$, dann existiert nach Induktionsvoraussetzung ein $e_1'$ mit
          $e_1 \to e_1'$. Folglich existiert mit Regel \RN{App-Left} ein small step
          $\expApp{e_1}{e_2} \to \expApp{e_1'}{e_2}$.

          Andererseits existiert f\"ur $e_1 \in \setVal, e_2 \not\in \setVal$ nach Induktionsvoraussetzung
          ein $e_2'$ mit $e_2 \to e_2'$, und somit ein small step $\expApp{e_1}{e_2}\to\expApp{e_1}{e_2'}$
          mit Regel \RN{App-Right}.

          Es bleibt der Fall $e_1,e_2\in\setVal$. Wegen $\Tj{[\,]}{e_1}{\typeArrow{\tau'}{\tau}}$ sind
          gem\"a"s Lemma~\ref{lemma:Lot:Canonical_Forms} die folgenden drei F\"alle zu unterscheiden.
          \begin{enumerate}
            \item F\"ur $e_1 \in \setOp$ ist $\expApp{e_1}{e_2} \in \setVal$.

            \item F\"ur $e_1 = \expApp{\op}{v_1}$ ist zun\"achst zu bemerken, dass $\op$ nur vom Typ
                  $\typeIntIntInt$ oder $\typeIntIntBool$ sein kann. Mit dem Canonical Forms Lemma
                  (\ref{lemma:Lot:Canonical_Forms}) folgt aus $\Tj{[\,]}{v_1}{\typeInt}$ und
                  $\Tj{[\,]}{e_2}{\typeInt}$, dass $v_1,e_2\in\setInt$ gilt, und somit existiert ein
                  small step $\expApp{\op}{\expApp{v_1}{e_2}} \to \op^I(v_1,e_2)$ mit Regel \RN{Op}.

            \item F\"ur $e_1 = \expAbstr{x:\tau_2'}{e_1'}$ existiert ein small step
                  $\expApp{(\expAbstr{x:\tau_2'}{e_1'})}{e_2} \to e_1'\SUB{e_2}{x}$ mit Regel \RN{Beta-V},
                  da nach Voraussetzung $e_2 \in\setVal$.
          \end{enumerate}

    \item F\"ur $\expSend{\omega}{m}$ kann $\Tj{[\,]}{\expSend{\omega}{m}}{\tau}$ nur mit
          Typregel \RN{Send'} aus $\Tj{[\,]}{\omega}{(\rtypeMethod{m}{\tau}{\phi})}$ folgen.
          Damit muss gelten $\omega \ne \rowEpsilon$.

          Falls $\omega = (\rowVal{a}{v}{\omega'})$, dann existiert mit Regel \RN{Send-Attr} ein small step
          $\expSend{(\rowVal{a}{v}{\omega'})}{m} \to \expSend{\omega'\SUB{v}{a}}{m}$.

          F\"ur $\omega = (\rowMethod{m'}{e}{\omega'})$ mit $m \ne m' \vee m \in\domm{\omega'}$ existiert
          ein small step $\expSend{(\rowMethod{m'}{e}{\omega'})}{m} \to \expSend{\omega'}{m}$ mit Regel
          \RN{Send-Skip}.

          F\"ur $\omega = (\rowMethod{m}{e}{\omega'})$ mit $m \not\in \domm{\omega'}$ existiert mit Regel
          \RN{Send-Exec} ein small step $\expSend{(\rowMethod{m}{e}{\omega'})}{m} \to e$.

    \item F\"ur Methodenaufrufe $\expSend{e}{m}$ kann $\Tj{[\,]}{\expSend{e}{m}}{\tau'}$ nur mit
          Typregel \RN{Send} aus $\Tj{[\,]}{e}{\tau}$ mit $\tau= \typeObject{\rtypeMethod{m}{\tau'}{\phi}}$ folgen.

          F\"ur $e\not\in\setVal$ existiert nach Induktionsvoraussetzung ein $e'$ mit $e \to e'$, und
          somit ein small step $\expSend{e}{m} \to \expSend{e'}{m}$ mit Regel \RN{Send-Eval}.

          F\"ur $e\in\setVal$ gilt nach Lemma~\ref{lemma:Lot:Canonical_Forms}
          $e = \expObject{\self:\tau}{\omega}$. Somit existiert ein small step
          $\expSend{\expObject{\self:\tau}{\omega}}{m}\to\expSend{\omega\SUB{\expObject{\self:\tau}{\omega}}{\self}}{m}$
          mit Regel \RN{Send-Unfold}.

    \item F\"ur Objekte $\expObject{\self:\tau}{r}$ kann $\Tj{[\,]}{\expObject{\self:\tau}{r}}{\tau}$
          ausschliesslich mit Typregel \RN{Object} aus Pr\"amissen der Form $\Tj{[\self:\tau]}{r}{\phi}$
          und $\tau = \typeObject{\phi}$ folgen.

          Falls $r\not\in\setRVal$, dann existiert nach Induktionsvoraussetzung ein $r'$ mit $r \to r'$.
          Also existiert ein small step $\expObject{\self:\tau}{r} \to \expObject{\self:\tau}{r'}$ mit
          Regel \RN{Object-Eval}.

          Ist andererseits $r\in\setRVal$, dann gilt $(\expObject{\self:\tau}{r}) \in \setVal$.

    \item F\"ur Attributdeklarationen $\rowVal{a}{e}{r}$ kann $\Tj{\Gamma^+}{\rowVal{a}{e}{r}}{\phi}$ nur
          mit Typregel \RN{Attr} aus $\Tj{(\Gamma^+)^\star}{e}{\tau}$ und $\Tj{\Gamma^+\SUB{\tau}{a}}{r}{\phi}$
          folgen.

          F\"ur $e\not\in\setVal$ existiert wegen $(\Gamma^+)^\star = [\,]$ nach Induktionsvoraussetzung ein
          $e'$ mit $e \to e'$. Also existiert ein small step $\rowVal{a}{e}{r} \to \rowVal{a}{e'}{r}$
          mit Regel \RN{Attr-Left}.

          F\"ur $e\in\setVal, r\not\in\setRVal$ existiert nach Induktionsvoraussetzung ein $r'$ mit
          $r \to r'$, und folglich ein small step $\rowVal{a}{e}{r} \to \rowVal{a}{e}{r'}$ mit
          Regel \RN{Attr-Right}.

          Es bleibt der Fall $e\in\setVal, r\in\setRVal$. Dann ist $(\rowVal{a}{e}{r}) \in \setRVal$.

    \item F\"ur Methodendeklarationen $\rowMethod{m}{e}{r}$ kann
          $\Tj{\Gamma^+}{\rowMethod{m}{e}{r}}{(\rtypeMethod{m}{\tau}{\rtypeEmpty})\oplus\phi}$ ausschliesslich mit
          Typregel \RN{Method} aus Pr\"amissen der Form $\Tj{\Gamma^+}{e}{\tau}$ und $\Tj{\Gamma^+}{r}{\phi}$
          folgen.

          Falls $r\not\in\setRVal$, dann existiert nach Induktionsvoraussetzung ein $r'$ mit $r \to r'$,
          also auch ein small step $\rowMethod{m}{e}{r} \to \rowMethod{m}{e}{r'}$ mit Regel \RN{Method-Right}.

          F\"ur $r\in\setRVal$ ist $(\rowMethod{m}{e}{r}) \in \setRVal$.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen analog.
\end{beweis}

{\bf TODO:} \"Uberleitung

\begin{satz}[Typsicherheit, "`Safety"'] \label{satz:Lot:Safety} \index{Typsicherheit!Safety}
  Wenn $\Tj{[\,]}{e}{\tau}$, dann bleibt die Berechnung f\"ur $e$ nicht stecken.
\end{satz}

\begin{beweis}
  Wir f\"uhren den Beweis indirekt. Sei dazu angenommen, die Berechnung f\"ur $e$ bleibe stecken.
  Dann ist die Berechnung von der Form $e = e_0 \to \ldots \to e_n$ mit $e_n \not\to$ und
  $e_n \not\in \setVal$ f\"ur ein $n \ge 0$. Wegen $\Tj{[\,]}{e}{\tau}$ folgt mit
  Satz~\ref{satz:Lot:Preservation} induktiv $\Tj{[\,]}{e_i}{\tau}$ f\"ur alle $i=1,\ldots,n$.
  Also gilt insbesondere $\Tj{[\,]}{e_n}{\tau}$, aber $e_n \not\in\setVal$ und $e_n \not\to$.
  Dies steht im Widerspruch zu Satz~\ref{satz:Lot:Progress}.
\end{beweis}

{\bf TODO:} Prosa

\begin{korollar}
  Sei $e\in\setExp$ und $\tau\in\setType$. Wenn $\Tj{[\,]}{e}{\tau}$, dann gilt genau eine der
  folgenden Aussagen.
  \begin{enumerate}
    \item Es existiert ein $v\in\setVal$ mit $e \xrightarrow* v$.
    \item Die Berechnung von $e$ divergiert.
  \end{enumerate}
\end{korollar}

\begin{beweis}
  Folgt unmittelbar aus Satz~\ref{satz:Lot:Safety}.
\end{beweis}


% vi:set ts=2 sw=2 et ai syntax=tex:
