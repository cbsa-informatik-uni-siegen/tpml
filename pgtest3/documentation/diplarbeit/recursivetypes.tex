%%
%% Rekursive Typen
%%

\chapter{Rekursive Typen}
\label{kapitel:Rekursive_Typen}

{\bf TODO:} Diese Einleitung passt nicht zum Kapitel! Unbedingt anpassen!

Im vorangegangenen Kapitel haben wir das einfache objekt-orientierte Typsystem aus
Kapitel~\ref{kapitel:Funktionale_Objekte} um Subsumption erweitert, so dass in der
Sprache \Losub\ deutlich mehr Ausdr\"ucke wohlgetypt sind, als noch in der Programmiersprache \Lot.
Dabei haben wir f\"ur \Losub\ gezeigt, dass diese neu hinzugewonnen wohlgetypten Ausdr\"ucke
zu Unrecht durch das Typsystem von \Lot\ abgelehnt wurden, denn deren Berechnung bleibt nicht
stecken (vgl. Satz~\ref{satz:Losub:Safety}).

Allerdings ist das Typsystem der Sprache \Losub\ immer noch zu eingeschr\"ankt, um
sinnvoll mit funktionalen Objekten programmieren zu k\"onnen. Zum Beispiel ist es nicht m\"oglich
den folgenden Ausdruck so mit Typinformationen zu versehen, dass mit den Typregeln von \Losub\ ein
Typ herleitbar w\"are.
\[\begin{array}{l}
  \expLet{point}{\\\quad \expObject{\self} 
                           {\\\quad\quad \rowVal{x}{1} 
                           {\\\quad\quad \rowVal{y}{2}
                           {\\\quad\quad \rowMethod{move}{\expAbstr{dx}{\expAbstr{dy}
                                                   {\expDupl{x=x+dx;y=y+dy}}}}
                           {\\\quad}}}}\\}
                           {\expApp{\expApp{\expSend{point}{move}}{2}}{1}}
\end{array}\]
Offensichtlich w\"urde die Berechnung dieses Ausdrucks nicht stecken bleiben, sondern stattdessen mit
einem Punktobjekt terminieren, mit den Koordinaten $x=3$ und $y=3$. Die Methode $move$ liefert ein neues
Punktobjekt, welches sich lediglich in den Werten der Attribute $x$ und $y$ unterscheidet. Insbesondere
besitzt aber dieses neue Punktobjekt ebenfalls eine Methode $move$.

F\"ur das Typsystem bedeutet das, dass ein Typ f\"ur $point$ "`sich selbst enthalten"' m\"usste, und
zwar als Ergebnistyp der Methode $move$. Oder anders ausgedr\"uckt, gesucht ist ein Typ $\tau_{point}$
f\"ur den gilt:
\[
  \tau_{point} = \typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{\tau_{point}}}}{\rtypeEmpty}}
\]
Es ist leicht zu sehen, dass im Typsystem der Sprache \Losub\ kein solcher Typ $\tau_{point}$ existiert, der diese
(rekursive) Gleichung erf\"ullt. Um also Objekten, die sich selbst oder ein Duplikat von sich selbst als Ergebnis
eines Methodenaufrufs liefern, Typen zuordnen zu k\"onnen, ist es notwendig das Typsystem um sogenannte
\Define{rekursive Typen}{Rekursive Typen} \engl{recursive types} zu erweitern.

{\bf TODO:} Darstellung als unendlicher Baum, und \"Uberleitung zur endlichen Darstellung dieser
unendlichen Struktur ($\mu$-types)


%%%%%%%%%%%%%%%%%%%%%%
%% Die Sprache Lort %%
%%%%%%%%%%%%%%%%%%%%%%

\section{Die Sprache \Lort}
\label{abschnitt:Die_Sprache_Lort}

Die im diesem Abschnitt betrachtete Sprache \Lort\ stellt eine Erweiterung des Typsystems der Sprache \Lot\ um
rekursive Typen dar. Die Semantik der Sprache \Lot\ wird bis auf die folgenden syntaktischen \"Anderungen
unver\"andert \"ubernommen.

\begin{definition}[Syntax der Sprache \Lort] \label{definition:Lort:Syntax_der_Sprache_Lort} \
  Vorgegeben sei eine Menge $\setTName$ von \Define{Typnamen}{Typname} $t$.
  \begin{enumerate}
    \item Die Menge $\setType^{raw}$ aller syntaktisch herleitbaren Typen $\tau^{raw}$ ist durch die
          kontextfreie Grammatik
          \GRbeg
            \tau^{raw} \GRis \typeBool \GRmid \typeInt \GRmid \typeUnit
                       \GRal \typeArrow{\tau_1^{raw}}{\tau_2^{raw}}
                       \GRal \typeRec{t}{\tau_1^{raw}}
                       \GRal \typeObject{\phi^{raw}}
          \GRend
          und die Menge $\setRType^{raw}$ aller syntaktisch herleitbaren Reihentypen $\phi^{raw}$ ist durch
          \GRbeg
            \phi^{raw} \GRis \rtypeEmpty
                       \GRal \rtypeMethod{m}{\tau^{raw}}{\phi_1^{raw}}
          \GRend
          definiert.

    \item Die Menge $\free{\tau^{raw}}$ aller im Typ $\tau^{raw}\in\setType^{raw}$ frei vorkommenden Typnamen ist
          induktiv durch
          \EQNbeg
            \free{\tau_\beta} & = & \emptyset \text{ f\"ur } \tau_\beta\in\{\typeBool,\typeInt,\typeUnit\} \\
            \free{\typeArrow{\tau_1^{raw}}{\tau_2^{raw}}} & = & \free{\tau_1^{raw}} \cup \free{\tau_2^{raw}} \\
            \free{\typeRec{t}{\tau_1^{raw}}} & = & \free{\tau_1^{raw}} \setminus \{t\} \\
            \free{\typeObject{\phi^{raw}}} & = & \free{\phi^{raw}}
          \EQNend
          und die Menge $\free{\phi^{raw}}$ aller im Reihentyp $\phi^{raw} \in\setRType^{raw}$ frei
          vorkommenden Typnamen ist induktiv durch
          \EQNbeg
            \free{\rtypeEmpty} & = & \emptyset \\
            \free{\rtypeMethod{m}{\tau^{raw}}{\phi_1^{raw}}} & = & \free{\tau^{raw}} \cup \free{\phi_1^{raw}}
          \EQNend
          definiert.

    \item Die Mengen $\setType \subseteq \setType^{raw}$ aller g\"ultigen Typen $\tau$ und
          $\setRType^{raw}\subseteq\setRType$ aller g\"ultigen Reihentypen $\phi$ der Programmiersprache
          \Lort\ sind wie folgt definiert
          \EQNbeg
            \setType & = & \{\tau\in\setType^{raw}\ |\ \free{\tau} = \emptyset \wedge
                            \forall t,t_1,\ldots,t_n\in\setTName:
                            \typeRec{t}{\typeRec{t_1}{\ldots\typeRec{t_n}{t}}} \not\in \mathcal{P}(\tau)\} \\
            \setRType & = & \{\phi\in\setRType^{raw}\ |\ \free{\phi} = \emptyset\},
          \EQNend
          wobei $\mathcal{P}(\tau)$ die Menge aller im Typ $\tau$ vorkommenden Typen bezeichnet.
  \end{enumerate}
\end{definition}
Rekursive Typen sind hierbei analog zu rekursiven Ausdr\"ucken zu lesen, d.h. mit $\typeRec{t}{\tau}$
bezeichnen wir den Typ, der die Gleichung
\[
  \typeRec{t}{\tau} = \tau\SUB{\typeRec{t}{\tau}}{t}
\]
erf\"ullt. Allerdings handelt es sich hierbei nicht um die syntaktische Gleichheit der beiden Typen,
sondern vielmehr die \"ubereinstimmende Bedeutung.

{\bf TODO:} Erl\"auterungen zur Definition

Bevor wir uns jedoch genauer mit dem Begriff der
Gleichheit von rekursiven Typen besch\"aftigen, kommen wir zun\"achst auf das Beispiel mit dem
Punktobjekt zur\"uck. In der Sprache \Lort\ l\"asst sich das Beispiel nun wie folgt mit Typinformationen
versehen.
\[\begin{array}{l}
  \expLet{point}{\\\quad \expObject{\self:\typeRec{t}{\typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}{\rtypeEmpty}}}} 
                           {\\\quad\quad \rowVal{x}{1} 
                           {\\\quad\quad \rowVal{y}{2}
                           {\\\quad\quad \rowMethod{move}{\expAbstr{dx:\typeInt}{\expAbstr{dy:\typeInt}
                                                   {\expDupl{x=x+dx;y=y+dy}}}}
                           {\\\quad}}}}\\}
                           {\expApp{\expApp{\expSend{point}{move}}{2}}{1}}
\end{array}\]
Intuitiv sollte sich f\"ur diesen Ausdruck der Typ des Punktobjekts herleiten lassen, also
\[
  \typeRec{t}{\typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}{\rtypeEmpty}}},
\]
was dem zu erwartenden Ergebnis entsprechen w\"urde.

\begin{definition} \label{definition:Lort:Typkonstruktoren}
  Die Menge $\setTCons$ der Typkonstruktoren sei definiert durch
  \[\begin{array}{rcl}
    \setTCons & = & \{\typeBool,\typeInt,\typeUnit,\to\}
               \cup \{\typeObject{m_1;\ldots;m_n}\ |\ n\in\setN,\ m_1,\ldots,m_n\in\setMethod\},
  \end{array}\]
  wobei die Methodennamen in $\typeObject{m_1;\ldots;m_n}$ \"ahnlich wie bei den Typen als disjunkt
  angenommen werden.
\end{definition}

{\bf TODO:} Prosa

\begin{definition} \label{definition:Lort:Tree_Funktionen} \
  \begin{enumerate}
    \item Sei $\name{root}:\setType\to\setTCons$ die induktiv wie folgt definierte Funktion:
          \[\begin{array}{rcl}
            \TREEroot{\tau_\beta} & = & \tau_\beta \quad \text{ f\"ur } \tau_\beta \in \{\typeBool,\typeInt,\typeUnit\} \\
            \TREEroot{\typeArrow{\tau_1}{\tau_2}} & = & \to \\
            \TREEroot{\typeObject{{m_i:\tau_i}^{i=1 \ldots n}}} & = & \typeObject{m_i^{i=1 \ldots n}} \\
            \TREEroot{\typeRec{t}{\tau}} & = & \TREEroot{\tau\SUB{\typeRec{t}{\tau}}{t}}
          \end{array}\]

    \item Die Funktion $\name{arity}:\setType\to\setN$ sei induktiv definiert durch:
          \[\begin{array}{rcl}
            \TREEarity{\tau_\beta} & = & 0 \quad \text{ f\"ur } \tau_\beta \in \{\typeBool,\typeInt,\typeUnit\} \\
            \TREEarity{\typeArrow{\tau_1}{\tau_2}} & = & 2 \\
            \TREEarity{\typeObject{{m_i:\tau_i}^{i=1 \ldots n}}} & = & n \\
            \TREEarity{\typeRec{t}{\tau}} & = & \TREEarity{\tau\SUB{\typeRec{t}{\tau}}{t}}
          \end{array}\]

    \item Die partielle Funktion $\name{child}:\setType\times\setN\pto\setType$ ist induktiv definiert durch:
          \[\begin{array}{rcl}
            \name{child}\,(\typeArrow{\tau_1}{\tau_2},i) & = & \CASEbeg
                                                                 \tau_i & \text{ falls } 1 \le i \le 2 \\
                                                                 \uparrow & \text{ sonst }
                                                               \CASEend \\[3mm]
            \name{child}\,(\typeObject{{m_j:\tau_j}^{j=1 \ldots n}},i) & = & \CASEbeg
                                                                               \tau_i & \text{ falls } 1 \le i \le n \\
                                                                               \uparrow & \text{ sonst }
                                                                             \CASEend \\[3mm]
            \name{child}\,(\typeRec{t}{\tau},i) & = & \name{child}\,(\tau\SUB{\typeRec{t}{\tau}}{t},i)
          \end{array}\]
          Statt $\name{child}(\tau,i)$ schreiben wir kurz $\TREEchild{i}{\tau}$.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa... hiermit klar, warum $\setType$ wie oben definiert werden muss.
Es ist klar, dass $\TREEchild{i}{\tau}$ stets definiert ist, solange $1 \le i \le \TREEarity{\tau}$.

\begin{korollar}
  $\forall \tau,\tau'\in\setType:\ \TREEroot{\tau} = \TREEroot{\tau'}\ \Rightarrow\ \TREEarity{\tau} = \TREEarity{\tau'}$
\end{korollar}

\begin{beweis}
  Trivial.
\end{beweis}

\begin{definition} \label{definition:Lort:Typgleichheit}
  Die Relationen $\sim_n$ seien wie folgt induktiv definiert
  \[\begin{array}{rcl}
    \sim_0     & = & \setType^2 \\
    \sim_{n+1} & = & \{(\tau,\tau')\in\setType^2\,|\,\TREEroot{\tau} = \TREEroot{\tau'} \\
               &   & \quad \wedge \ \forall 1 \le i \le \TREEarity{\tau}:\ \TREEchild{i}{\tau} \sim_n \TREEchild{i}{\tau'}\},
  \end{array}\]
  und die Relation $\sim$ ist durch
  \[\begin{array}{rcl}
    \sim & = & \bigcap\limits_{n\in\setN} \sim_n
  \end{array}\]
  definiert, also als Durchschnitt der Relationen $\sim_n$.
\end{definition}

{\bf TODO:} \"Uberleitung

\begin{lemma} \label{lemma:Lort:Aequivalenzrelation}
  Die Relation $\sim$ ist eine \"Aquivalenzrelation.
\end{lemma}

\begin{beweis}
  Hierzu gen\"ugt es zu zeigen, dass jede Relation $\sim_n$ eine \"Aquivalenzrelation ist, denn der Schnitt von
  \"Aquivalenzrelationen ist wiederum eine \"Aquivalenzrelation. Wir zeigen also durch Induktion \"uber $n$,
  dass alle $\sim_n$ reflexiv, transitiv und symmetrisch sind.
  \begin{itemize}
    \item $n = 0$

          Da $\sim_0\,=\setType^2$ ist klar, dass $\sim_0$ reflexiv, transitiv und symmetrisch ist.

    \item $n \leadsto n+1$

          Nach Induktionsvoraussetzung ist $\sim_n$ reflexiv, transitiv und symmetrisch.

          \noindent\underline{Reflexivit\"at:} Da $\sim_n$ reflexiv ist, folgt trivialerweise, dass auch $\sim_{n+1}$ reflexiv ist.

          \noindent\underline{Transivit\"at:} Seien $(\tau_1,\tau_2),(\tau_2,\tau_3)\in\sim_{n+1}$. Dann gilt
          $\TREEroot{\tau_1}=\TREEroot{\tau_2}=\TREEroot{\tau_3}$, $\TREEchild{i}{\tau_1} \sim_n \TREEchild{i}{\tau_2}$ und
          $\TREEchild{i}{\tau_2} \sim_n \TREEchild{i}{\tau_3}$ f\"ur alle $i = 1,\ldots,\TREEarity{\tau_2}$. Da
          $\sim_n$ transitiv ist, folgt $\TREEchild{i}{\tau_1} \sim_n \TREEchild{i}{\tau_3}$  f\"ur alle
          $i = 1,\ldots,\TREEarity{\tau_1}$, und somit $(\tau_1,\tau_3)\in\sim_{n+1}$.

          \noindent\underline{Symmetrie:} Sei $(\tau,\tau')\in\sim_{n+1}$. Dann ist nach Definition
          $\TREEroot{\tau} = \TREEroot{\tau'}$ und es gilt $\TREEchild{i}{\tau} \sim_n \TREEchild{i}{\tau'}$
          f\"ur alle $i = 1,\ldots,\TREEarity{\tau}$. Da $\sim_n$ symmetrisch ist,
          folgt $\TREEchild{i}{\tau'} \sim_n \TREEchild{i}{\tau}$, also $(\tau,\tau')\in\sim_{n+1}$.
  \end{itemize}
  Also ist $\sim$ eine \"Aquivalenzrelation auf $\setType$.
\end{beweis}

\begin{definition}
  Mit $\setTypeRel$ bezeichnen wir die Menge der bin\"aren Relationen auf $\setType$, also
  $\setTypeRel = \mathcal{P}(\setType \times \setType)$.
\end{definition}

\begin{definition} \label{definition:Lort:Abbildung_E}
  Sei $\mathcal{E}: \setTypeRel \to \setTypeRel$ definiert durch
  \[\begin{array}{rcl}
    \mathcal{E}(R)
    &   =  & \{(\tau,\tau')\in\setType^2\,|\,\TREEroot{\tau} = \TREEroot{\tau'} \in \{\typeBool,\typeInt,\typeUnit\}\} \\
    & \cup & \{(\tau,\tau')\in\setType^2\,|\,\TREEroot{\tau} = \TREEroot{\tau'} =\ \to \\
    &      & \quad \wedge\,\forall i=1,2:\,(\TREEchild{i}{\tau},\TREEchild{i}{\tau'})\in{R}\} \\
    & \cup & \{(\tau,\tau')\in\setType^2\,|\,\TREEroot{\tau} = \TREEroot{\tau'} = \typeObject{m_1;\ldots;m_k} \\
    &      & \quad \wedge\,\forall i=1,\ldots,k:\,(\TREEchild{i}{\tau},\TREEchild{i}{\tau'})\in{R}\},
  \end{array}\]
  also eine totale Abbildung zwischen bin\"aren Typrelationen.
\end{definition}

Die Idee ist nun zu zeigen, dass die Relation $\sim$ ein Fixpunkt der generierenden Funktion $\mathcal{E}$ ist.
Dazu benutzen wir den Fixpunktsatz von Kleene, das heisst, wir m\"ussen zun\"achst zeigen, dass $\setTypeRel$
eine dcpo ist, und die Abbildung $\mathcal{E}$ auf $(\setTypeRel,\supseteq)$ stetig ist. Der Leser
sei an dieser Stelle nochmals auf Abschnitt~\ref{abschnitt:Bereichstheorie} verwiesen, in dem die notwendigen
mathematischen Grundlagen zur Bereichstheorie dargestellt werden.

\begin{lemma} \label{lemma:Lort:dcpo_und_Stetigkeit} \
  \begin{enumerate}
    \item $(\setTypeRel,\supseteq)$ ist eine dcpo mit kleinstem Element $\setType \times \setType$.
    \item $\mathcal{E}$ ist eine stetige Abbildung auf $(\setTypeRel,\supseteq)$.
  \end{enumerate}
\end{lemma}

\begin{beweis} \
  \begin{enumerate}
    \item Folgt unmittelbar nach Lemma~\ref{lemma:math:Potenzmengen_sind_dcpos}.

    \item Zun\"achst zeigen wir, dass $\mathcal{E}$ eine monotone Abbildung auf $(\setTypeRel,\supseteq)$ ist. Seien dazu
          $R_1,R_2\in\setTypeRel$ mit $R_1 \supseteq R_2$. Dann m\"ussen wir zeigen, dass f\"ur alle
          $(\tau,\tau')\in\mathcal{E}(R_2)$ auch $(\tau,\tau')\in\mathcal{E}(R_1)$ gilt. Dazu unterscheiden
          wir nach der Form von $\TREEroot{\tau}$:
          \PROOFCASEbeg
            \item $\TREEroot{\tau} \in \{\typeBool,\typeInt,\typeUnit\}$

                  Dann gilt $\TREEroot{\tau} = \TREEroot{\tau'}$, und nach Definition~\ref{definition:Lort:Abbildung_E}
                  gilt $(\tau,\tau')\in\mathcal{E}(R)$ f\"ur alle $R\in\setTypeRel$, also insbesondere
                  $(\tau,\tau')\in\mathcal{E}(R_1)$.
            
            \item $\TREEroot{\tau} =\ \to$

                  Dann gilt $\TREEroot{\tau} = \TREEroot{\tau'}$ und $\bigl(\TREEchild{i}{\tau},\TREEchild{i}{\tau'}\bigr)\in{R_2}$
                  f\"ur $i=1,2$. Da $R_2 \subseteq R_1$ folgt unmittelbar $\bigl(\TREEchild{i}{\tau},\TREEchild{i}{\tau'}\bigr)\in{R_1}$
                  und somit nach Definition~\ref{definition:Lort:Abbildung_E} auch $(\tau,\tau')\in\mathcal{E}(R_1)$.
            
            \item $\TREEroot{\tau} = \typeObject{m_1;\ldots;m_k}$

                  Folgt v\"ollig analog.
          \PROOFCASEend

          Um die Stetigkeit von $\mathcal{E}$ zu beweisen, bleibt also zu zeigen, dass
          \[\begin{array}{rcl}
            \mathcal{E}(\bigsqcup \Delta) & \supseteq & \bigsqcup \mathcal{E}(\Delta)
          \end{array}\]
          f\"ur jede gerichtete Teilmenge $\Delta\subseteq\setTypeRel$ gilt, wobei das
          Supremum bez\"uglich $\supseteq$ offensichtlich dem Durchschnitt entspricht.
          Sei dazu $\Delta\subseteq\setTypeRel$ gerichtet und
          $(\tau,\tau')\in\bigcap \mathcal{E}(\Delta) = \bigcap \{\mathcal{E}(R)\,|\,R\in\Delta\}$,
          das heisst $(\tau,\tau')\in\mathcal{E}(R)$ f\"ur alle $R\in\Delta$.
          Wir zeigen durch Fallunterscheidung nach der Form von $\TREEroot{\tau}$, dass auch
          $(\tau,\tau')\in\mathcal{E}(\bigcap \Delta)$ gilt:
          \PROOFCASEbeg
            \item $\TREEroot{\tau} \in \{\typeBool,\typeInt,\typeUnit\}$

                  Klar.

            \item $\TREEroot{\tau} =\ \to$

                  Es gilt wieder $\TREEroot{\tau} = \TREEroot{\tau'}$ und
                  $\bigl(\TREEchild{i}{\tau},\TREEchild{i}{\tau'}\bigr)\in{R}$ f\"ur $i=1,2$ und alle $R\in\Delta$.
                  Also gilt insbesondere $\bigl(\TREEchild{i}{\tau},\TREEchild{i}{\tau'}\bigr)\in\bigcap\Delta$ f\"ur $i=1,2$,
                  und wegen Definition~\ref{definition:Lort:Abbildung_E} folgt somit $(\tau,\tau')\in\mathcal{E}(\bigcap\Delta)$.
            
            \item $\TREEroot{\tau} = \typeObject{m_1;\ldots;m_k}$

                  Folgt wieder analog zum vorangegangenen Fall.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}
%
Damit nun l\"asst sich das zentrale Lemma \"uber die Typrelation $\sim$ formulieren und beweisen,
welches uns einen einfacheren Umgang mit der Relation $\sim$ erm\"oglicht, so dass wir nicht
l\"anger zeigen m\"ussen, dass eine bestimmte Eigenschaft, die wir f\"ur $\sim$ beweisen m\"ochten,
f\"ur alle $\sim_n$ gilt.

\begin{lemma}[Fixpunkt-Lemma f\"ur \Lort] \label{lemma:Lort:Fixpunkt_Lemma}
  $\mu\mathcal{E} =\ \sim$
\end{lemma}

Mit anderen Worten, die Relation $\sim$ ist der kleinste Fixpunkt der generierenden Funktion $\mathcal{E}$.
Dies l\"asst sich mit dem Fixpunktsatz von Kleene leicht zeigen.

\begin{beweis}
  Gem\"a"s Lemma~\ref{lemma:Lort:dcpo_und_Stetigkeit} ist $(\setTypeRel,\supseteq)$ eine
  dcpo mit einem kleinsten Element $\setType\times\setType$, und $\mathcal{E}$ ist eine totale, stetige Abbildung auf
  $(\setTypeRel,\supseteq)$. Nach Satz~\ref{satz:math:Fixpunktsatz_von_Kleene} (Fixpunktsatz von Kleene) existiert also
  mit $\mu\mathcal{E} = \bigsqcup_{n\in\setN} \mathcal{E}^n(\setType\times\setType)$ der kleinste Fixpunkt von $\mathcal{E}$.

  Es bleibt noch zu zeigen, dass gerade die Typrelation $\sim$ genau diesem Fixpunkt entspricht, also, dass
  $\sim\ = \bigsqcup_{n\in\setN}\mathcal{E}^n(\setType\times\setType)$ gilt. Dazu zeigen wir zun\"achst
  durch vollst\"andige Induktion \"uber $n$, dass $\sim_n\ = \mathcal{E}^n(\setType\times\setType)$ gilt:
  \begin{itemize}
    \item $n=0$

          Klar, da $\sim_0\ = \setType\times\setType = \mathcal{E}^0(\setType\times\setType)$.

    \item $n\leadsto{n+1}$

          Wegen Induktionsvoraussetzung gilt $\sim_n\ = \mathcal{E}^n(\setType\times\setType)$, und wir
          m\"ussen zeigen, dass dann auch $\sim_{n+1}\ = \mathcal{E}(\sim_n)$ gilt:
          \begin{itemize}
            \item["`$\subseteq$"']
                
                  Sei $(\tau,\tau')\in\ \sim_{n+1}$, d.h. $\TREEroot{\tau}=\TREEroot{\tau'}$ und
                  $(\TREEchild{i}{\tau},\TREEchild{i}{\tau'})\in\ \sim_n$ f\"ur $i=1,\ldots,\TREEarity{\tau}$.
                  Mit Fallunterscheidung nach der Form von $\TREEroot{\tau}$ l\"asst sich leicht zeigen,
                  dass auch $(\tau,\tau')\in\mathcal{E}(\sim_n)$ gilt.

            \item["`$\supseteq$"']

                  Sei nun $(\tau,\tau')\in\mathcal{E}(\sim_n)$. Dann ist je nach Form von $\TREEroot{\tau}$
                  zu zeigen, dass auch $(\tau,\tau')\in\ \sim_{n+1}$ gilt, was aus offensichtlichen Gr\"unden
                  ziemlich trivial ist.
          \end{itemize}
  \end{itemize}
  Insgesamt folgt dann $\sim\ = \bigcap_{n\in\setN}\mathcal{E}^n(\setType\times\setType)
                              = \bigsqcup_{n\in\setN}\mathcal{E}^n(\setType\times\setType)$, was es zu zeigen galt.
\end{beweis}

\begin{korollar}
  $\sim$ ist bez\"uglich $\subseteq$ der gr\"o"ste Fixpunkt von $\mathcal{E}$.
\end{korollar}

\begin{beweis}
  Klar.
\end{beweis}

Die Aussage des Fixpunkt-Lemmas l\"asst sich auch in einer einfacher anzuwendenden Form darstellen, mit
der wir dann in den nachfolgenden Beweisen leichter argumentieren k\"onnen:

\begin{lemma}[\"Aquivalenz-Lemma f\"ur \Lort] \label{lemma:Lort:Aequivalenz_Lemma}
  $\tau \sim \hat{\tau}$ gilt genau dann, wenn eine der folgenden Aussagen erf\"ullt ist:
  \begin{enumerate}
    \item $\tau = \typeRec{t_1}{\ldots\typeRec{t_n}{\tau_\beta}}$ und
          $\hat{\tau} = \typeRec{\hat{t}_1}{\ldots\typeRec{\hat{t}_m}{\tau_\beta}}$ mit $\tau_\beta\in\{\typeBool,\typeInt,\typeUnit\}$

    \item $\tau = \typeRec{t_1}{\ldots\typeRec{t_n}{\typeArrow{\tau_1}{\tau_2}}}$
          und $\hat{\tau} = \typeRec{\hat{t}_1}{\ldots\typeRec{\hat{t}_m}{\typeArrow{\hat{\tau}_1}{\hat{\tau}_2}}}$
          mit $\tau_1{\SUB{\tau}{t_i}}_{i=1}^{n} \sim \hat{\tau}_1{\SUB{\hat{\tau}}{\hat{t}_i}}_{i=1}^{m}$
          und $\tau_2{\SUB{\tau}{t_i}}_{i=1}^{n} \sim \hat{\tau}_2{\SUB{\hat{\tau}}{\hat{t}_i}}_{i=1}^{m}$

    \item $\tau = \typeRec{t_1}{\ldots\typeRec{t_n}{\typeObject{m_1:\tau_1;\ldots;m_k:\tau_k}}}$
          und $\hat{\tau} = \typeRec{\hat{t}_1}{\ldots\typeRec{\hat{t}_m}{\typeObject{m_1:\hat{\tau}_1;\ldots;m_k:\hat{\tau}_k}}}$
          mit $\tau_j{\SUB{\tau}{t_i}}_{i=1}^{n} \sim \hat{\tau}_j{\SUB{\hat{\tau}}{\hat{t}_i}}_{i=1}^{m}$ f\"ur alle $j=1,\ldots,k$
  \end{enumerate}
\end{lemma}

Dabei handelt es sich zum Beispiel bei $\tau_1,\tau_2$ um nicht unbedingt abgeschlossene Typen, in denen
die Typnamen $t_1,\ldots,t_n$ frei vorkommen d\"urfen, was aber in der Folge bedeutet, dass in jedem
Fall $\tau_1{\SUB{\tau}{t_i}}_{i=1}^{n},\tau_2{\SUB{\tau}{t_i}}_{i=1}^{n}\in\setType$ gilt, da $\tau$
ein abgeschlossener Typ ist. Entsprechendes gilt f\"ur die \"ubrigen Typen $\hat{\tau}_1, \hat{\tau}_2,\ldots$.

\begin{beweis}
  Folgt unmittelbar aus dem Fixpunkt-Lemma (\ref{lemma:Lort:Fixpunkt_Lemma}), da die Aussagen des
  Lemmas mit der Definition von $\mathcal{E}$ \"ubereinstimmen (\ref{definition:Lort:Abbildung_E}).
\end{beweis}

Um nun zum Beispiel zu zeigen, dass $\typeArrow{\tau_1}{\tau_2} \sim \typeArrow{\tau_1'}{\tau_2'}$ gilt,
gen\"ugt es zu zeigen, dass $\tau_1 \sim \tau_1'$ und $\tau_2 \sim \tau_2'$ gilt. Entsprechend gilt
f\"ur Basistypen $\tau,\tau'\in\{\typeBool,\typeInt,\typeUnit\}$, dass $\tau \sim \tau'$ genau dann
erf\"ullt ist, wenn $\tau = \tau'$ gilt.

\begin{definition}[G\"ultige Typurteile f\"ur \Lort] \label{definition:Lort:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Lort}
  Ein Typurteil $\Tje{\Gamma}{e}{\tau}$ oder $\Tjr{\Gamma}{r}{\phi}$ heisst {\em g\"ultig} f\"ur
  \Lort, wenn es sich mit den Typregeln der Programmiersprache \Lot\ aus
  Definition~\ref{definition:Lot:Gueltige_Typurteile} mit Ausnahme der \RN{Object}-Regel, sowie
  den folgenden neuen Typregeln\\[5mm]
  \begin{tabular}{ll}
    \RN{Object'}      & $\RULE{\Tjr{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}
                               \quad
                               \tau \sim \typeObject{\phi}}
                              {\Tje{\Gamma}{\expObject{\self:\tau}{r}}{\tau}}$ \\[5mm]
    \RN{Equiv}        & $\RULE{\Tje{\Gamma}{e}{\tau'} \quad \tau' \sim \tau}
                              {\Tje{\Gamma}{e}{\tau}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst.
\end{definition}

{\bf TODO:} Beispiel f\"ur Typherleitung \\
{\bf TODO:} \"Uberleitung


%%%%%%%%%%%%%%%%%%%
%% Typsicherheit %%
%%%%%%%%%%%%%%%%%%%

\subsection{Typsicherheit}
\index{Typsicherheit}

{\bf TODO:} Zun\"achst die obligatorischen Lemmata

\begin{lemma}[Typumgebungen und frei vorkommende Namen] \label{lemma:Lort:free_und_dom_Gamma} \
  \begin{enumerate}
    \item $\forall \Gamma \in \setTEnv, e\in\setExp,\tau\in\setType:\,
           \Tj{\Gamma}{e}{\tau}\,\Rightarrow\,\free{e}\subseteq\dom{\Gamma}$
    \item $\forall \Gamma \in \setTEnv, r\in\setRow,\phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\Rightarrow\,\free{r}\subseteq\dom{\Gamma}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Entspricht dem Beweis von Lemma~\ref{lemma:Lot:free_und_dom_Gamma} f\"ur die Programmiersprache
  \Lot, wobei der neue Fall f\"ur die \RN{Equiv}-Regel direkt mit Induktionsvoraussetzung folgt.
\end{beweis}

\begin{lemma}[Koinzidenzlemma f\"ur Lort] \label{lemma:Lort:Koinzidenzlemma} \
  \begin{enumerate}
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, e \in \setExp, \tau \in \setType:\,
           \Tj{\Gamma_1}{e}{\tau}\,\wedge\,\Gamma_1 =_{\free{e}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{e}{\tau}$
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, r \in \setRow, \phi \in \setRType:\,
           \Tj{\Gamma_1}{r}{\phi}\,\wedge\,\Gamma_1 =_{\free{r}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{r}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wiederum wie im Beweis von Lemma~\ref{lemma:Lot:Koinzidenzlemma} f\"ur die Programmiersprache \Lot,
  und der Fall f\"ur die \RN{Equiv}-Regel folgt ebenfalls direkt mit Induktionsvoraussetzung.
\end{beweis}

\begin{lemma}[Typurteile und Substitution] \label{lemma:Lort:Typurteile_und_Substitution}
  Sei $\id \in \setAttribute \cup \setVar$, $\Gamma \in \setTEnv$, $\tau \in \setType$
  und $e \in \setExp$. Dann gilt:
  \begin{enumerate}
    \item $\forall e' \in \setExp:
           \forall \tau' \in \setType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$
    \item $\forall r \in \setRow:
           \forall \phi \in \setRType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{r\SUB{e}{\id}}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wie im Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_Substitution} mittels simultaner Induktion \"uber die
  L\"ange der Herleitung der Typurteile $\Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi}$,
  und Fallunterscheidung nach der letzten angewandten Typregel. Wir betrachten nur die F\"alle der \RN{Equiv}- und
  \RN{Object'}-Regeln.
  \PROOFCASEbeg
    \item $\Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'}$ mit Typregel \RN{Equiv}.

          Nach Voraussetzung existiert ein $\tau''\in\setType$ mit $\Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau''}$ und
          $\tau'' \sim \tau'$. Mit Induktionsvoraussetzung folgt dann
          \[\begin{array}{l}
            \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau''},
          \end{array}\]
          und somit wegen
          \[\begin{array}{l}
            \tau'' \sim \tau'
          \end{array}\]
          mit Typregel \RN{Equiv} das erwartete Ergebnis $\Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$.

    \item $\Tj{\Gamma\SUB{\tau}{\id}}{\expObject{\self:\tau'}{r}}{\tau'}$ mit Typregel \RN{Object'}.

          Dann existiert ein $\phi\in\setRType$ mit $\Tj{(\Gamma\SUB{\tau}{\id})^\star\SUB{\tau'}{\self}}{r}{\phi}$ und
          $\typeObject{\phi} \sim \tau'$.

          Falls $\id\in\setVar$, dann gilt nach Definition $(\Gamma\SUB{\tau}{\id})^\star = \Gamma^\star\SUB{\tau}{\id}$.
          Andererseits gilt f\"ur $\id\in\setAttribute$, dass $(\Gamma\SUB{\tau}{\id})^\star = \Gamma^\star$, also nach
          Lemma~\ref{lemma:Lort:free_und_dom_Gamma} $\id\not\in\free{r}$. Demzufolge gilt
          $\Gamma^\star =_{\free{r}} \Gamma^\star\SUB{\tau}{\id}$. Zusammenfassend folgt also
          \[\begin{array}{l}
            \Tj{\Gamma^\star\SUB{\tau}{\id}\SUB{\tau'}{\self}}{r}{\phi},
          \end{array}\]
          und da $\self \not\in \setAttribute\cup\setVar$ folgt weiter
          \[\begin{array}{l}
            \Tj{\Gamma^\star\SUB{\tau'}{\self}\SUB{\tau}{\id}}{r}{\phi}.
          \end{array}\]
          Darauf l\"asst sich nun die Induktionsvoraussetzung anwendung und wir erhalten
          \[\begin{array}{l}
            \Tj{\Gamma^\star\SUB{\tau'}{\self}}{r\SUB{e}{\id}}{\phi},
          \end{array}\]
          woraus sich wegen $\typeObject{\phi} \sim \tau'$ mit Typregel \RN{Object'} schliesslich
          \[\begin{array}{l}
            \Tj{\Gamma}{\expObject{\self:\tau'}{r\SUB{e}{\id}}}{\tau'}
          \end{array}\]
          ergibt, was nach Definition der Substitution (\ref{definition:Lo:Substitution}) dem Typurteil
          \[\begin{array}{l}
            \Tj{\Gamma}{(\expObject{\self:\tau'}{r})\SUB{e}{\id}}{\tau'}
          \end{array}\]
          entspricht.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen entsprechend wie im Beweis des Lemmas f\"ur die Programmiersprache \Lot.
\end{beweis}
%
Zus\"atzlich zum Substitutionslemma f\"ur Attribute und Variablen (\ref{lemma:Lort:Typurteile_und_Substitution}) ben\"otigen
wir wieder ein spezielles Lemma, welches die Typerhaltung der $\self$-Substitution sichert (siehe
Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution}).

\begin{lemma}[Typurteile und $\self$-Substitution] \label{lemma:Lort:Typurteile_und_self_Substitution}
  Sei $\Gamma \in \setTEnv$, $\self\in\setSelf$,\linebreak[4] $\tau\in\setType$ und $r\in\setRow$. Dann gilt:
  \renewcommand{\labelenumii}{(\arabic{enumii})}
  \begin{enumerate}
    \item F\"ur alle $e\in\setExp$ und $\tau'\in\setType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          \end{enumerate}

    \item F\"ur alle $r'\in\setRow$ und $\phi\in\setRType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r \oplus r'}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{r'\SUB{\expObject{\self:\tau}{r \oplus r'}}{\self}}{\phi}$
          \end{enumerate}
  \end{enumerate}
  \renewcommand{\labelenumii}{\arabic{enumii}.}
\end{lemma}

\begin{beweis}
  Der Beweis entspricht im wesentlichen dem Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution} f\"ur die
  Programmiersprache \Lot. Wie zuvor folgt gem\"a"s Lemma~\ref{lemma:Lort:free_und_dom_Gamma} (Typumgebungen und frei
  vorkommende Namen), dass die Substitution stets definiert ist. Der Beweis erfolgt dann durch simultane Induktion \"uber
  die L\"ange der Herleitung der Typurteile
  $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$, und Fallunterscheidung nach
  der letzten Typregel in der Herleitung. Wir betrachten hier lediglich die F\"alle der \RN{Equiv}- und \RN{Object'}-Regeln.
  \PROOFCASEbeg
    \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ mit Typregel \RN{Equiv}.

          Nach Voraussetzung existiert ein $\tau'' \in \setType$ mit $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau''}$ und
          $\tau'' \sim \tau'$. Darauf l\"asst sich direkt die Induktionsvoraussetzung anwenden, und es folgt
          \[\begin{array}{l}
            \Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau''}.
          \end{array}\]
          Wegen $\tau'' \sim \tau'$ folgt unmittelbar
          \[\begin{array}{l}
            \Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}
          \end{array}\]
          mit Typregel \RN{Equiv}.

    \item $\Tj{\Gamma\SUB{\tau}{\self}}{\expObject{\self:\tau'}{r''}}{\tau'}$ mit Typregel \RN{Object'}.

          In diesem Fall folgt die Behauptung trivialerweise, da nach Definition~\ref{definition:Lo:Substitution} gilt
          \[\begin{array}{rcl}
            (\expObject{\self:\tau'}{r''})\SUB{\expObject{\self:\tau}{r}}{\self} & = & \expObject{\self:\tau'}{r''},
          \end{array}\]
          und es gilt $\self\not\in\free{\expObject{\self:\tau'}{r''}}$ gem\"a"s
          Definition~\ref{definition:Lo:Frei_vorkommende_Namen}. Mit Lemma~\ref{lemma:Lort:Koinzidenzlemma} folgt dann
          \[\begin{array}{l}
            \Tj{\Gamma}{\expObject{\self:\tau'}{r''}}{\tau'},
          \end{array}\]
          was zu zeigen war.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen wie im Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution}
  f\"ur die Programmiersprache \Lot.
\end{beweis}

Bevor wir nun das Preservation-Theorem f\"ur die Programmiersprache \Lort\ formulieren und beweisen k\"onnen,
ben\"otigen wir \"ahnlich wie im Fall der Typerhaltung der Programmiersprache \Losub\ ein Lemma, welches im
wesentlichen einer Umkehrung der Typrelation entspricht. Dieses Lemma erm\"oglicht eine einfachere Argumentation
in den Beweisen der Preservation- und Progress-Theoreme. Wie zuvor beschr\"anken wir uns auf die Aussagen, die
wir in den nachfolgenden Beweisen ben\"otigen, statt das Lemma in seiner allgemeinsten Form anzugeben.

\begin{lemma}[Umkehrung der Typrelation] \label{lemma:Lort:Umkehrung_der_Typrelation} \
  \begin{enumerate}
    \item Wenn $\Tj{\Gamma}{\op}{\tau}$, dann gilt $\tau \sim \typeIntIntInt$ f\"ur $\op\in\{+,-,*\}$
          oder $\tau \sim \typeIntIntBool$ f\"ur $\op\in\{\le,\ge,<,>,=\}$.
    \item Wenn $\Tj{\Gamma}{\expAbstr{x:\tau_2}{e}}{\tau'}$, dann gilt $\Tj{\Gamma\SUB{\tau_2}{x}}{e}{\tau}$
          mit $\tau' \sim \typeArrow{\tau_2}{\tau}$.
    \item Wenn $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$, dann gilt $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau}}$
          und $\Tj{\Gamma}{e_2}{\tau_2}$.
    \item Wenn $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$, dann gilt $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$
          mit $\typeObject{\phi} \sim \tau' \sim \tau$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Die Beweise f\"uhren wir jeweils durch vollst\"andige Induktion \"uber die L\"ange der Herleitung der
  Typurteile, mit Fallunterscheidung nach der zuletzt angewandten Typregel. Offensichtlich kommen in
  jedem Fall nur exakt zwei Typregeln in Frage.
  \begin{enumerate}
    \item $\Tj{\Gamma}{\op}{\tau}$ kann nur mit einer der Typregeln \RN{Const} oder \RN{Equiv} hergeleitet
          worden sein.
          \PROOFCASEbeg
            \item F\"ur $\Tj{\Gamma}{\op}{\tau}$ mit Typregel \RN{Const} folgt die Behauptung unmittelbar
                  aus der Definition, da die Relation $\sim$ reflexiv ist.

            \item Wenn $\Tj{\Gamma}{\op}{\tau}$ mit Typregel \RN{Equiv} hergeleitet wurde, existiert nach
                  Voraussetzung ein $\tau'\in\setType$ mit $\Tj{\Gamma}{\op}{\tau'}$ und $\tau' \sim \tau$.
                  Da $\sim$ transitiv ist, folgt mit Induktionsvoraussetzung die Behauptung.
          \PROOFCASEend

    \item Eine Herleitung des Typurteils $\Tj{\Gamma}{\expAbstr{x:\tau_2}{e}}{\tau'}$ kann ausschliesslich
          mit Anwendungen von \RN{Abstr} oder \RN{Equiv} enden.
          \PROOFCASEbeg
            \item Endet die Herleitung mit einer Anwendung von \RN{Abstr}, so gilt nach Voraussetzung
                  $\Tj{\Gamma\SUB{\tau_2}{x}}{e}{\tau}$ und $\tau' = \typeArrow{\tau_2}{\tau}$. Also
                  $\tau' \sim \typeArrow{\tau_2}{\tau}$, da $\sim$ reflexiv ist.
            
            \item Im Fall von \RN{Equiv} existiert wieder ein $\tau''\in\setType$, so dass
                  $\Tj{\Gamma}{\expAbstr{x:\tau_2}{e}}{\tau''}$ mit $\tau'' \sim \tau'$ gilt. Nach
                  Induktionsvoraussetzung folgt $\Tj{\Gamma\SUB{\tau_2}{x}}{e}{\tau}$ mit
                  $\tau'' \sim \typeArrow{\tau_2}{\tau}$. Wegen der Transivit\"at von $\sim$
                  folgt also die Behauptung.
          \PROOFCASEend

    \item F\"ur $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ kommen nur die Typregeln \RN{App} und \RN{Equiv} in Frage.
          \PROOFCASEbeg
            \item Im Fall der \RN{App}-Regel folgt die Behauptung unmittelbar aus den Voraussetzungen.

            \item Wurde andererseits $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{Equiv} hergeleitet,
                  so existiert ein $\tau' \in\setType$ mit $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau'}$ und $\tau' \sim \tau$.
                  Nach Induktionsvoraussetzung existiert dann ein $\tau_2\in\setType$ mit
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau'}}$ und $\Tj{\Gamma}{e_2}{\tau_2}$. Wegen $\tau' \sim \tau$
                  gilt nach Lemma~\ref{lemma:Lort:Aequivalenz_Lemma} (\"Aquivalenz-Lemma) ebenfalls
                  $\typeArrow{\tau_2}{\tau'} \sim \typeArrow{\tau_2}{\tau}$, und mit Anwendung der
                  \RN{Equiv}-Regel folgt schliesslich $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau}}$.
          \PROOFCASEend

    \item Das Typurteil $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ kann nur mit einer der Typregeln \RN{Equiv}
          oder \RN{Object'} hergeleitet worden sein.
          \PROOFCASEbeg
            \item F\"ur \RN{Object'} folgt die Behauptung wegen der Reflexivit\"at von $\sim$ bereits aus den Voraussetzung der Regel.

            \item Im Fall von \RN{Equiv} folgt die Behauptung wegen der Transitivit\"at von $\sim$
                  unmittelbar aus der Induktionsvoraussetzung.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}
%
Dank dieses Lemmas k\"onnen wir im Folgenden Anwendungen der \RN{Equiv}-Regel im wesentlichen ignorieren, so dass
sich die Beweise deutlich vereinfachen.

Nach diesen Vorbereitungen k\"onnen wir nun endlich das Preservation-Theorem f\"ur die Programmiersprache
\Lort\ formulieren und beweisen.

\begin{satz}[Typerhaltung, "`Preservation"'] \label{satz:Lort:Preservation} \index{Typsicherheit!Preservation} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv:\forall e,e'\in\setExp:\forall \tau\in\setType:\,
           \Tj{\Gamma^\star}{e}{\tau}\,\wedge\,e \to e'\ \Rightarrow\ \Tj{\Gamma^\star}{e'}{\tau}$
    \item $\forall \Gamma\in\setTEnv:\forall r,r'\in\setRow:\forall \phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\wedge\,r \to r'\ \Rightarrow\ \Tj{\Gamma}{r'}{\phi}$
  \end{enumerate}
\end{satz}

\begin{beweis}
  Wie bereits im Beweis des Preservation-Theorems f\"ur die Programmiersprache \Losub\ (Satz~\ref{satz:Losub:Preservation})
  erfolgt der Beweis durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{\Gamma^\star}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$, mit Fallunterscheidung nach der
  letzten Typregel in der Herleitung. Dies ist notwendig, da die Typregeln der Programmiersprache \Lort, ebenso wie
  die der Sprache \Losub, nicht eindeutigkeit r\"uckw\"artsanwendbar sind\footnote{Genauergesagt, kann auf jeden
  Ausdrucks nicht nur die eigentlich f\"ur diesen Ausdruck vorgesehene Typregel, sondern ebenfalls die \RN{Equiv}-Regel,
  angewandt werden.}.

  Wir betrachten exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur \RN{Const}, \RN{Id}, \RN{Abstr} und \RN{Empty} gilt gem\"a"s Lemma~\ref{lemma:Lo:Werte_und_small_steps}
          $e \not\to$ bzw. $r \not\to$.

    \item $\Tj{\Gamma^\star}{e}{\tau}$ mit Typregel \RN{Equiv}.

          Nach Voraussetzung existiert ein $\tau'\in\setType$, so dass $\Tj{\Gamma^\star}{e}{\tau'}$ mit $\tau' \sim \tau$
          gilt. Mit Induktionsvoraussetzung folgt daraus
          \[\begin{array}{l}
            \Tj{\Gamma^\star}{e'}{\tau'},
          \end{array}\]
          woraus dann wegen $\tau' \sim \tau$ mit Typregel \RN{Equiv} das erwartete Ergebnis
          \[\begin{array}{l}
            \Tj{\Gamma^\star}{e'}{\tau}
          \end{array}\]
          folgt.

    \item $\Tj{\Gamma^\star}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App}.

          Nach Voraussetzung gilt $\Tj{\Gamma^\star}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{\Gamma^\star}{e_2}{\tau_2}$.
          Der small step $\expApp{e_1}{e_2} \to e'$ kann nur mit einer der small step Regeln \RN{App-Left}, \RN{App-Right},
          \RN{Beta-V} oder \RN{Op} hergeleitet worden sein. Entsprechend unterscheiden wir nach der zuletzt angewendeten
          small step Regel:
          \begin{enumerate}
            \item $\expApp{e_1}{e_2} \to e'$ mit \RN{App-Left} impliziert $e' = \expApp{e_1'}{e_2}$ und $e_1 \to e_1'$. Nach
                  Induktionsvoraussetzung folgt $\Tj{\Gamma^\star}{e_1'}{\typeArrow{\tau_2}{\tau}}$, also
                  $\Tj{\Gamma^\star}{\expApp{e_1'}{e_2}}{\tau}$ mit Typregel \RN{App}.

            \item $\expApp{e_1}{e_2} \to e'$ mit small step Regel \RN{App-Right} kann nur aus $e_1\in\setVal$, $e_2 \to e_2'$
                  und $e' = \expApp{e_1}{e_2'}$ folgen. Die Behauptung folgt dann mit Induktionsvoraussetzung und Typregel
                  \RN{App}.

            \item Wenn $\expApp{e_1}{e_2} \to e'$ mit \RN{Beta-V} hergeleitet wurde, gilt $e_1=\expAbstr{x:\tau_1}{e_1'}$
                  und $e_2\in\setVal$, sowie $e'=e_1'\SUB{e_2}{x}$. Nach Lemma~\ref{lemma:Lort:Umkehrung_der_Typrelation}
                  gilt
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star\SUB{\tau_1}{x}}{e_1'}{\tau'}
                  \end{array}\]
                  mit $\typeArrow{\tau_1}{\tau'} \sim \typeArrow{\tau_2}{\tau}$. Nach Definition von $\sim$
                  (\ref{definition:Lort:Typgleichheit}) also insbesondere $\tau_1 \sim \tau_2$ und $\tau' \sim \tau$.
                  Mit Typregel \RN{Equiv} folgt aus $\Tj{\Gamma^\star}{e_2}{\tau_2}$ und $\tau_2 \sim \tau_1$, dass auch
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_2}{\tau_1}
                  \end{array}\]
                  gilt. Nach Substitutionslemma (\ref{lemma:Lort:Typurteile_und_Substitution}) folgt somit
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'\SUB{e_2}{x}}{\tau'},
                  \end{array}\]
                  und wegen $\tau' \sim \tau$ schliesslich
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'\SUB{e_2}{x}}{\tau}
                  \end{array}\]
                  mit Typregel \RN{Equiv}.

            \item $\expApp{e_1}{e_2} \to e'$ mit small step Regel \RN{Op} bedingt $e_1 = \expApp{\op}{v_1}$,
                  $e_2 = v_2 \in \setVal$ und $e' = \op^I(v_1,v_2)$. Mit Lemma~\ref{lemma:Lort:Umkehrung_der_Typrelation} folgt,
                  dass
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op}{\typeArrow{\tau_1}{\typeArrow{\tau_2}{\tau}}}
                  \end{array}\]
                  und
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{v_1}{\tau_1}
                  \end{array}\]
                  gilt. Nach Lemma~\ref{lemma:Lort:Umkehrung_der_Typrelation} folgt weiterhin, dass $\tau_1\sim\typeInt$,
                  $\tau_2\sim\typeInt$, und $\tau\sim\typeInt$ f\"ur $\op\in\{+,-,*\}$ bzw. $\tau\sim\typeBool$ f\"ur
                  $\op\in\{\le,\ge,<,>,=\}$.

                  Sei also $\op\in\{+,-,*\}$, dann gilt $\op^I(v_1,v_2)\in\setInt$. Mit Typregel \RN{Const} folgt
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op^I(v_1,v_2)}{\typeInt},
                  \end{array}\]
                  und wegen $\tau \sim \typeInt$ folgt schliesslich
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op^I(v_1,v_2)}{\tau}
                  \end{array}\]
                  mit Typregel \RN{Equiv}.

                  F\"ur $\op\in\{\le,\ge,<,>,=\}$ folgt die Behauptung analog.
          \end{enumerate}

    \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object'}.

          Der small step $e \to e'$ kann nur mit der small step Regel \RN{Object-Eval} aus $r \to r'$ folgen, und es
          gilt $e' = \expObject{\self:\tau}{r'}$. Nach Voraussetzung existiert ein $\phi \in \setRType$ mit
          \[\begin{array}{l}
            \Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}
          \end{array}\]
          und $\typeObject{\phi} \sim \tau$. Mit Induktionsvoraussetzung folgt daraus
          \[\begin{array}{l}
            \Tj{\Gamma^\star\SUB{\tau}{\self}}{r'}{\phi},
          \end{array}\]
          also mit Typregel \RN{Object'} die Behauptung.

    \item $\Tj{\Gamma^\star}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send}.

          Dann gilt $\Tj{\Gamma^\star}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$. Der small step $\expSend{e_1}{m} \to e'$
          kann nur mit den small step Regeln \RN{Send-Eval} oder \RN{Send-Unfold} hergeleitet worden sein.
          \PROOFCASEbeg
            \item Der small step $\expSend{e_1}{m} \to \expSend{e_1'}{m}$ mit Regel \RN{Send-Eval} kann nur aus
                  $e_1 \to e_1'$ folgen. Nach Induktionsvoraussetzung gilt
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}},
                  \end{array}\]
                  also folgt
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\expSend{e_1'}{m}}{\tau}
                  \end{array}\]
                  mit Typregel \RN{Send}.

            \item $\expSend{e_1}{m} \to e'$ mit \RN{Send-Unfold} bedingt $e_1 = \expObject{\self:\tau_1}{\omega}$ und
                  $e' = \expSend{\omega\SUB{e_1}{\self}}{m}$. Nach Lemma~\ref{lemma:Lort:Umkehrung_der_Typrelation}
                  gilt
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star\SUB{\tau_1}{\self}}{\omega}{\phi_1}
                  \end{array}\]
                  mit $\typeObject{\phi_1} \sim \typeObject{\rtypeMethod{m}{\tau}{\phi}} \sim \tau_1$. Also existieren nach
                  Definition~\ref{definition:Lort:Typgleichheit} $\tau'\in\setType$ und $\phi_1'\in\setRType$ mit
                  $\phi_1 = (\rtypeMethod{m}{\tau'}{\phi_1'})$ und $\tau' \sim \tau$. Nach Voraussetzung gilt schon
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\expObject{\self:\tau_1}{\omega}}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}},
                  \end{array}\]
                  und nach Definition~\ref{definition:Lot:Typumgebungen} gilt $\Gamma^\star = (\Gamma^\star)^\star$, somit also
                  \[\begin{array}{l}
                    \Tj{(\Gamma^\star)^\star}{\expObject{\self:\tau_1}{\omega}}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}.
                  \end{array}\]
                  Wegen $\typeObject{\rtypeMethod{m}{\tau}{\phi}} \sim \tau_1$ folgt daraus 
                  \[\begin{array}{l}
                    \Tj{(\Gamma^\star)^\star}{\expObject{\self:\tau_1}{\omega}}{\tau_1}
                  \end{array}\]
                  mit Typregel \RN{Equiv}. Darauf l\"a"st sich nun das spezielle $\self$-Substitutions-Lemma
                  (\ref{lemma:Lort:Typurteile_und_self_Substitution}) anwenden, und wir erhalten
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\omega\SUB{\expObject{\self:\tau_1}{\omega}}{\self}}{\phi_1}.
                  \end{array}\]
                  Da $\phi_1 = (\rtypeMethod{m}{\tau'}{\phi_1'})$ folgt weiter mit Typregel \RN{Send'}
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\expSend{\omega\SUB{\expObject{\self:\tau_1}{\omega}}{\self}}{m}}{\tau'},
                  \end{array}\]
                  und wegen $\tau' \sim \tau$ folgt schliesslich mit Typregel \RN{Equiv} die Behauptung.
          \PROOFCASEend
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen analog.
\end{beweis}

Damit ist sichergestellt, dass auch im neuen Typsystem mit rekursiven Typen die small step Semantik typerhaltend ist. Zum
Beweis der Typsicherheit der Programmiersprache \Lort\ fehlt damit nur noch das Progress-Theorem. Dazu formulieren wir
zun\"achst eine entsprechende Version des {\em Canonical Forms Lemma} f\"ur die Sprache \Lort. Wie im Fall der
Sprache \Losub\ (siehe Lemma~\ref{lemma:Losub:Canonical_Forms}) beschr\"anken wir uns auf die Aussagen, die wir im Beweis
des nachfolgenden Progress-Theorem benutzen werden.

\begin{lemma}[Canonical Forms] \label{lemma:Lort:Canonical_Forms}
  Sei $v\in\setVal$, $\tau\in\setType$, und gelte $\Tj{[\,]}{v}{\tau}$.
  \begin{enumerate}
    \item Wenn $\tau \sim \typeInt$, dann gilt $v\in\setInt$.

    \item Wenn $\tau \sim \typeArrow{\tau_1}{\tau_2}$, dann gilt eine der folgenden Aussagen:
          \PROOFCASEbeg
            \item $v\in\setOp$
            \item $v=\expApp{\op}{v_1}$ mit $\op\in\setOp$ und $v_1\in\setVal$
            \item $v=\expAbstr{x:\tau_1'}{e}$ mit $x\in\setVar$, $\tau_1'\in\setType$ und $e\in\setExp$
          \PROOFCASEend

    \item Wenn $\tau \sim \typeObject{\phi}$, dann gilt $v=\expObject{\self:\tau'}{\omega}$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Die Beweise der einzelnen Teile des Lemmas erfolgen jeweils durch vollst\"andige Induktion \"uber die L\"ange der
  Herleitung des Typurteils mit Fallunterscheidung nach der letzten Typregel in der Herleitung. Wir betrachten
  lediglich den Beweis des ersten Teils des Lemmas.
  \begin{enumerate}
    \item Das Typurteil $\Tj{[\,]}{v}{\tau}$ mit $\tau \sim \typeInt$ kann nur mit den Typregeln \RN{Const} und
          \RN{Equiv} hergeleitet worden sein, da sich mit den \"ubrigen, auf Werte anwendbaren Typregeln, wie
          zum Beispiel \RN{Abstr}, kein zu $\typeInt$ \"aquivalenter Typ herleiten l\"a"st. Wir haben also lediglich
          die F\"alle f\"ur die \RN{Const}- und \RN{Equiv}-Regeln zu betrachten.
          \PROOFCASEbeg
            \item F\"ur $\Tj{[\,]}{v}{\tau}$ mit \RN{Const} gilt nach Voraussetzung $\tj{v}{\tau}$ und insbesondere
                  $v\in\setConst$. Die einzige in Frage kommende Regel hier ist \RN{Int}, denn von den m\"oglichen
                  Typen von Konstanten ist nach Lemma~\ref{lemma:Lort:Aequivalenz_Lemma} (\"Aquivalenz-Lemma) einzig
                  $\typeInt$ \"aquivalent zu $\typeInt$. Die Regel \RN{Int} wiederum impliziert $v\in\setInt$, was zu zeigen war.

            \item Im Fall von \RN{Equiv} als letzter Typregel folgt die Behauptung unmittelbar mit Induktionsvoraussetzung.
          \PROOFCASEend
  \end{enumerate}
  Die \"ubrigen Teile des Lemmas lassen sich \"ahnlich einfach beweisen.
\end{beweis}
%
Damit sind nun alle Voraussetzungen gegeben, um das Progress-Theorem formulieren und beweisen zu k\"onnen. Der Beweis
ist im wesentlichen identisch zum Beweis des Progress-Theorems f\"ur die Programmiersprache \Losub\ 
(Satz~\ref{satz:Losub:Progress}), da die wesentlichen Details, in denen sich die Sprachen unterscheiden, bereits in
den vorangegangenen Lemmata behandelt werden.

\begin{satz}[Existenz des \"Ubergangsschritts, "`Progress"'] \label{satz:Lort:Progress} \index{Typsicherheit!Progress} \
  \begin{enumerate}
    \item $\forall e\in\setExp, \tau\in\setType:\, \Tj{[\,]}{e}{\tau}
           \,\Rightarrow\,(e\in\setVal\,\vee\,\exists e'\in\setExp: e \to e')$
    \item $\forall \Gamma\in\setTEnv,r\in\setRow, \phi\in\setRType:\, \Tj{\Gamma^+}{r}{\phi}
           \,\Rightarrow\,(r\in\setRVal\,\vee\,\exists r'\in\setRow: r \to r')$
  \end{enumerate}
\end{satz}

\begin{beweis}
  Es sollte keine gro"se \"Uberraschung darstellen, dass der Beweis durch simultane Induktion \"uber die L\"ange der
  Herleitung der Typurteile $\Tj{[\,]}{e}{\tau}$ und $\Tj{\Gamma^+}{r}{\phi}$ erfolgt, wobei jeweils nach der
  zuletzt angewandten Typregel unterschieden wird. Wir betrachten dazu die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur \RN{Const} und \RN{Abstr} gilt $e\in\setVal$, und f\"ur \RN{Empty} gilt $r\in\setRVal$.

    \item $\Tj{[\,]}{e}{\tau}$ mit Typregel \RN{Equiv}.

          Nach Voraussetzung existiert ein $\tau'\in\setType$, so dass gilt $\Tj{[\,]}{e}{\tau'}$ mit $\tau' \sim \tau$.
          Die Behauptung folgt dann unmittelbar mit Induktionsvoraussetzung.

    \item $\Tj{[\,]}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App}.

          Dann muss gelten $\Tj{[\,]}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{[\,]}{e_2}{\tau_2}$, und es
          ist nach der Form der Teilausdr\"ucke $e_1,e_2$ zu unterscheiden.

          Falls $e_1\not\in\setVal$, so existiert nach Induktionsvoraussetzung ein $e_1'\in\setExp$
          mit $e_1 \to e_1'$, und somit ein small step $\expApp{e_1}{e_2} \to \expApp{e_1'}{e_2}$ mit
          small step Regel \RN{App-Left}.

          Entsprechend existiert f\"ur $e_1\in\setVal$ und $e_2\not\in\setVal$ ein small step mit
          Regel \RN{App-Right}.

          Somit bleibt noch der Fall $e_1,e_2\in\setVal$ zu betrachten. Nach Canonical Forms Lemma
          (\ref{lemma:Lort:Canonical_Forms}) sind wegen $\Tj{[\,]}{e_1}{\typeArrow{\tau_2}{\tau}}$ und
          der Reflexivit\"at von $\sim$ f\"ur $e_1$ die folgenden drei F\"alle zu unterscheiden:
          \begin{enumerate}
            \item $e_1 \in \setOp$

                  Dann gilt nach Definition~\ref{definition:Lo:Werte_und_Reihenwerte} $\expApp{e_1}{e_2}\in\setVal$.

            \item $e_1 = \expApp{\op}{v_1}$ mit $\op\in\setOp$ und $v_1 \in \setVal$

                  Nach Lemma~\ref{lemma:Lort:Umkehrung_der_Typrelation} existiert ein $\tau_1\in\setType$ mit
                  $\Tj{[\,]}{\op}{\typeArrow{\tau_1}{\typeArrow{\tau_2}{\tau}}}$
                  und $\Tj{[\,]}{v_1}{\tau_1}$.
                  Nach Definition~\ref{definition:Lot:Typurteile_fuer_Konstanten} folgt mit dem \"Aquivalenz-Lemma
                  (\ref{lemma:Lort:Aequivalenz_Lemma}) $\tau_1 \sim \typeInt$ und $\tau_2 \sim \typeInt$,
                  also $v_1,e_2\in\setInt$ nach Lemma~\ref{lemma:Lort:Canonical_Forms}. Somit existiert ein
                  small step $\expApp{\expApp{\op}{v_1}}{e_2} \to \op^I(v_1,e_2)$ mit small step Regel \RN{Op}.

            \item F\"ur $e_1 = \expAbstr{x:\tau_2'}{e_1'}$ existiert ein small step
                  $\expApp{(\expAbstr{x:\tau_2'}{e_1'})}{e_2} \to e_1'\SUB{e_2}{x}$ mit Regel
                  \RN{Beta-V}, da nach Voraussetzung $e_2\in\setVal$.
          \end{enumerate}

    \item $\Tj{[\,]}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send}.

          Das kann nur aus $\Tj{[\,]}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$ folgen, und nach
          Induktionsvoraussetzung gilt entweder $e_1\in\setVal$ oder es existiert ein $e_1'\in\setExp$ mit
          $e_1 \to e_1'$.

          Sei also $e_1\in\setVal$, dann gilt nach Lemma~\ref{lemma:Lort:Canonical_Forms}, dass
          $e_1 = \expObject{\self:\typeObject{\phi}}{\omega}$. Also existiert ein small step
          \[\begin{array}{l}
            \expSend{(\expObject{\self:\typeObject{\phi}}{\omega})}{m} \to \expSend{\omega\SUB{e_1}{\self}}{m}
          \end{array}\]
          mit small step Regel \RN{Send-Unfold}.

          Ist andererseits $e_1\not\in\setVal$, so existiert ein small step
          \[\begin{array}{l}
            \expSend{e_1}{m}\to\expSend{e_1'}{m}
          \end{array}\]
          mit small step Regel \RN{Send-Eval}.

    \item $\Tj{\Gamma^+}{\rowVal{a}{e'}{r'}}{\phi}$ mit Typregel \RN{Attr}.

          Das Typurteil kann nur aus Pr\"amissen der Form $\Tj{(\Gamma^+)^\star}{e'}{\tau'}$ und
          $\Tj{\Gamma^+}{r'}{\phi'}$ folgen, wobei zu beachten gilt, dass $(\Gamma^+)^\star = [\,]$.
          Nach Induktionsvoraussetzung gilt dann entweder $e'\in\setVal$ oder es existiert ein
          $e''\in\setExp$ mit $e' \to e''$. Ebenso gilt entweder $r'\in\setRVal$ oder existiert ein
          $r''\in\setRow$ mit $r' \to r''$.

          Seien $e'\in\setVal$ und $r'\in\setRVal$, dann gilt $(\rowVal{a}{e'}{r'})\in\setRVal$
          nach Definition~\ref{definition:Lo:Werte_und_Reihenwerte}.

          Falls $e'\not\in\setVal$, also $e' \to e''$, so existiert ein small step
          \[\begin{array}{l}
            \rowVal{a}{e'}{r'} \to \rowVal{a}{e''}{r'}
          \end{array}\]
          mit small step Regel \RN{Attr-Left}.

          Analog existiert f\"ur $e'\in\setVal$ und $r'\not\in\setRVal$, also $r' \to r''$, ein small step
          \[\begin{array}{l}
            \rowVal{a}{e'}{r'} \to \rowVal{a}{e'}{r''}
          \end{array}\]
          mit Regel \RN{Attr-Right}.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen analog.
\end{beweis}
%
Mit diesen Ergebnissen k\"onnen wir nun wiederum leicht die Typsicherheit der Programmiersprache \Lort\ zeigen,
da sich der Beweis des nachfolgenden Satzes analog zum Beweis des Safety-Theorems der Sprache \Lot\ (Satz~\ref{satz:Lot:Safety})
unmittelbar aus dem Preservation- und Progress-Theorem ergibt.

\begin{satz}[Typsicherheit, "`Safety"'] \label{satz:Lort:Safety} \index{Typsicherheit!Safety}
  Wenn $\Tj{[\,]}{e}{\tau}$, dann bleibt die Berechnung f\"ur $e$ nicht stecken.
\end{satz}

\begin{beweis}
  Folgt analog wie f\"ur \Lot\ aus den Preservation und Progress-S\"atzen.
\end{beweis}


{\bf TODO:} Algorithmus!



%%%%%%%%%%%%%%%%%%%%%%%
%% Die Sprache Losrt %%
%%%%%%%%%%%%%%%%%%%%%%%

\section{Die Sprache \Losrt}

Abschliessend wollen wir betrachten, in wie weit sich die beiden bisher betrachteten Erweiterungen des Typsystems
-- Subtyping und rekursive Typen -- in einer objekt-orientierten Programmiersprache kombinieren lassen.

{\bf TODO:} Mehr Prosa

\begin{definition} \label{definition:Losrt:Subtyping_Relation}
  Die Relationen $\simle_n$ seien wie folgt induktiv definiert
  \[\begin{array}{rcl}
    \simle_0     &   =  & \setType^2 \\
    \simle_{n+1} &   =  & \{(\tau,\tau')\in\setType^2\ |\ \TREEroot{\tau} = \TREEroot{\tau'} \in \{\typeBool,\typeInt,\typeUnit\}\} \\
                 & \cup & \{(\tau,\tau')\in\setType^2\ |\ \TREEroot{\tau} = \TREEroot{\tau'} =\ \to \\
                 &      & \quad \wedge\,\TREEchild{1}{\tau'} \simle_n \TREEchild{1}{\tau}
                              \,\wedge\,\TREEchild{2}{\tau} \simle_n \TREEchild{2}{\tau'}\} \\
                 & \cup & \{(\tau,\tau')\in\setType^2\ |\ \TREEroot{\tau} = \typeObject{m_1;\ldots;m_{k+l}}
                                                \,\wedge\,\TREEroot{\tau'} = \typeObject{m_1;\ldots;m_k} \\
                 &      & \quad \wedge\,\forall 1 \le i \le k:\,\TREEchild{i}{\tau} \simle_n \TREEchild{i}{\tau'}\} 
  \end{array}\]
  und die Relation $\simle$ ist durch
  \[\begin{array}{rcl}
    \simle & = & \bigcap\limits_{n\in\setN} \simle_n
  \end{array}\]
  definiert, also als Durchschnitt aller Relationen $\simle_n$.
\end{definition}

{\bf TODO:} \"Uberleitung, Vergleich mit Minimal Typing Subtypregeln (Sm-Refl, Sm-Arrow und Sm-Object)

\begin{lemma} \label{lemma:Losrt:Quasiordnung}
  Die Relation $\simle$ ist eine Quasiordnung.
\end{lemma}
%
Im Gegensatz zur Subtyprelation in Kapitel~\ref{kapitel:Subtyping} (vgl. Definition~\ref{definition:Subtyping:Subtyping_Regeln})
begn\"ugen wir uns in diesem Fall mit einer Quasiordnung, da wir die Eigenschaft der Antisymmetrie nicht zwingend ben\"otigen
zum Beweis der Typsicherheit. Stattdessen formulieren wir sp\"ater ein Lemma, welches den Zusammenhang zwischen den Relationen
$\sim$ und $\simle$ darstellt. Diese Eigenschaft entspricht im weiteren Sinne einer Antisymmetrie f\"ur die Relation
$\simle$.

\begin{beweis}
  Analog zum Beweis von Lemma~\ref{lemma:Lort:Aequivalenzrelation} gen\"ugt es zu zeigen, dass jede Relation
  $\simle_n$ eine Quasiordnung ist, denn der Schnitt von Quasiordnungen ist wiederum eine Quasiordnung. Dazu
  zeigen wir durch vollst\"andige Induktion \"uber $n$, dass alle $\simle_n$ reflexiv und transitiv sind.
  \begin{itemize}
    \item $n = 0$

          Da $\simle_0\,=\setType^2$ ist klar, dass $\simle_0$ reflexiv und transitiv ist.

    \item $n \leadsto n+1$

          Nach Induktionsvoraussetzung ist $\simle_n$ reflexiv und transitiv. Damit zeigen wir, dass auch
          $\simle_{n+1}$ reflexiv und transitiv ist. Konkret zeigen wir lediglich die Transitivit\"at von
          $\simle_{n+1}$, da die Reflexivit\"at trivialerweise erf\"ullt ist.

          Seien also $(\tau_1,\tau_2)\in\ \simle_{n+1}$ und $(\tau_2,\tau_3)\in\ \simle_{n+1}$. Dann unterscheiden
          wir nach der Form von $\TREEroot{\tau_2}$:
          \PROOFCASEbeg
            \item $\TREEroot{\tau_2} \in \{\typeBool,\typeInt,\typeUnit\}$

                  Dann gilt $\TREEroot{\tau_1} = \TREEroot{\tau_2} = \TREEroot{\tau_3}$, also auch
                  $(\tau_1,\tau_3)\in\ \simle_{n+1}$.

            \item $\TREEroot{\tau_2} =\ \to$

                  Dann gilt wieder $\TREEroot{\tau_1} = \TREEroot{\tau_2} = \TREEroot{\tau_3}$. Weiterhin gelten
                  die folgenden Ungleichungen:
                  \[\begin{array}{rclcrcl}
                    \TREEchild{1}{\tau_2} & \simle_n & \TREEchild{1}{\tau_1}
                    & \quad \quad &
                    \TREEchild{2}{\tau_1} & \simle_n & \TREEchild{2}{\tau_2} \\
                    \TREEchild{1}{\tau_3} & \simle_n & \TREEchild{1}{\tau_2}
                    & \quad \quad &
                    \TREEchild{2}{\tau_2} & \simle_n & \TREEchild{2}{\tau_3}
                  \end{array}\]
                  Wegen der nach Induktionsvoraussetzung geltenden Transitivit\"at von $\simle_n$ folgt damit,
                  dass auch die Ungleichungen
                  \[\begin{array}{rcl}
                    \TREEchild{1}{\tau_3} & \simle_n & \TREEchild{1}{\tau_1} \\
                    \TREEchild{2}{\tau_1} & \simle_n & \TREEchild{2}{\tau_3}
                  \end{array}\]
                  gelten, und somit $(\tau_1,\tau_3)\in\ \simle_{n+1}$ nach Definition~\ref{definition:Losrt:Subtyping_Relation}.

            \item $\TREEroot{\tau_2} = \typeObject{m_1;\ldots;m_k}$
            
                  Dann existieren f\"ur $\tau_1$ und $\tau_3$ nach Definition $j,k\in\setN$ mit $j \le k \le l$, so dass
                  $\TREEroot{\tau_1} = \typeObject{m_1;\ldots;m_l}$ und $\TREEroot{\tau_3} = \typeObject{m_1;\ldots;m_j}$.
                  Weiterhin gilt
                  \[\begin{array}{l}
                    \forall 1 \le i \le k:\ \TREEchild{i}{\tau_1} \simle_n \TREEchild{i}{\tau_2}
                  \end{array}\]
                  und
                  \[\begin{array}{l}
                    \forall 1 \le i \le j:\ \TREEchild{i}{\tau_2} \simle_n \TREEchild{i}{\tau_3}.
                  \end{array}\]
                  Da $j \le k$ und $\simle_n$ als transitiv angenommen wurde, folgt
                  \[\begin{array}{l}
                    \forall 1 \le i \le j:\ \TREEchild{i}{\tau_1} \simle_n \TREEchild{i}{\tau_3}.
                  \end{array}\]
                  und somit unmittelbar $(\tau_1,\tau_3)\in\ \simle_{n+1}$.
          \PROOFCASEend
  \end{itemize}
  Damit ist gezeigt, dass die Menge $\setType$ durch die Relation $\simle$, sowie die Relationen $\simle_n$, quasi geordnet ist.
\end{beweis}

Damit kommen wir nun zum bereits angesprochenen Lemma \"uber den Zusammenhang zwischen Typgleichheit und Subtyping bei
rekursiven Typen. Wir werden zeigen, dass die Relation $\simle$ bez\"uglich der Relation $\sim$ antisymmetrisch ist.

\begin{lemma} \label{lemma:Losrt:Antisymmetrie}
  $\forall \tau,\tau'\in\setType:\ \tau \simle \tau' \wedge \tau' \simle \tau\ \Leftrightarrow\ \tau\sim\tau'$
\end{lemma}

\begin{beweis}
  Es gen\"ugt zu zeigen, dass die Aussage
  \[\begin{array}{l}
    \forall \tau,\tau'\in\setType:\ \tau \simle_n \tau' \wedge \tau' \simle_n \tau\ \Leftrightarrow\ \tau\sim_n\tau'
  \end{array}\]
  f\"ur alle $n\in\setN$ gilt, da die Relationen $\sim$ und $\simle$ beide als Schnitt der induktiv definierten
  Relationen $\sim_n$ und $\simle_n$ definiert sind.
  \begin{enumerate}
    \item["`$\Leftarrow$"']

          Wir beweisen die Behauptung durch vollst\"andige Induktion \"uber $n$.
          \begin{itemize}
            \item $n = 0$

                  Klar, denn es gilt $\sim_0\ = \setType^2 =\ \simle_0$.

            \item $n \leadsto n+1$

                  F\"ur $\tau \sim_{n+1} \tau'$ muss nach Voraussetzung
                  \[\begin{array}{l}
                    \TREEroot{\tau} = \TREEroot{\tau'}
                  \end{array}\]
                  und
                  \[\begin{array}{l}
                    \forall 1 \le i \le \TREEarity{\tau}:\ \TREEchild{i}{\tau} \sim_n \TREEchild{i}{\tau'}
                  \end{array}\]
                  gelten. Nach Induktionsvoraussetzung folgt daraus, dass
                  \[\begin{array}{l}
                    \forall 1 \le i \le \TREEarity{\tau}:\ \TREEchild{i}{\tau} \simle_n \TREEchild{i}{\tau'}
                                                    \wedge \TREEchild{i}{\tau'} \simle_n \TREEchild{i}{\tau}.
                  \end{array}\]
                  gilt. Damit folgt insgesamt die Behauptung mit einer einfachen Fallunterscheidung nach der Form von
                  $\TREEroot{\tau}$ und Anwenden der Definition von $\simle_{n+1}$ (\ref{definition:Losrt:Subtyping_Relation}).
          \end{itemize}

    \item["`$\Rightarrow$"']

          Auch diese Implikation beweisen wir durch vollst\"andige Induktion \"uber $n$:
          \begin{itemize}
            \item $n=0$

                  Klar, da $\simle_0\ = \setType\times\setType =\ \sim_0$.

            \item $n\leadsto{n+1}$

                  Seien $\tau,\tau'\in\setType$, und gelte sowohl $\tau \simle_{n+1} \tau'$ als auch
                  $\tau' \simle_{n+1} \tau$. Dann zeigen wir abh\"angig von der Form von $\TREEroot{\tau}$,
                  dass auch $\tau \sim_{n+1} \tau'$ gilt:
                  \PROOFCASEbeg
                    \item $\TREEroot{\tau} = \TREEroot{\tau'} \in \{\typeBool,\typeInt,\typeUnit\}$

                          Trivial.

                    \item $\TREEroot{\tau} = \TREEroot{\tau'} =\ \to$

                          Dann gelten nach Voraussetzung die folgenden Ungleichungen:
                          \[\begin{array}{rclcrcl}
                            \TREEchild{1}{\tau'} & \simle_n & \TREEchild{1}{\tau}
                            & \quad \quad &
                            \TREEchild{2}{\tau} & \simle_n & \TREEchild{2}{\tau'} \\
                            \TREEchild{1}{\tau} & \simle_n & \TREEchild{1}{\tau'}
                            & \quad \quad &
                            \TREEchild{2}{\tau'} & \simle_n & \TREEchild{2}{\tau}
                          \end{array}\]
                          Darauf nun l\"a"st sich die Induktionsvoraussetzung anwenden, und wir erhalten
                          \[\begin{array}{rcl}
                            \TREEchild{1}{\tau} & \sim_n & \TREEchild{1}{\tau'}
                          \end{array}\]
                          und
                          \[\begin{array}{rcl}
                            \TREEchild{2}{\tau} & \sim_n & \TREEchild{2}{\tau'},
                          \end{array}\]
                          woraus dann nach Definition von $\sim_{n+1}$ unmittelbar die Behauptung folgt.

                    \item $\TREEroot{\tau} = \typeObject{m_1;\ldots;m_k}, \TREEroot{\tau'} = \typeObject{m_1;\ldots;m_l}$

                          Da sowohl $\tau \simle_{n+1} \tau'$ wie auch $\tau' \simle_{n+1} \tau$ gilt, muss $k=l$
                          gelten, und die Behauptung folgt dann analog zum vorangegangenen Fall.
                  \PROOFCASEend
          \end{itemize}
  \end{enumerate}
\end{beweis}
%
Genaugenommen ist das Lemma sogar eine st\"arkere Aussage. F\"ur die eigentliche Antisymmetrie w\"urde eine
Implikation, wie im folgenden Korollar dargestellt, gen\"ugen.

\begin{korollar}
  $\forall \tau,\tau'\in\setType:\ \tau \simle \tau' \wedge \tau' \simle \tau\ \Rightarrow\ \tau\sim\tau'$
\end{korollar}

\begin{beweis}
  Folgt direkt aus Lemma~\ref{lemma:Losrt:Antisymmetrie}.
\end{beweis}

{\bf TODO:} Prosa

\begin{definition} \label{definition:Losrt:Abbildung_S}
  Sei $\mathcal{S}: \setTypeRel \to \setTypeRel$ definiert durch
  \[\begin{array}{rcl}
    \mathcal{S}(R)
    &   =  & \{(\tau,\tau')\in\setType^2\,|\,\TREEroot{\tau}=\TREEroot{\tau'}\in\{\typeBool,\typeInt,\typeUnit\}\} \\
    & \cup & \{(\tau,\tau')\in\setType^2\ |\ \TREEroot{\tau} = \TREEroot{\tau'} =\ \to \\
    &      & \quad \wedge\,(\TREEchild{1}{\tau'},\TREEchild{1}{\tau})\in R
                 \,\wedge\,(\TREEchild{2}{\tau},\TREEchild{2}{\tau'})\in R\} \\
    & \cup & \{(\tau,\tau')\in\setType^2\ |\ \TREEroot{\tau} = \typeObject{m_1;\ldots;m_{k+l}}
                                   \,\wedge\,\TREEroot{\tau'} = \typeObject{m_1;\ldots;m_k} \\
    &      & \quad \wedge\,\forall 1 \le i \le k:\,(\TREEchild{i}{\tau},\TREEchild{i}{\tau'})\in R\},
  \end{array}\]
  also eine totale Abbildung auf bin\"aren Typrelationen.
\end{definition}

Wir wollen wieder zeigen, dass die Typrelation $\simle$ ein Fixpunkt der Abbildung $\mathcal{S}$ ist. F\"ur die
Programmiersprache \Lort\ hatten wir bereits bewiesen, dass $(\setTypeRel,\supseteq)$ eine dcpo mit einem kleinstem
Element $\setType\times\setType$ ist (Lemma~\ref{lemma:Lort:dcpo_und_Stetigkeit}). F\"ur die Anwendung des Fixpunktsatzes
von Kleene bleibt hier also lediglich zu zeigen, dass die Abbildung $\mathcal{S}$ stetig ist.

\begin{lemma} \label{lemma:Losrt:Stetigkeit}
  $\mathcal{S}$ ist eine stetige Abbildung auf $(\setTypeRel,\supseteq)$.
\end{lemma}

\begin{beweis}
  Wie zuvor im Beweis des Lemmas f\"ur die Programmiersprache \Lort\ (Lemma~\ref{lemma:Lort:dcpo_und_Stetigkeit}) zeigen wir
  zun\"achst, dass $\mathcal{S}$ eine monotone Abbildung auf $(\setTypeRel,\supseteq)$ ist. Seien dazu wieder $R_1,R_2\in\setTypeRel$
  mit $R_1 \supseteq R_2$. Dann ist zu zeigen, dass f\"ur alle
  $(\tau,\tau')\in\mathcal{S}(R_2)$ auch $(\tau,\tau')\in\mathcal{S}(R_1)$ gilt. Wir unterscheiden dazu wieder
  nach der Form von $\TREEroot{\tau}$.
  \PROOFCASEbeg
    \item $\TREEroot{\tau} \in \{\typeBool,\typeInt,\typeUnit\}$

          Dann ist $\TREEroot{\tau} = \TREEroot{\tau'}$, und nach Definition~\ref{definition:Losrt:Abbildung_S} gilt
          $(\tau,\tau')\in\mathcal{S}(R)$ f\"ur alle $R\in\setTypeRel$, also insbesondere $(\tau,\tau')\in\mathcal{S}(R_1)$.

    \item $\TREEroot{\tau} =\ \to$

          Nach Definition~\ref{definition:Losrt:Abbildung_S} gilt wieder $\TREEroot{\tau} = \TREEroot{\tau'}$,
          $\bigl(\TREEchild{1}{\tau'},\TREEchild{1}{\tau}\bigr)\in{R_2}$ sowie
          $\bigl(\TREEchild{2}{\tau},\TREEchild{2}{\tau'}\bigr)\in{R_2}$. Also insbesondere
          $\bigl(\TREEchild{1}{\tau'},\TREEchild{1}{\tau}\bigr)\in{R_1}$ und
          $\bigl(\TREEchild{2}{\tau},\TREEchild{2}{\tau'}\bigr)\in{R_1}$, denn es gilt $R_2 \subseteq R_1$, und
          somit folgt die Behauptung unmittelbar nach Definition.

    \item $\TREEroot{\tau} = \typeObject{m_1;\ldots;m_{k+l}}$

          Folgt analog zum vorangegangenen Fall.
  \PROOFCASEend

  Damit bleibt zum Beweis der Stetigkeit von $\mathcal{S}$ zu zeigen, dass
  \[\begin{array}{rcl}
    \mathcal{S}(\bigsqcup \Delta) & \supseteq & \bigsqcup \mathcal{S}(\Delta)
  \end{array}\]
  f\"ur alle gerichteten Teilmengen $\Delta\subseteq\setTypeRel$ gilt. Sei also
  wieder $\Delta\subseteq\setTypeRel$ eine gerichtete Teilmenge und sei
  $(\tau,\tau')\in\bigcap \mathcal{S}(\Delta) = \bigcap \{\mathcal{S}(R)\,|\,R\in\Delta\}$,
  also $(\tau,\tau')\in\mathcal{S}(R)$ f\"ur alle $R\in\Delta$. Durch Fallunterscheidung nach
  der Form von $\TREEroot{\tau}$ zeigen wir, dass dann auch $(\tau,\tau')\in\mathcal{S}(\bigcap \Delta)$ gilt:
  \PROOFCASEbeg
    \item $\TREEroot{\tau}\in\{\typeBool,\typeInt,\typeUnit\}$

          Klar.

    \item $\TREEroot{\tau}=\ \to$

          Dann ist $\TREEroot{\tau} = \TREEroot{\tau'}$ und f\"ur alle $R\in\Delta$ gilt
          $\bigl(\TREEchild{1}{\tau'},\TREEchild{1}{\tau}\bigr)\in{R}$ sowie
          $\bigl(\TREEchild{2}{\tau},\TREEchild{2}{\tau'}\bigr)\in{R}$. Das bedeutet aber insbesondere, dass dann
          $\bigl(\TREEchild{1}{\tau'},\TREEchild{1}{\tau}\bigr),
           \bigl(\TREEchild{2}{\tau},\TREEchild{2}{\tau'}\bigr)\in\bigcap\Delta$ gilt, also folgt nach
          Definition~\ref{definition:Losrt:Abbildung_S}, dass auch $(\tau,\tau')\in\mathcal{S}(\bigcap\Delta)$ gilt.

    \item $\TREEroot{\tau}=\typeObject{m_1;\ldots;m_{k+l}}$

          Folgt wieder analog zum vorherigen Fall.
  \PROOFCASEend
\end{beweis}
%
Damit l\"a"st sich nun das Fixpunkt-Lemma f\"ur die Relation $\simle$ formulieren und beweisen,
analog zum Fixpunkt-Lemma f\"ur die Programmiersprache \Lort\ (\ref{lemma:Lort:Fixpunkt_Lemma}),
welches uns einen einfacheren Umgang mit der Subtyprelation $\simle$ erm\"oglichen soll.

\begin{lemma}[Fixpunkt-Lemma f\"ur \Losrt] \label{lemma:Losrt:Fixpunkt_Lemma}
  $\mu\mathcal{S}=\ \simle$
\end{lemma}

In Worten also, die Subtyprelation $\simle$ ist der kleinste Fixpunkt der generierenden Funktion $\mathcal{S}$.

\begin{beweis}
  Nach Lemma~\ref{lemma:Lort:dcpo_und_Stetigkeit} ist $(\setTypeRel,\supseteq)$ ein semantischer Bereich,
  und nach Lemma~\ref{lemma:Losrt:Stetigkeit} ist die totale Abbildung $\mathcal{S}$ stetig auf
  $(\setTypeRel,\supseteq)$. Damit l\"asst sich Satz~\ref{satz:math:Fixpunktsatz_von_Kleene} (Fixpunktsatz von Kleene)
  anwenden, nach dem mit $\mu\mathcal{S} = \bigsqcup_{n\in\setN} \mathcal{S}^n(\setType \times \setType)$ der kleinste Fixpunkt
  von $\mathcal{S}$ existiert. Es bleibt also zu zeigen, dass die Relation $\simle$ gerade diesem Fixpunkt entspricht.

  Dazu zeigen wir zun\"achst durch vollst\"andige Induktion, dass $\simle_n\ = \mathcal{S}^n(\setType \times \setType)$ gilt:
  \begin{itemize}
    \item $n = 0$

          Klar, da $\simle_0\ = \setType \times \setType = \mathcal{S}^0(\setType \times \setType)$.

    \item $n \leadsto n+1$

          Nach Induktionsvoraussetzung gilt $\simle_n\ = \mathcal{S}^n(\setType \times \setType)$. Damit folgt
          trivialerweise die Behauptung, da die Definition von $\simle_{n+1}$ unter dieser Voraussetzung mit
          der Definition von $\mathcal{S}$ \"ubereinstimmt.
  \end{itemize}
  Damit erhalten wir
  $\simle\ 
   = \bigcap_{n\in\setN} \mathcal{S}^n(\setType \times \setType)
   = \bigsqcup_{n\in\setN} \mathcal{S}^n(\setType \times \setType)$,
  was zu zeigen war.
\end{beweis}

\begin{korollar}
  Die Relation $\simle$ ist bez\"uglich $\subseteq$ der gr\"o"ste Fixpunkt von $\mathcal{S}$.
\end{korollar}

\begin{beweis}
  Klar.
\end{beweis}

Das vorangegangene Fixpunkt-Lemma l\"a"st sich auch in einer vertrauteren Form darstellen, die wir
bereits f\"ur die Programmiersprache \Losub\ kennengelernt haben (siehe Lemma~\ref{lemma:Subtyping:Subtyping_Lemma}).

\begin{lemma}[Subtyping-Lemma f\"ur \Losrt] \label{lemma:Losrt:Subtyping_Lemma}
  $\tau \simle \tau'$ gilt genau dann, wenn eine der folgenden Aussagen zutrifft:
  \begin{enumerate}
    \item $\tau \sim \tau' \sim \tau_\beta$ mit $\tau_\beta \in \{\typeBool,\typeInt,\typeUnit\}$
    \item $\tau \sim \typeArrow{\tau_1}{\tau_2}$ und $\tau' \sim \typeArrow{\tau_1'}{\tau_2'}$ mit
          $\tau_1' \simle \tau_1$ und $\tau_2 \simle \tau_2'$
    \item $\tau \sim \typeObject{m_1:\tau_1;\ldots;m_{k+l}:\tau_{k+l}}$ und
          $\tau' \sim \typeObject{m_1:\tau_1';\ldots;m_k:\tau_k'}$ mit
          $\tau_i \simle \tau_i'$ f\"ur alle $i=1,\ldots,k$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Folgt unmittelbar aus der Tatsache, dass die Subtyprelation $\simle$ Fixpunkt der stetigen Abbildung $\mathcal{S}$ ist
  (Lemma~\ref{lemma:Losrt:Fixpunkt_Lemma}), denn die Aussagen des Lemmas entsprechen genau der Definition der Abbildung
  $\mathcal{S}$.
\end{beweis}

Bevor wir nun die Typsicherheit der Programmiersprache \Losrt\ betrachten, m\"ussen wir noch die
Typregeln f\"ur das Typsystem festlegen. Im wesentlichen handelt es sich beim Typsystem von \Losrt\ 
um eine Kombination der Typsysteme der Programmiersprachen \Losub\ und \Lort. Entsprechend sieht
die Definition der g\"ultigen Typurteile f\"ur \Losrt\ bekannt aus:

\begin{definition}[G\"ultige Typurteile f\"ur \Losrt] \label{definition:Losrt:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Losrt}
  Ein Typurteil $\Tje{\Gamma}{e}{\tau}$ oder $\Tjr{\Gamma}{r}{\phi}$ heisst {\em g\"ultig} f\"ur
  \Losrt, wenn es sich mit den Typregeln der Programmiersprache \Lort\ aus
  Definition~\ref{definition:Lort:Gueltige_Typurteile} mit Ausnahme der \RN{Equiv}-Regel, sowie
  der folgenden neuen Typregel \\[5mm]
  \begin{tabular}{ll}
    \RN{Subsume'}  & $\RULE{\Tje{\Gamma}{e}{\tau'} \quad \tau' \simle \tau}
                           {\Tje{\Gamma}{e}{\tau}}$
  \end{tabular} \\[7mm]
  herleiten l\"asst.
\end{definition}


%%%%%%%%%%%%%%%%%%%
%% Typsicherheit %%
%%%%%%%%%%%%%%%%%%%

\subsection{Typsicherheit}
\index{Typsicherheit!Subtyping}

Intuitiv l\"asst sich bereits vermuten, dass die Programmiersprache \Losrt\ ebenfalls typsicher ist,
da das Typsystem im wesentlichen durch Zusammenf\"uhrung der Typsysteme der Programmiersprachen
\Losub\ und \Lort\ entstanden ist. Allerdings ist diese Eigenschaft deshalb noch nicht zwingend
trivial ersichtlich, denn es existieren Programme, die zwar in \Losrt\ wohlgetypt sind, jedoch
weder in \Losub\ noch in \Lort.

Also beweisen wir in diesem Abschnitt zun\"achst wiederum die Preservation- und Progress-S\"atze,
f\"ur die Programmiersprache \Losrt, womit dann gezeigt w\"are, dass auch die kombinierte Programmiersprache
noch immer typsicher ist. Dazu beginnen wir wie gehabt mit einigen technischen Lemmata, wobei wir die
Beweise, sofern sie keine neuen Erkenntnisse zu Tage f\"ordern, im wesentlichen \"uberspringen.

\begin{lemma}[Typumgebungen und frei vorkommende Namen] \label{lemma:Losrt:free_und_dom_Gamma} \
  \begin{enumerate}
    \item $\forall \Gamma \in \setTEnv, e\in\setExp,\tau\in\setType:\,
           \Tj{\Gamma}{e}{\tau}\,\Rightarrow\,\free{e}\subseteq\dom{\Gamma}$
    \item $\forall \Gamma \in \setTEnv, r\in\setRow,\phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\Rightarrow\,\free{r}\subseteq\dom{\Gamma}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wie zuvor verl\"auft der Beweis durch Induktion \"uber die L\"ange der Herleitung der Typurteile.
  Die bekannten F\"alle folgen wie gehabt, der neue Fall der \RN{Subsume'}-Regel folgt unmittelbar
  mit Induktionsvoraussetzung.
\end{beweis}

\begin{lemma}[Koinzidenzlemma f\"ur \Losrt] \label{lemma:Losrt:Koinzidenzlemma} \
  \begin{enumerate}
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, e \in \setExp, \tau \in \setType:\,
           \Tj{\Gamma_1}{e}{\tau}\,\wedge\,\Gamma_1 =_{\free{e}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{e}{\tau}$
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, r \in \setRow, \phi \in \setRType:\,
           \Tj{\Gamma_1}{r}{\phi}\,\wedge\,\Gamma_1 =_{\free{r}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{r}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Ebenfalls wie gehabt, wobei der Fall der \RN{Subsume'}-Regel direkt mit Induktionsvoraussetzung folgt.
\end{beweis}
%
Wie zuvor ben\"otigen wir wieder zwei Substitutionslemmata, ein allgemeines f\"ur Attribute und
Variablen, und ein spezielles f\"ur die $\self$-Substitution.

\begin{lemma}[Typurteile und Substitution] \label{lemma:Losrt:Typurteile_und_Substitution}
  Sei $\id \in \setAttribute \cup \setVar$, $\Gamma \in \setTEnv$, $\tau \in \setType$
  und $e \in \setExp$. Dann gilt:
  \begin{enumerate}
    \item $\forall e' \in \setExp:
           \forall \tau' \in \setType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$
    \item $\forall r \in \setRow:
           \forall \phi \in \setRType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{r\SUB{e}{\id}}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  \"Ahnlich wie im Beweis des Lemmas f\"ur die Programmiersprache \Lort\ (\ref{lemma:Lort:Typurteile_und_Substitution}),
  wobei der Fall der \RN{Subsume'}-Regel ebenfalls trivialerweise mit Induktionsvoraussetzung folgt.
\end{beweis}

\begin{lemma}[Typurteile und $\self$-Substitution] \label{lemma:Losrt:Typurteile_und_self_Substitution}
  Sei $\Gamma \in \setTEnv$, $\self\in\setSelf$,\linebreak[4] $\tau\in\setType$ und $r\in\setRow$. Dann gilt:
  \renewcommand{\labelenumii}{(\arabic{enumii})}
  \begin{enumerate}
    \item F\"ur alle $e\in\setExp$ und $\tau'\in\setType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          \end{enumerate}

    \item F\"ur alle $r'\in\setRow$ und $\phi\in\setRType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r \oplus r'}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{r'\SUB{\expObject{\self:\tau}{r \oplus r'}}{\self}}{\phi}$
          \end{enumerate}
  \end{enumerate}
  \renewcommand{\labelenumii}{\arabic{enumii}.}
\end{lemma}

\begin{beweis}
  Der Beweis entspricht ebenfalls im wesentlichen den Beweisen des Lemmas f\"ur zuvor behandelte Programmiersprachen.
  Wie fr\"uher folgt gem\"a"s Lemma~\ref{lemma:Losrt:free_und_dom_Gamma}, dass die Substitution in jedem Fall
  definiert ist. Der eigentliche Beweis erfolgt dann durch simultane Induktion \"uber die L\"ange der Herleitung
  der Typurteile $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ und $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$, mit 
  Fallunterscheidung nach der zuletzt angewendeten Typregel in der Herleitung. Wir betrachten dazu lediglich den
  Fall der neuen Typregel \RN{Subsume'}.
  \PROOFCASEbeg
    \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$ mit Typregel \RN{Subsume'}.

          Dann existiert nach Voraussetzung ein $\tau''\in\setType$ mit $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau''}$ und
          $\tau'' \simle \tau'$. Darauf l\"asst sich unmittelbar die Induktionsvoraussetzung anwenden, und es golt
          \[\begin{array}{l}
            \Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau''}.
          \end{array}\]
          Wegen $\tau'' \simle \tau'$ folgt dann direkt die Behauptung
          \[\begin{array}{l}
            \Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}
          \end{array}\]
          mit Typregel \RN{Subsume'}.
  \PROOFCASEend
  Die \"ubrigen F\"alle verlaufen wie in den fr\"uheren Beweisen.
\end{beweis}

Wie zuvor f\"ur \Losub\ und \Lort\ ben\"otigen wir zum Beweis der Preservation- und Progress-Theoreme neben den obigen
Lemmata noch ein weiteres Lemmas, welches im wesentlichen einer Umkehrung der Typrelation entspricht. Wie gehabt
beschr\"anken wir uns auf die Aussagen, die in den sp\"ateren Beweisen benutzt werden, anstatt das Lemma in seiner
vollst\"andigen Form anzugeben.

\begin{lemma}[Umkehrung der Typrelation] \label{lemma:Losrt:Umkehrung_der_Typrelation} \
  \begin{enumerate}
    \item Wenn $\Tj{\Gamma}{\op}{\tau}$, dann gilt $\tau \sim \typeIntIntInt$ f\"ur $\op\in\{+,-,*\}$ oder
          $\tau \sim \typeIntIntBool$ f\"ur $\op\in\{\le,\ge,<,>,=\}$.

    \item Wenn $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau}$, dann gilt $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$
          und $\typeArrow{\tau_1}{\tau_2} \simle \tau$.

    \item Wenn $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$, dann gilt $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$,
          $\Tj{\Gamma}{e_2}{\tau_2}$ und $\tau_2 \simle \tau_2'$.

    \item Wenn $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$, dann gilt $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$
          mit $\typeObject{\phi} \sim \tau$ und $\tau \simle \tau'$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wir beweisen die einzelnen Aussagen jeweils durch Induktion \"uber die L\"ange der Typherleitung, mit Fallunterscheidung
  nach der zuletzt angewandten Typregel in der Herleitung. In jedem Fall kommen wieder nur exakt zwei Typregeln in
  Frage.
  \begin{enumerate}
    \item $\Tj{\Gamma}{\op}{\tau}$ kann nur mit einer der Typregeln \RN{Const} oder \RN{Subsume'} hergeleitet worden
          sein:
          \PROOFCASEbeg
            \item Falls $\Tj{\Gamma}{\op}{\tau}$ mit Typregel \RN{Const} hergeleitet wurde, folgt die Behauptung unmittelbar
                  nach Definition, denn $\sim$ ist reflexiv.

            \item Sollte die Herleitung von $\Tj{\Gamma}{\op}{\tau}$ mit einer Anwendung von Typregel \RN{Subsume'} enden,
                  so existiert nach Voraussetzung ein $\tau'\in\setType$ mit $\Tj{\Gamma}{\op}{\tau'}$ und $\tau' \simle \tau$.
                  Nach Induktionsvoraussetzung gilt $\tau' \sim \typeIntIntInt$ f\"ur $\op\in\{+,-,*\}$ oder
                  $\tau' \sim \typeIntIntBool$ f\"ur $\op\in\{\le,\ge,<,>,=\}$.

                  Wir betrachten ausschliesslich den Fall $\tau' \sim \typeIntIntInt$, der Fall
                  $\tau' \sim \typeIntIntBool$ folgt dann analog. Wegen Lemma~\ref{lemma:Losrt:Antisymmetrie}
                  folgt $\typeIntIntInt \simle \tau'$ und wegen der Transitivit\"at von $\simle$ folgt
                  $\typeIntIntInt \simle \tau$. Nach Subtyping-Lemma (\ref{lemma:Losrt:Subtyping_Lemma}) existeren
                  dann $\tau_1,\tau_2\in\setType$ mit $\tau \sim \typeArrow{\tau_1}{\tau_2}$, $\tau_1 \simle \typeInt$
                  und $\typeArrow{\typeInt}{\typeInt} \simle \tau_2$. Nach erneuter Anwendung des Lemmas erhalten
                  wir $\tau_2',\tau_2''\in\setType$ mit $\tau_2' \simle \typeInt$ und $\typeInt \simle \tau_2''$.
                  Wiederum mit Lemma~\ref{lemma:Losrt:Subtyping_Lemma} folgt schliesslich
                  $\tau_1 \sim \tau_2' \sim \tau_2'' \sim \typeInt$. Somit gilt schlussendlich
                  $\tau \sim \typeIntIntInt$, was zu zeigen war.
          \PROOFCASEend

    \item Das Typurteil $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau}$ l\"a"st sich nur mit einer der Typregeln \RN{Abstr}
          oder \RN{Subsume'} herleiten:
          \PROOFCASEbeg
            \item Im Fall von $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau}$ mit Typregel \RN{Abstr} gilt nach Voraussetzung
                  $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$ und $\tau = \typeArrow{\tau_1}{\tau_2}$. Da $\simle$
                  reflexiv ist, folgt $\typeArrow{\tau_1}{\tau_2} \simle \tau$.

            \item Falls $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau}$ mit Typregel \RN{Subsume'} hergeleitet worden ist,
                  existiert nach Voraussetzung ein $\tau'\in\setType$ mit $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\tau'}$
                  und $\tau' \simle \tau$. Nach Induktionsvoraussetzung gilt also $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$
                  mit $\typeArrow{\tau_1}{\tau_2} \simle \tau'$. Wegen der Transitivit\"at von $\simle$ folgt damit
                  $\typeArrow{\tau_1}{\tau_2} \simle \tau$, was zu zeigen war.
          \PROOFCASEend

    \item Die Herleitung von $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ kann nur mit einer Anwendung einer der Typregeln
          \RN{App} oder \RN{Subsume'} enden, entsprechend sind nur diese F\"alle zu betrachten:
          \PROOFCASEbeg
            \item F\"ur $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App} muss gelten
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{\Gamma}{e_2}{\tau_2}$. Da
                  $\simle$ reflexiv ist, gilt $\tau_2 \simle \tau_2$.

            \item $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{Subsume'} kann nur aus Pr\"amissen der
                  Form $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau'}$ und $\tau' \simle \tau$ folgen. Nach Induktionsvoraussetzung
                  gilt dann $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau'}}$, $\Tj{\Gamma}{e_2}{\tau_2}$ und
                  $\tau_2 \simle \tau_2'$. Wegen $\tau' \simle \tau$ folgt somit schliesslich
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$ mit Typregel \RN{Subsume'} aus
                  $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau'}}$.
          \PROOFCASEend

    \item Wiederum ist klar, dass das Typurteil $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ ausschliesslich mit
          den Typregeln \RN{Object'} und \RN{Subsume'} hergeleitet worden sein kann, und somit nur diese F\"alle zu
          betrachten sind:
          \PROOFCASEbeg
            \item Falls $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ mit einer Anwendung der Typregel \RN{Object'}
                  hergeleitet wurde, so gilt nach Voraussetzung $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$
                  mit $\typeObject{\phi} \sim \tau$ und $\tau = \tau'$, woraus unmittelbar $\tau \simle \tau'$ folgt.

            \item Sollte andererseits $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$ mit Typregel \RN{Subsume'}
                  hergeleitet worden sein, so existiert nach Voraussetzung ein $\tau''\in\setType$ mit
                  $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau''}$ und $\tau'' \simle \tau'$. Darauf l\"asst sich
                  nun die Induktionsvoraussetzung anwenden und wir erhalten $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$
                  mit $\typeObject{\phi} \sim \tau$ und $\tau \simle \tau''$. Wegen der Transitivit\"at von $\simle$ folgt
                  schliesslich $\tau \simle \tau'$.
          \PROOFCASEend
  \end{enumerate}
\end{beweis}

Wie bereits im Beweis der Typsicherheit der Programmiersprache \Losub\ und \Lort\ k\"onnen wir dank des vorangegangenen
Lemmas die Anwendungen der Typregel \RN{Subsume'} im wesentlichen ignorieren, und somit das Preservation-Theorem
relativ einfach beweisen. Die Formulierung des Satzes ist, wie nicht anders zu erwarten, die gleiche wie zuvor.

\begin{satz}[Typerhaltung, "`Preservation"'] \label{satz:Losrt:Preservation} \index{Typsicherheit!Preservation} \
  \begin{enumerate}
    \item $\forall \Gamma\in\setTEnv:\forall e,e'\in\setExp:\forall \tau\in\setType:\,
           \Tj{\Gamma^\star}{e}{\tau}\,\wedge\,e \to e'\ \Rightarrow\ \Tj{\Gamma^\star}{e'}{\tau}$
    \item $\forall \Gamma\in\setTEnv:\forall r,r'\in\setRow:\forall \phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\wedge\,r \to r'\ \Rightarrow\ \Tj{\Gamma}{r'}{\phi}$
  \end{enumerate}
\end{satz}

\begin{beweis}
  Der Beweis erfolgt selbstverst\"andlich wieder durch simultane Induktion \"uber die L\"ange der Typherleitungen
  von $\Tj{\Gamma^\star}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$, mit Fallunterscheidung nach der zuletzt angewendeten
  Typregel. Wir betrachten lediglich die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur \RN{Const}, \RN{Id}, \RN{Abstr} und \RN{Empty} gilt gem\"a"s Lemma~\ref{lemma:Lo:Werte_und_small_steps}
          $e \not\to$ bzw. $r \not\to$.

    \item $\Tj{\Gamma^\star}{e}{\tau}$ mit Typregel \RN{Subsume'}

          Dann gilt nach Voraussetzung, dass ein $\tau'\in\setType$ existiert, mit $\Tj{\Gamma^\star}{e}{\tau'}$ und
          $\tau' \simle \tau$. Nach Induktionsvoraussetzung folgt
          \[\begin{array}{l}
            \Tj{\Gamma^\star}{e'}{\tau'},
          \end{array}\]
          und wegen $\tau' \simle \tau$ folgt daraus mit Anwendung von Typregel \RN{Subsume'} unmittelbar
          \[\begin{array}{l}
            \Tj{\Gamma^\star}{e'}{\tau},
          \end{array}\]
          was zu zeigen war.

    \item $\Tj{\Gamma^\star}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App}

          Dann muss gelten $\Tj{\Gamma^\star}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{\Gamma^\star}{e_2}{\tau_2}$.
          Der small step $\expApp{e_1}{e_2} \to e'$ kann wiederum nur mit einer der small step Regel \RN{App-Left},
          \RN{App-Right}, \RN{Beta-V} oder \RN{Op} hergeleitet worden sein. Entsprechend unterscheiden wir nach
          der letzten Regel in der Herleitung des small steps:
          \begin{enumerate}
            \item $\expApp{e_1}{e_2} \to e'$ mit \RN{App-Left} impliziert $e' = \expApp{e_1'}{e_2}$ und
                  $e_1 \to e_1'$. Darauf l\"asst sich die Induktionsvoraussetzung anwenden, und wir erhalten
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'}{\typeArrow{\tau_2}{\tau}},
                  \end{array}\]
                  woraus dann mit Typregel \RN{App} das erwartete Ergebnis
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\expApp{e_1'}{e_2}}{\tau}
                  \end{array}\]
                  folgt.

            \item $\expApp{e_1}{e_2} \to e'$ mit small step Regel \RN{App-Right} kann nur aus $e_1\in\setVal$, $e_2 \to e_2'$
                  und $e' = \expApp{e_1}{e_2'}$ folgen. Die Behauptung folgt dann mit Induktionsvoraussetzung und Typregel
                  \RN{App}.

            \item Falls $\expApp{e_1}{e_2} \to e'$ mit \RN{Beta-V} hergeleitet wurde, gilt $e_1=\expAbstr{x:\tau_1}{e_1'}$
                  und $e_2\in\setVal$, sowie $e'=e_1'\SUB{e_2}{x}$. Nach dem vorangegangenen Lemma
                  (\ref{lemma:Losrt:Umkehrung_der_Typrelation}) gilt also
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star\SUB{\tau_1}{x}}{e_1'}{\tau'}
                  \end{array}\]
                  mit $\typeArrow{\tau_1}{\tau'} \simle \typeArrow{\tau_2}{\tau}$. Nach Subtyping-Lemma
                  (\ref{lemma:Losrt:Subtyping_Lemma}) gilt also $\tau_2 \simle \tau_1$ und
                  $\tau' \simle \tau$, das bedeutet wegen $\Tj{\Gamma^\star}{e_2}{\tau_2}$ folgt mit
                  Typregel \RN{Subsume'}, dass auch
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_2}{\tau_1}
                  \end{array}\]
                  gilt. Damit l\"asst sich nun auf $\Tj{\Gamma^\star\SUB{\tau_1}{x}}{e_1'}{\tau'}$ das
                  Substitutions-Lemma (\ref{lemma:Losrt:Typurteile_und_Substitution}) anwenden, und
                  wir erhalten
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'\SUB{e_2}{x}}{\tau'},
                  \end{array}\]
                  woraus dann wegen $\tau' \simle \tau$ mit Typregel \RN{Subsume'} schliesslich
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{e_1'\SUB{e_2}{x}}{\tau}
                  \end{array}\]
                  folgt, was zu zeigen war.

            \item F\"ur $\expApp{e_1}{e_2} \to e'$ mit small step Regel \RN{Op} muss gelten $e_1=\expApp{\op}{v_1}$,
                  $e_2 = v_2 \in \setVal$ und $e' = \op^I(v_1,v_2)$. Gem\"a"s Lemma~\ref{lemma:Losrt:Umkehrung_der_Typrelation}
                  folgt daraus, dass
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op}{\typeArrow{\tau_1}{\typeArrow{\tau_2}{\tau}}}
                  \end{array}\]
                  und
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{v_1}{\tau_1}
                  \end{array}\]
                  gilt. Weiterhin folgt nach Lemma~\ref{lemma:Losrt:Umkehrung_der_Typrelation}, dass $\tau_1\sim\typeInt$,
                  $\tau_2\sim\typeInt$, und $\tau\sim\typeInt$ f\"ur $\op\in\{+,-,*\}$ oder $\tau\sim\typeBool$ f\"ur
                  $\op\in\{\le,\ge,<,>,=\}$. 

                  Wir betrachten wieder nur den Fall, dass $\op\in\{+,-,*\}$. F\"ur relationale Operatoren folgt die
                  Behauptung analog.

                  Sei also $\op\in\{+,-,*\}$, dann gilt nach Definition $\op^I(v_1,v_2)\in\setInt$. Daraus folgt mit
                  Typregel \RN{Const}, dass
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op^I(v_1,v_2)}{\typeInt}
                  \end{array}\]
                  gilt, und wegen $\tau \sim \typeInt$ gilt nach Lemma~\ref{lemma:Losrt:Antisymmetrie} auch
                  $\typeInt \simle \tau$, also folgt schliesslich
                  \[\begin{array}{l}
                    \Tj{\Gamma^\star}{\op^I(v_1,v_2)}{\tau}
                  \end{array}\]
                  mit Typregel \RN{Subsume'}.
          \end{enumerate}

    \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object'}

          Das kann nur aus Pr\"amissen der Form $\Tj{(\Gamma^\star)^\star\SUB{\tau}{\self}}{r}{\phi}$ und
          $\typeObject{\phi} \sim \tau$ folgen. Der small step $\expObject{\self:\tau}{r} \to e'$ kann
          andererseits nur mit der small step Regel \RN{Object-Eval} hergeleitet worden sein, wobei nach
          Voraussetzung ein small step $r \to r'$ existiert und $e' = \expObject{\self:\tau}{r'}$. Nach
          Induktionsvoraussetzung gilt also
          \[\begin{array}{l}
            \Tj{(\Gamma^\star)^\star\SUB{\tau}{\self}}{r'}{\phi},
          \end{array}\]
          und mit Typregel \RN{Object'} folgt dann unmittelbar die Behauptung.
    
    \item $\Tj{\Gamma^\star}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send}

          Dann gilt nach Voraussetzung $\Tj{\Gamma^\star}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$. Der
          small step $\expSend{e_1}{m} \to e'$ kann nur mit \RN{Send-Eval} oder \RN{Send-Unfold} hergeleitet
          worden sein:
          \begin{enumerate}
            \item F\"ur $\expSend{e_1}{m} \to e'$ mit \RN{Send-Eval} existiert dann nach Voraussetzung ein
                  small step $e_1 \to e_1'$ und es gilt $e' = \expSend{e_1'}{m}$. Das bedeutet, die
                  Behauptung folgt direkt mit Induktionsvoraussetzung und Typregel \RN{Send}.

            \item Falls $\expSend{e_1}{m} \to e'$ mit small step Regel \RN{Send-Unfold} hergeleitet worden
            ist, so muss gelten $e_1 = \expObject{\self:\tau'}{\omega}$ und $e' = \expSend{\omega\SUB{e_1}{\self}}{m}$.
            Nach dem vorangegangenen Lemma (\ref{lemma:Losrt:Umkehrung_der_Typrelation}) gilt
            \[\begin{array}{l}
              \Tj{(\Gamma^\star)^\star\SUB{\tau'}{\self}}{\omega}{\phi'}
            \end{array}\]
            mit $\typeObject{\phi'} \sim \tau'$ und $\tau' \simle \typeObject{\rtypeMethod{m}{\tau}{\phi}}$. Das
            wiederum bedeutet, dass mit Typregel \RN{Subsume'}
            \[\begin{array}{l}
              \Tj{\Gamma^\star}{\expObject{\self:\tau'}{\omega}}{\tau'}
            \end{array}\]
            folgt. Damit sind alle Voraussetzungen f\"ur die Anwendung des speziellen Substitutions-Lemmas
            (\ref{lemma:Losrt:Typurteile_und_self_Substitution}) erf\"ullt, und wir erhalten
            \[\begin{array}{l}
              \Tj{\Gamma^\star}{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{\phi'}.
            \end{array}\]
            Da $\typeObject{\phi'} \sim \tau'$ und $\tau' \simle \typeObject{\rtypeMethod{m}{\tau}{\phi}}$ existieren
            also nach Subtyping-Lemma (\ref{lemma:Losrt:Subtyping_Lemma}) $\tau''\in\setType$ und $\phi''\in\setRType$
            mit $\tau'' \simle \tau$ und $\typeObject{\phi''} \simle \typeObject{\phi'}$, so dass
            $\phi' = (\rtypeMethod{m}{\tau''}{\phi''})$. Damit erhalten wir schliesslich mit Typregel \RN{Send'}
            \[\begin{array}{l}
              \Tj{\Gamma^\star}{\expSend{\omega\SUB{\expObject{\self:\tau'}{\omega}}{\self}}{m}}{\tau''},
            \end{array}\]
            denn $(\Gamma^\star)^\star = \Gamma^\star$, und wegen $\tau'' \simle \tau$ folgt schliesslich
            mit Typregel \RN{Subsume'} die Behauptung.
          \end{enumerate}
  \PROOFCASEend
  Die restlichen F\"alle verlaufen \"ahnlich.
\end{beweis}

Wir haben also gezeigt, dass auch f\"ur das Typsystem der Programmiersprache \Losrt, small steps typerhaltend sind. Es bleibt
wie zuvor noch das Progress-Theorem zu zeigen. Dazu formulieren wir wieder wie gehabt ein {\em Canonical Forms Lemma} f\"ur
die Sprache \Losrt, wobei wir uns wieder auf die im nachfolgenden Beweis verwendeten Aussagen beschr\"anken, statt das Lemma
in seiner allgemeinsten Form anzugeben.

\begin{lemma}[Canonical Forms] \label{lemma:Losrt:Canonical_Forms}
  Sei $v\in\setVal$, $\tau\in\setType$, und gelte $\Tj{[\,]}{v}{\tau}$.
  \begin{enumerate}
    \item Wenn $\tau \simle \typeInt$, dann gilt $v\in\setInt$.

    \item Wenn $\tau \simle \typeArrow{\tau_1}{\tau_2}$, dann gilt eine der folgenden Aussagen:
          \PROOFCASEbeg
            \item $v\in\setOp$
            \item $v=\expApp{\op}{v_1}$ mit $\op\in\setOp$ und $v_1\in\setVal$
            \item $v=\expAbstr{x:\tau_1'}{e}$ mit $x\in\setVar$, $\tau_1'\in\setType$ und $e\in\setExp$
          \PROOFCASEend

    \item Wenn $\tau \simle \typeObject{\phi}$, dann gilt $v=\expObject{\self:\tau'}{\omega}$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Wir \"uberspringen den Beweis an dieser Stelle, da es sich bis auf Kleinigkeiten um exakt den gleichen Beweis
  handelt, wie im Canonical Forms Lemma f\"ur die Programmiersprache \Lort\ (\ref{lemma:Losrt:Canonical_Forms}).
\end{beweis}

Somit k\"onnen wir schliesslich das Progress-Theorem beweisen und formulieren. Wie nicht anders zu erwarten,
stimmt die Formulierung des Theorems mit den vorangegangenen Formulierungen \"uberein (vgl. Satz~\ref{satz:Losub:Progress}
und Satz~\ref{satz:Lort:Progress}), und auch der Beweis verl\"auft sehr \"ahnlich.

\begin{satz}[Existenz des \"Ubergangsschritts, "`Progress"'] \label{satz:Losrt:Progress} \index{Typsicherheit!Progress} \
  \begin{enumerate}
    \item $\forall e\in\setExp, \tau\in\setType:\, \Tj{[\,]}{e}{\tau}
           \,\Rightarrow\,(e\in\setVal\,\vee\,\exists e'\in\setExp: e \to e')$
    \item $\forall \Gamma\in\setTEnv,r\in\setRow, \phi\in\setRType:\, \Tj{\Gamma^+}{r}{\phi}
           \,\Rightarrow\,(r\in\setRVal\,\vee\,\exists r'\in\setRow: r \to r')$
  \end{enumerate}
\end{satz}

\begin{beweis}
  Wir f\"uhren den Beweis wieder durch simultane Induktion \"uber die L\"ange der Herleitung der Typurteile
  $\Tj{[\,]}{e}{\tau}$ und $\Tj{\Gamma^+}{r}{\phi}$, mit Fallunterscheidung nach der jeweils zuletzt angewandten
  Typregel. Dazu betrachten wir exemplarisch die folgenden F\"alle.
  \PROOFCASEbeg
    \item F\"ur \RN{Const} und \RN{Abstr} gilt $e\in\setVal$, w\"ahrend f\"ur \RN{Empty} gilt $r\in\setRVal$.

    \item $\Tj{[\,]}{e}{\tau}$ mit Typregel \RN{Subsume'}

          Nach Voraussetzung existiert ein $\tau'\in\setType$ mit $\Tj{[\,]}{e}{\tau'}$ und $\tau' \simle \tau$.
          Also folgt die Behauptung unmittelbar mir Induktionsvoraussetzung.

    \item $\Tj{[\,]}{\expApp{e_1}{e_2}}{\tau}$ mit Typregel \RN{App}

          Das kann nur aus Pr\"amissen der Form $\Tj{[\,]}{e_1}{\typeArrow{\tau_2}{\tau}}$ und $\Tj{[\,]}{e_2}{\tau_2}$
          folgen. Dann zeigen wir je nach Form der Teilausdr\"ucke $e_1$ und $e_2$, dass entweder die Applikation
          bereits ein Wert ist, oder ein small step existiert.

          F\"ur $e_1\not\in\setVal$ l\"asst sich wie fr\"uher leicht zeigen, dass ein small step mit \RN{App-Left}
          existiert. Ebenso einfach zeigt man, dass f\"ur $e_1\in\setVal$ und $e_2\not\in\setVal$ ein small
          step mit \RN{App-Right} existiert.

          Es bleibt also der Fall $e_1,e_2\in\setVal$ zu betrachten. Da $\simle$ reflexiv ist, l\"asst sich das
          Canonical Forms Lemma (\ref{lemma:Losrt:Canonical_Forms}) anwenden, demzufolge drei F\"alle zu
          unterscheiden sind:
          \begin{enumerate}
            \item $e_1 \in \setOp$

                  Trivial.

            \item $e_1 = \expApp{\op}{v_1}$ mit $\op\in\setOp$ und $v_1 \in \setVal$

                  Dann existiert nach Lemma~\ref{lemma:Losrt:Umkehrung_der_Typrelation} ein $\tau_1\in\setType$ mit
                  $\Tj{[\,]}{\op}{\typeArrow{\tau_1}{\typeArrow{\tau_2}{\tau}}}$ und $\Tj{[\,]}{v_1}{\tau_1}$. Wie
                  fr\"uher folgt daraus leicht, dass $v_1,e_2\in\setInt$, und somit ein small step
                  $\expApp{\expApp{\op}{v_1}}{e_2} \to \op^I(v_1,e_2)$ mit small step Regel \RN{Op} existiert.

            \item $e_1 = \expAbstr{x:\tau_2'}{e_1'}$ mit $x\in\setVar$, $\tau_2'\in\setType$ und $e_1'\in\setExp$

                  Dann ist trivialerweise ersichtlich, dass ein small step mit \RN{Beta-V} m\"oglich ist.
          \end{enumerate}

    \item $\Tj{[\,]}{\expSend{e_1}{m}}{\tau}$ mit Typregel \RN{Send}

          Nach Voraussetzung gilt $\Tj{[\,]}{e_1}{\typeObject{\rtypeMethod{m}{\tau}{\phi}}}$. Mit Induktionsvoraussetzung
          folgt, dass entweder $e_1\in\setVal$ gilt oder ein small step $e_1 \to e_1'$ existiert.

          Sei also $e_1\in\setVal$, dann gilt nach Lemma~\ref{lemma:Losrt:Canonical_Forms}, dass
          $e_1 = \expObject{\self:\typeObject{\phi}}{\omega}$. Also existiert ein small steo
          \[\begin{array}{l}
            \expSend{(\expObject{\self:\typeObject{\phi}}{\omega})}{m} \to \expSend{\omega\SUB{e_1}{\self}}{m}
          \end{array}\]
          mit small step Regel \RN{Send-Unfold}.

          Ist andererseits $e_1\not\in\setVal$, so existiert ein small step
          \[\begin{array}{l}
            \expSend{e_1}{m}\to\expSend{e_1'}{m}
          \end{array}\]
          mit small step Regel \RN{Send-Eval}.
  \PROOFCASEend
  Die restlichen F\"alle verlaufen analog.
\end{beweis}
%
Wie zuvor folgt dann mit Hilfe der Preservation- und Progress-Theoreme die Typsicherheit der Programmiersprache
\Losrt. Der Vollst\"andigkeithalber wiederholen wir den Satz aber gerne ein weiteres Mal.

\begin{satz}[Typsicherheit, "`Safety"'] \label{satz:Losrt:Safety} \index{Typsicherheit!Safety}
  Wenn $\Tj{[\,]}{e}{\tau}$, dann bleibt die Berechnung f\"ur $e$ nicht stecken.
\end{satz}

\begin{beweis}
  Folgt analog wie f\"ur \Lort\ aus den Preservation und Progress-S\"atzen.
\end{beweis}


%%%%%%%%%%%%%%%%%%%%
%% Typalgorithmus %%
%%%%%%%%%%%%%%%%%%%%

\subsection{Typalgorithmus}

Es ist offensichtlich, dass sich f\"ur die Programmiersprache \Losrt, \"ahnlich wie dies zuvor f\"ur die
Sprache \Losub\ vorgef\"uhrt wurde, ein Minimal Typing Kalk\"ul angeben l\"asst. Aus Abschnitt~\ref{abschnitt:Die_Sprache_Lort}
wissen wir dar\"uber hinaus, dass die Relation $\sim$ entscheidbar ist. Es bleibt uns also zu zeigen, dass
auch die Relation $\simle$ entscheidbar ist.

{\bf TODO}


%%%%%%%%%%%%%%%
%% Beispiele %%
%%%%%%%%%%%%%%%

\section{Beispiele}

\subsection{Punktobjekte}

{\bf TODO:} Vollst\"andiges Beispiel.

\subsection{Rekursive Datenstrukturen}

{\bf TODO:} Listenbeispiel aus den Unterlagen.


% vi:set ts=2 sw=2 et ai syntax=tex:
