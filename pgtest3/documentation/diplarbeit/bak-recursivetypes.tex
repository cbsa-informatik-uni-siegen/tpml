%%
%% Rekursive Typen
%%

\chapter{Rekursive Typen}
\label{kapitel:Rekursive_Typen}


Im vorangegangenen Kapitel haben wir das einfache objekt-orientierte Typsystem aus
Kapitel~\ref{kapitel:Funktionale_Objekte} um Subsumption erweitert, so dass in der
Sprache \Losub\ deutlich mehr Ausdr\"ucke wohlgetypt sind, als noch in der Programmiersprache \Lot.
Dabei haben wir f\"ur \Losub\ gezeigt, dass diese neu hinzugewonnen wohlgetypten Ausdr\"ucke
zu Unrecht durch das Typsystem von \Lot\ abgelehnt wurden, denn deren Berechnung bleibt nicht
stecken (vgl. Satz~\ref{satz:Losub:Safety}).

Allerdings ist das Typsystem der Sprache \Losub\ immer noch zu eingeschr\"ankt, um
sinnvoll mit funktionalen Objekten programmieren zu k\"onnen. Zum Beispiel ist es nicht m\"oglich
den folgenden Ausdruck so mit Typinformationen zu versehen, dass mit den Typregeln von \Losub\ ein
Typ herleitbar w\"are.
\[\begin{array}{l}
  \expLet{point}{\\\quad \expObject{\self} 
                           {\\\quad\quad \rowVal{x}{1} 
                           {\\\quad\quad \rowVal{y}{2}
                           {\\\quad\quad \rowMethod{move}{\expAbstr{dx}{\expAbstr{dy}
                                                   {\expDupl{x=x+dx;y=y+dy}}}}
                           {\\\quad}}}}\\}
                           {\expApp{\expApp{\expSend{point}{move}}{2}}{1}}
\end{array}\]
Offensichtlich w\"urde die Berechnung dieses Ausdrucks nicht stecken bleiben, sondern stattdessen mit
einem Punktobjekt terminieren, mit den Koordinaten $x=3$ und $y=3$. Die Methode $move$ liefert ein neues
Punktobjekt, welches sich lediglich in den Werten der Attribute $x$ und $y$ unterscheidet. Insbesondere
besitzt aber dieses neue Punktobjekt ebenfalls eine Methode $move$.

F\"ur das Typsystem bedeutet das, dass ein Typ f\"ur $point$ "`sich selbst enthalten"' m\"usste, und
zwar als Ergebnistyp der Methode $move$. Oder anders ausgedr\"uckt, gesucht ist ein Typ $\tau_{point}$
f\"ur den gilt:
\[
  \tau_{point} = \typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{\tau_{point}}}}{\rtypeEmpty}}
\]
Es ist leicht zu sehen, dass im Typsystem der Sprache \Losub\ kein solcher Typ $\tau_{point}$ existiert, der diese
(rekursive) Gleichung erf\"ullt. Um also Objekten, die sich selbst oder ein Duplikat von sich selbst als Ergebnis
eines Methodenaufrufs liefern, Typen zuordnen zu k\"onnen, ist es notwendig das Typsystem um sogenannte
\Define{rekursive Typen}{Rekursive Typen} \engl{recursive types} zu erweitern.


%%%%%%%%%%%%%%%%%%%%%%
%% Die Sprache Lort %%
%%%%%%%%%%%%%%%%%%%%%%

\section{Die Sprache \Lort}

Die im diesem Abschnitt betrachtete Sprache \Lort\ stellt eine Erweiterung des Typsystems der Sprache \Lot\ um
rekursive Typen dar. Die Semantik der Sprache \Lot\ wird bis auf die folgenden syntaktischen \"Anderungen
unver\"andert \"ubernommen.

\begin{definition}[Syntax der Sprache \Lort] \label{definition:Lort:Syntax_der_Sprache_Lort} \
  Vorgegeben sei eine Menge $\setTName$ von \Define{Typnamen}{Typname} $t$.
  \begin{enumerate}
    \item Die Menge $\setType^{raw}$ aller syntaktisch herleitbaren Typen $\tau^{raw}$ ist durch die
          kontextfreie Grammatik
          \GRbeg
            \tau^{raw} \GRis \typeBool \GRmid \typeInt \GRmid \typeUnit
                       \GRal \typeArrow{\tau_1^{raw}}{\tau_2^{raw}}
                       \GRal \typeRec{t}{\tau_1^{raw}}
                       \GRal \typeObject{\phi^{raw}}
          \GRend
          und die Menge $\setRType^{raw}$ aller syntaktisch herleitbaren Reihentypen $\phi^{raw}$ ist durch
          \GRbeg
            \phi^{raw} \GRis \rtypeEmpty
                       \GRal \rtypeMethod{m}{\tau^{raw}}{\phi_1^{raw}}
          \GRend
          definiert.

    \item Die Menge $\free{\tau^{raw}}$ aller im Typ $\tau^{raw}\in\setType^{raw}$ frei vorkommenden Typnamen ist
          induktiv durch
          \EQNbeg
            \free{\tau_\beta} & = & \emptyset \text{ f\"ur } \tau_\beta\in\{\typeBool,\typeInt,\typeUnit\} \\
            \free{\typeArrow{\tau_1^{raw}}{\tau_2^{raw}}} & = & \free{\tau_1^{raw}} \cup \free{\tau_2^{raw}} \\
            \free{\typeRec{t}{\tau_1^{raw}}} & = & \free{\tau_1^{raw}} \setminus \{t\} \\
            \free{\typeObject{\phi^{raw}}} & = & \free{\phi^{raw}}
          \EQNend
          und die Menge $\free{\phi^{raw}}$ aller im Reihentyp $\phi^{raw} \in\setRType^{raw}$ frei
          vorkommenden Typnamen ist induktiv durch
          \EQNbeg
            \free{\rtypeEmpty} & = & \emptyset \\
            \free{\rtypeMethod{m}{\tau^{raw}}{\phi_1^{raw}}} & = & \free{\tau^{raw}} \cup \free{\phi_1^{raw}}
          \EQNend
          definiert.

    \item Die Mengen $\setType \subseteq \setType^{raw}$ aller g\"ultigen Typen $\tau$ und
          $\setRType^{raw}\subseteq\setRType$ aller g\"ultigen Reihentypen $\phi$ der Programmiersprache
          \Lort\ sind wie folgt definiert
          \EQNbeg
            \setType & = & \{\tau\in\setType^{raw}\ |\ \free{\tau} = \emptyset \wedge
                            \forall t,t_1,\ldots,t_n\in\setTName:
                            \typeRec{t}{\typeRec{t_1}{\ldots\typeRec{t_n}{t}}} \not\in \mathcal{P}(\tau)\} \\
            \setRType & = & \{\phi\in\setRType^{raw}\ |\ \free{\phi} = \emptyset\},
          \EQNend
          wobei $\mathcal{P}(\tau)$ die Menge aller im Typ $\tau$ vorkommenden Typen bezeichnet.
  \end{enumerate}
\end{definition}
Rekursive Typen sind hierbei analog zu rekursiven Ausdr\"ucken zu lesen, d.h. mit $\typeRec{t}{\tau}$
bezeichnen wir den Typ, der die Gleichung
\[
  \typeRec{t}{\tau} = \tau\SUB{\typeRec{t}{\tau}}{t}
\]
erf\"ullt. Allerdings handelt es sich hierbei nicht um die syntaktische Gleichheit der beiden Typen,
sondern vielmehr die \"ubereinstimmende Bedeutung.

{\bf TODO:} Erl\"auterungen zur Definition

Bevor wir uns jedoch genauer mit dem Begriff der
Gleichheit von rekursiven Typen besch\"aftigen, kommen wir zun\"achst auf das Beispiel mit dem
Punktobjekt zur\"uck. In der Sprache \Lort\ l\"asst sich das Beispiel nun wie folgt mit Typinformationen
versehen.
\[\begin{array}{l}
  \expLet{point}{\\\quad \expObject{\self:\typeRec{t}{\typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}{\rtypeEmpty}}}} 
                           {\\\quad\quad \rowVal{x}{1} 
                           {\\\quad\quad \rowVal{y}{2}
                           {\\\quad\quad \rowMethod{move}{\expAbstr{dx:\typeInt}{\expAbstr{dy:\typeInt}
                                                   {\expDupl{x=x+dx;y=y+dy}}}}
                           {\\\quad}}}}\\}
                           {\expApp{\expApp{\expSend{point}{move}}{2}}{1}}
\end{array}\]
Intuitiv sollte sich f\"ur diesen Ausdruck der Typ des Punktobjekts herleiten lassen, also
\[
  \typeRec{t}{\typeObject{\rtypeMethod{move}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}{\rtypeEmpty}}},
\]
was dem zu erwartenden Ergebnis entsprechen w\"urde.


%%%%%%%%%%%%%%%%%%%
%% Typgleichheit %%
%%%%%%%%%%%%%%%%%%%

\subsection{Typgleichheit}

Bevor wir uns der Frage der Typgleichheit in einem Typsystem mit rekursiven Typen, wie dem der
Programmiersprache \Lort, widmen, wollen wir uns zun\"achst an einem Beispiel die Probleme
veranschaulichen, die es zu l\"osen gilt.

\begin{beispiel}
  In den bisherigen Typsystem wurden zwei Typen als gleich angesehen, wenn ihre syntaktischen Repr\"asentationen
  \"ubereinstimmten. Betrachten wir dazu die folgenden beiden rekursiven Typen.
  \begin{enumerate}
    \item $\typeRec{t}{\typeArrow{\typeInt}{t}}$
    \item $\typeRec{t}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}$
  \end{enumerate}
  Rein syntaktisch handelt es sich hierbei um zwei unterschiedliche Typen. Ber\"ucksichtigt man jedoch die
  Ausdr\"ucke denen diese Typen zugeordnet werden k\"onnen, so zeigt sich, dass die Typen nicht so unterschiedlich
  sind, wie sie zun\"achst aussehen m\"ogen. Ein Ausdruck des Typs $\typeRec{t}{\typeArrow{\typeInt}{t}}$
  ist eine sogenannte {\em hungry function} auf Ganzzahlen (vgl.\cite[S.300]{Pierce02}), also eine Funktion, die
  wenn sie auf eine Ganzzahl angewendet wird, eine neue {\em hungry function} liefert, die wieder als Argument
  eine Ganzzahl erwartet. Der folgende Ausdruck stellt eine solche {\em hungry function} dar:
  \[
    \expRec{f:\typeRec{t}{\typeArrow{\typeInt}{t}}}{\expAbstr{x:\typeInt}{f}}
  \]
  Intuitiv l\"asst sich f\"ur diesen Ausdruck aber ebenfalls der Typ
  $\typeRec{t}{\typeArrow{\typeInt}{\typeArrow{\typeInt}{t}}}$ herleiten, denn die Funktion liefert ja angewandt
  auf eine Ganzzahl wieder eine Funktion, die eine Ganzzahl erwartet und bei Anwendung zum identischen Ergebnis
  f\"uhrt. F\"ur den gleichen Ausdruck lassen
  sich nun also zwei syntaktisch unterschiedliche Typen herleiten\footnote{Da die genaue Definition der Typgleichheit
  fehlt, die f\"ur die Typregeln streng formal nat\"urlich ben\"otigt wird, ist in diesem Fall die intuitive
  Herleitbarkeit gemeint.}.
\end{beispiel}

In der Literatur werden im wesentlich zwei L\"osungsans\"atze f\"ur Typgleichheit mit rekursiven Typen beschrieben
(vgl. \cite[S.276ff]{Pierce02}).
\begin{itemize}
  \item Der {\em iso-rekursive} Ansatz unterscheidet grunds\"atzlich zwischen dem rekursiven Typ
        $\typeRec{t}{\tau}$ und seiner aufgefalteten Version $\tau\SUB{\typeRec{t}{\tau}}{t}$, d.h.
        die Typen werden nicht als gleich angesehen. Dadurch l\"asst sich die \"Uberpr\"ufung der Typgleichheit
        nach wie vor durch einen syntaktischen Vergleich realisieren. Das Erzeugen und Auffalten von rekursiven
        Typen wird hierbei explizit durch Programmkonstrukte durchgef\"uhrt, niemals implizit durch den Typechecker.
        Dieser Ansatz ist in der Praxis am weitesten verbreitet, da die Implementierung verh\"altnism\"a"sig einfach ist.
        Eine detailierte Beschreibung eines objekt-orientierten Typsystems mit iso-rekursiven Typen findet sich
        zum Beispiel in \cite{AbadiCardelli96}.
  \item Der {\em equi-rekursive} Ansatz hingegen unterscheidet nicht zwischem dem rekursiven Typ und seiner
        aufgefalteten Version. Dieser Ansatz bedingt eine aufwendigere Implementation, ist aber aus theoretischer
        Sicht interessanter.
\end{itemize}
Wir betrachten im folgenden einen equi-rekursiven Ansatz, da der iso-rekursive Ansatz vergleichsweise trivial und
f\"ur die theoretische Betrachtung eher uninteressant ist. Dazu ben\"otigen wir zun\"achst ein paar Definitionen,
da der bisher in diesem Dokument verwendete Herleitungsbegriff f\"ur die Gleichheit rekursiver Typen nicht in
dieser Form anwendbar ist. Wir orientieren uns hierbei an dem in \cite{Pierce02} vorgestellten Ansatz.

{\bf TODO:} Verweis auf math. Grundlagen (Abschnitt~\ref{subsection:math:Induktion_und_Coinduktion})

{\bf TODO:} In math. Grundlagen packen!

Nach diesen allgemeinen Erkenntnissen k\"onnen wir nun die Relation f\"ur die Typgleichheit definieren.
Dazu definieren wir eine generierende Funktion $\mathcal{E}$, deren gr\"o"ster Fixpunkt die Relation
$\eq$ ist, die alle rekursiven Typen enth\"alt, die als gleich angesehen werden sollen.

{\bf TODO:} Gebundene Umbenennung (nicht notwendig, da $\free{\tau} = \emptyset$, Substitution mit rekursiven Typen.

\begin{definition}[Gleichheit von rekursiven Typen] \label{definition:Lort:Typgleichheit} \
  \begin{enumerate}
    \item Sei $\mathcal{E}: \mathcal{P}(\setType\times\setType) \to \mathcal{P}(\setType\times\setType)$ die
          wie folgt definierte monotone Funktion.
          \[\begin{array}{rcl}
            \mathcal{E}(R) & =  & \{(\tau_\beta,\tau_\beta)\ |\ \tau_\beta \in \{\typeBool,\typeInt,\typeUnit\}\} \\
                  &\cup& \{(\typeArrow{\tau_1}{\tau_2},\typeArrow{\tau_1'}{\tau_2'})\ |\ (\tau_1,\tau_1')\in R \wedge
                           (\tau_2,\tau_2')\in R\} \\
                  &\cup& \{(\typeObject{{m_i:\tau_i}^{i=1 \ldots n}},\typeObject{{m_i:\tau_i'}^{i=1 \ldots n}})\ |\ 
                           \forall i=1,\ldots,n:(\tau_i,\tau_i')\in R\} \\
                  &\cup& \{(\typeRec{t}{\tau},\tau')\ |\ (\tau\SUB{\typeRec{t}{\tau}}{t},\tau')\in R\} \\
                  &\cup& \{(\tau',\typeRec{t}{\tau})\ |\ (\tau',\tau\SUB{\typeRec{t}{\tau}}{t})\in R \wedge
                           \tau'\not\in\{\typeRec{t'}{\tau''}|t'\in\setTName,\tau''\in\setType\}\}
          \end{array}\]

    \item Die Relation $\eq$ ist definiert als der gr\"o"ste Fixpunkt von $\mathcal{E}$, also $\tau \eq \tau'$ genau
          dann wenn $(\tau,\tau')\in\nu \mathcal{E}$.
  \end{enumerate}
\end{definition}

Bevor wir nun das Regelwerk f\"ur das Typsystem an diese neue Definition der Typgleichheit anpassen, zeigen
wir zun\"achst einige wichtige Eigenschaften der Relation $\eq$. Wir beginnen damit zu zeigen, dass die
Typgleichheit eine \"Aquivalenzrelation ist.

\begin{lemma} \
  \begin{enumerate}
    \item $\eq$ ist reflexiv.
    \item $\eq$ ist transitiv.
    \item $\eq$ ist symmetrisch.
    \item $\eq$ ist eine \"Aquivalenzrelation.
  \end{enumerate}
\end{lemma}

\begin{beweis} \
  \begin{enumerate}
    \item Um zu zeigen, dass $\nu \mathcal{E}$ reflexiv ist, gen\"ugt es nach dem Koinduktionsprinzip
          (Korollar~\ref{korollar:math:Prinzip_der_Koinduktion}) zu zeigen, dass die Menge
          \[\begin{array}{rcl}
            \name{Refl} := \{(\tau,\tau)\ |\ \tau\in\setType\}
          \end{array}\]
          $\mathcal{E}$-konsistent ist, also $\name{Refl} \subseteq \mathcal{E}(\name{Refl})$. Dazu zeigen wir f\"ur
          jedes $\tau\in\setType$, dass $(\tau,\tau)\in\mathcal{E}(\name{Refl})$ gilt.
          \PROOFCASEbeg
            \item F\"ur $\tau \in \{\typeBool,\typeInt,\typeUnit\}$ gilt $(\tau,\tau)\in\mathcal{E}(R)$
                  f\"ur alle $R \subseteq \setType\times\setType$, also insbesondere auch f\"ur
                  $R = \name{Refl}$.

            \item Wenn $\tau = \typeArrow{\tau_1}{\tau_2}$, dann gilt bereits $(\tau_1,\tau_1)\in \name{Refl}$
                  und $(\tau_2,\tau_2)\in \name{Refl}$, und daraus folgt
                  $(\typeArrow{\tau_1}{\tau_2},\typeArrow{\tau_1}{\tau_2})\in\mathcal{E}(\name{Refl})$.

            \item F\"ur $\tau = \typeObject{{m_i:\tau_i}^{i=1 \ldots n}}$ gilt entsprechend
                  $(\tau_i,\tau_i)\in \name{Refl}$, und es folgt unmittelbar
                  $(\typeObject{{m_i:\tau_i}^{i=1 \ldots n}},\typeObject{{m_i:\tau_i}^{i=1 \ldots n}})
                   \in \mathcal{E}(\name{Refl})$.

            \item Bleibt der Fall von rekursiven Typen $\tau = \typeRec{t}{\tau'}$ zu betrachten.
                  Nach Definition ({\bf TODO:} Definition \"uber Substitution mit rekursiven Typen)
                  gilt $(\typeRec{t}{\tau'})\SUB{\typeRec{t}{\tau'}}{t} = \typeRec{t}{\tau'}$, also
                  ist auch $((\typeRec{t}{\tau'})\SUB{\typeRec{t}{\tau'}}{t}, \typeRec{t}{\tau'})\in \name{Refl}$.
                  Gem\"a"s Definition~\ref{definition:Lort:Typgleichheit} folgt somit
                  $(\typeRec{t}{\tau'},\typeRec{t}{\tau'})\in\mathcal{E}(\name{Refl})$.
          \PROOFCASEend

    \item TODO

    \item TODO

    \item Folgt unmittelbar aus (a), (b) und (c).
  \end{enumerate}
\end{beweis}

\begin{definition}[Gleichheit von rekursiven Typen] \
  \begin{enumerate}
    \item F\"ur eine Menge von Annahmen $A \subseteq \mathcal{P}(\setTypearrow \times \setTypearrow)$ und zwei
          (rekursive) Typen $\tau_1,\tau_2 \in\setTypearrow$ heisst die Formel $A \vdash \tau_1 \eq \tau_2$
          g\"ultig, wenn sie sich mit den folgenden Regeln herleiten l\"a"st: \\[5mm]
          \begin{tabular}{lll}
            \RN{Eq-Refl} & $A \vdash \tau \eq \tau$ \\[1mm]
            \RN{Eq-Assume} & $\RULE{(\tau_1 \eq \tau_2) \in A}
                                   {A \vdash \tau_1 \eq \tau_2}$ \\[2mm]
            \RN{Eq-Symm} & $\RULE{A' \vdash \tau_2 \eq \tau_1}
                                 {A \vdash \tau_1 \eq \tau_2}$
                                 & mit $A' = A \cup \{\tau_1 \eq \tau_2\}$ \\[2mm]
            \RN{Eq-Trans} & $\RULE{A' \vdash \tau_1 \eq \tau_2
                                   \quad
                                   A' \vdash \tau_2 \eq \tau_3}
                                  {A \vdash \tau_1 \eq \tau_3}$
                                  & mit $A' = A \cup\{\tau_1 \eq \tau_3\}$ \\[2mm]
            \RN{Eq-Arrow} & $\RULE{A' \vdash \tau_1 \eq \tau_1'
                                   \quad
                                   A' \vdash \tau_2 \eq \tau_2'}
                                  {A \vdash \typeArrow{\tau_1}{\tau_2}
                                   \eq \typeArrow{\tau_1'}{\tau_2'}}$ 
                                  & mit $A' = A \cup \{\typeArrow{\tau_1}{\tau_2}
                                   \eq\typeArrow{\tau_1'}{\tau_2'}\}$ \\[2mm]
            \RN{Eq-Mu-Left} & $\RULE{A' \vdash \tau_1\SUB{\typeRec{t}{\tau_1}}{t}
                                     \eq \tau_2}
                                    {A \vdash \typeRec{t}{\tau_1} \eq \tau_2}$
                                   & mit $A' = A \cup \{\typeRec{t}{\tau_1} \eq \tau_2\}$ \\[2mm]
            \RN{Eq-Mu-Right} & $\RULE{A' \vdash \tau_1
                                     \eq  \tau_2\SUB{\typeRec{t}{\tau_2}}{t}}
                                    {A \vdash \tau_1 \eq \typeRec{t}{\tau_2}}$
                                   & mit $A' = A \cup \{\tau_1 \eq \typeRec{t}{\tau_2}\}$ \\[2mm]
          \end{tabular}

    \item Damit definieren wir die Relation $R_{\eq}$ wie folgt:
          \[\begin{array}{l}
            R_{\eq} := \{(\tau_1,\tau_2) \in \setTypearrow\times\setTypearrow\ |\ 
                                     \emptyset \vdash \tau_1 \eq \tau_2\}
          \end{array}\]
          Statt $(\tau_1,\tau_2)\in R_{\eq}$ schreiben wir kurz $\tau_1 \eq \tau_2$.
  \end{enumerate}
\end{definition}

{\bf TODO:} Prosa.

\begin{korollar}
  $R_{\eq}$ ist eine \"Aquivalenzrelation.
\end{korollar}

\begin{beweis}
  Folgt unmittelbar aus der Definition.
\end{beweis}

{\bf TODO:} \"Uberleitung

\begin{definition}[G\"ultige Typurteile f\"ur \Lort] \label{definition:Lort:Gueltige_Typurteile}
  \index{Typregeln!f\"ur die Sprache \Lort}
  Ein Typurteil $\Tj{\Gamma}{e}{\tau}$ oder $\Tj{\Gamma}{r}{\phi}$ heisst g\"ultig f\"ur \Lort,
  wenn es sich mit der neuen Typregel \\[5mm]
  \begin{tabular}{ll}
    \RN{Equal} & $\RULE{\Tj{\Gamma}{e}{\tau'} \quad \tau' \eq \tau}
                       {\Tj{\Gamma}{e}{\tau}}$
  \end{tabular} \\[7mm]
  und den Typregeln der Programmiersprache \Lot\ (Definition~\ref{definition:Lot:Gueltige_Typurteile})
  herleiten l\"a"st, wobei die \RN{Object}-Regel von \Lot\ durch \\[5mm]
  \begin{tabular}{ll}
    \RN{Object} & $\RULE{\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi} \quad \tau \eq \typeObject{\phi}}
                        {\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau}}$
  \end{tabular} \\[7mm]
  ersetzt wird.
\end{definition}

{\bf TODO:} Typsicherheit

\begin{lemma}[Typumgebungen und frei vorkommende Namen] \label{lemma:Lort:free_und_dom_Gamma} \
  \begin{enumerate}
    \item $\forall \Gamma \in \setTEnv, e\in\setExp,\tau\in\setType:\,
           \Tj{\Gamma}{e}{\tau}\,\Rightarrow\,\free{e}\subseteq\dom{\Gamma}$
    \item $\forall \Gamma \in \setTEnv, r\in\setRow,\phi\in\setRType:\,
           \Tj{\Gamma}{r}{\phi}\,\Rightarrow\,\free{r}\subseteq\dom{\Gamma}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Der Beweis erfolgt wie gehabt durch simultane Induktion \"uber die L\"ange der Herleitungen der
  Typurteile $\Tj{\Gamma}{e}{\tau}$ und $\Tj{\Gamma}{r}{\phi}$, und Fallunterscheidung nach der
  zuletzt angewandten Typregel. Dazu betrachten wie hier lediglich die F\"alle f\"ur die
  \RN{Equal} und \RN{Object} Regeln.
  \PROOFCASEbeg
    \item $\Tj{\Gamma}{e}{\tau}$ mit Typregel \RN{Equal} bedingt $\Tj{\Gamma}{e}{\tau'}$ mit
          $\tau' \eq \tau$. Also folgt die Behauptung mit Induktionsvoraussetzung.

    \item F\"ur $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau}$ mit Typregel \RN{Object} gilt nach
          Voraussetzung $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$ und $\tau = \typeObject{\phi}$.
          Nach Induktionsvoraussetzung folgt
          \EQNbeg
            \free{r} & \subseteq & \dom{\Gamma^\star\SUB{\tau}{\self}}
          \EQNend
          und mit Definition~\ref{definition:Lo:Frei_vorkommende_Namen} folgt
          \EQNbeg
            \free{\expObject{\self:\tau}{r}} & = & \free{r} \setminus \{\self\} \\
                                             & \subseteq & \dom{\Gamma^\star\SUB{\tau}{\self}} \setminus \{\self\} \\
                                             & = & (\dom{\Gamma^\star} \cup \{\self\}) \setminus \{\self\} \\
                                             & \subseteq & \dom{\Gamma^\star} \\
                                             & \subseteq & \dom{\Gamma}.
          \EQNend
          Die \"Anderung der \RN{Object}-Regel hat also keinen Einfluss auf den Beweis.
  \PROOFCASEend
  Die \"ubrigen F\"alle sind v\"ollig identisch zum Beweis von Lemma~\ref{lemma:Lot:free_und_dom_Gamma}.
\end{beweis}

{\bf TODO:} Bla blub

\begin{lemma}[Koinzidenzlemma] \label{lemma:Lort:Koinzidenzlemma} \
  \begin{enumerate}
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, e \in \setExp, \tau \in \setType:\,
           \Tj{\Gamma_1}{e}{\tau}\,\wedge\,\Gamma_1 =_{\free{e}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{e}{\tau}$
    \item $\forall \Gamma_1,\Gamma_2 \in \setTEnv, r \in \setRow, \phi \in \setRType:\,
           \Tj{\Gamma_1}{r}{\phi}\,\wedge\,\Gamma_1 =_{\free{r}} \Gamma_2
           \ \Rightarrow \ 
           \Tj{\Gamma_2}{r}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Der Beweis erfolgt wie gehabt durch simultane Induktion \"uber die L\"ange der Herleitungen
  der Typurteile $\Tj{\Gamma_1}{e}{\tau}$ und $\Tj{\Gamma_2}{r}{\phi}$, und Fallunterscheidung
  nach der jeweils zuletzt angewandten Typregel. Im wesentlichen ist der Beweis identisch zum
  Beweis des Koinzidenzlemmas f\"ur die Sprache \Lot\ (Lemma~\ref{lemma:Lot:Koinzidenzlemma}), neu
  hinzu kommt lediglich der Fall f\"ur die \RN{Equal}-Regel, hier folgt aber die Behauptung
  unmittelbar mit Induktionsvoraussetzung.
\end{beweis}
%
{\bf TODO:} Prosa
%
\begin{lemma}[Typurteile und Substitution] \label{lemma:Lort:Typurteile_und_Substitution}
  Sei $\id \in \setAttribute \cup \setVar$, $\Gamma \in \setTEnv$, $\tau \in \setType$
  und $e \in \setExp$. Dann gilt:
  \begin{enumerate}
    \item $\forall e' \in \setExp:
           \forall \tau' \in \setType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{e'}{\tau'} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{e'\SUB{e}{\id}}{\tau'}$
    \item $\forall r \in \setRow:
           \forall \phi \in \setRType:\,
           \Tj{\Gamma\SUB{\tau}{\id}}{r}{\phi} \wedge \Tj{\Gamma^\star}{e}{\tau}
           \,\Rightarrow\,
           \Tj{\Gamma}{r\SUB{e}{\id}}{\phi}$
  \end{enumerate}
\end{lemma}

\begin{beweis}
  Verl\"auft analog zum Beweis von Lemma~\ref{lemma:Lot:Typurteile_und_Substitution} f\"ur die Programmiersprache
  \Lot. Der Fall f\"ur die neue Typregel \RN{Equal} folgt trivialerweise mit Induktionsvoraussetzung.
\end{beweis}

\begin{lemma}[Typurteile und \self-Substitution] \label{lemma:Lort:Typurteile_und_self_Substitution}
  Sei $\Gamma \in \setTEnv$, $\self\in\setSelf$,\linebreak[4] $\tau\in\setType$ und $r\in\setRow$. Dann gilt:
  \renewcommand{\labelenumii}{(\arabic{enumii})}
  \begin{enumerate}
    \item F\"ur alle $e\in\setExp$ und $\tau'\in\setType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{e}{\tau'}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{e\SUB{\expObject{\self:\tau}{r}}{\self}}{\tau'}$
          \end{enumerate}

    \item F\"ur alle $r'\in\setRow$ und $\phi\in\setRType$:
          \begin{enumerate}
            \item $\Tj{\Gamma\SUB{\tau}{\self}}{r'}{\phi}$
            \item $\Tj{\Gamma^\star}{\expObject{\self:\tau}{r \oplus r'}}{\tau}$
            \item $\forall a\in\dom{\Gamma}\cap\setAttribute,\tau_a\in\setType:\,
                   \Tj{\Gamma^\star}{r(a)}{\tau_a}\,\Leftrightarrow\,\Tj{\Gamma}{a}{\tau_a}$
            \item[$\Rightarrow$] $\Tj{\Gamma}{r'\SUB{\expObject{\self:\tau}{r \oplus r'}}{\self}}{\phi}$
          \end{enumerate}
  \end{enumerate}
  \renewcommand{\labelenumii}{\arabic{enumii}.}
\end{lemma}

\begin{beweis}
  Entspricht im wesentlichen dem Beweis des Lemmas \"uber $\self$-Substitution f\"ur die Programmiersprache
  \Lot\ (Lemma~\ref{lemma:Lot:Typurteile_und_self_Substitution}). Wie nicht anders zu erwarten folgt der Fall der
  \RN{Equal}-Regel sofort mit Induktionsvoraussetzung.
\end{beweis}

\begin{lemma}[Umkehrung der Typrelation] \label{lemma:Lort:Umkehrung_der_Typrelation} \
  \begin{enumerate}
    \item Wenn $\Tj{\Gamma}{\op}{\tau}$, dann gilt $\tau=\typeIntIntInt$ f\"ur $\op\in\{+,-,*\}$
          oder $\tau=\typeIntIntBool$ f\"ur $\op\in\{\le,\ge,<,>,=\}$.
    \item Wenn $\Tj{\Gamma}{\expApp{e_1}{e_2}}{\tau}$, dann gilt $\Tj{\Gamma}{e_1}{\typeArrow{\tau_2'}{\tau}}$,
          $\Tj{\Gamma}{e_2}{\tau_2}$ und $\tau_2 <: \tau_2'$.
    \item Wenn $\Tj{\Gamma}{\expAbstr{x:\tau_1}{e}}{\typeArrow{\tau_1'}{\tau_2}}$, dann gilt
          $\Tj{\Gamma\SUB{\tau_1}{x}}{e}{\tau_2}$ und $\tau_1' <: \tau_1$.
    \item Wenn $\Tj{\Gamma}{\expObject{\self:\tau}{r}}{\tau'}$, dann gilt
          $\Tj{\Gamma^\star\SUB{\tau}{\self}}{r}{\phi}$, $\tau = \typeObject{\phi}$ und $\tau <: \tau'$.
  \end{enumerate}
\end{lemma}

\begin{beweis}
  TODO
\end{beweis}

% vi:set ts=2 sw=2 et ai syntax=tex:
