\documentclass[fleqn,landscape,titlepage,german]{myslides}
%
% Praesentation der Projektgruppe TPML, 2006
%
% 2006 Benedikt Meurer <benny@xfce.org>
% 2006 Marcell Fischbach <marcellfischbach@gmx.de>
%
 
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{german}
\usepackage{ngerman}

% Einkommentieren, um Handouts zu generieren
%\createhandoutstrue

\begin{document}
  
\presentation[TPML 1.0]{Marcell\,Fischbach,\,Benedikt\,Meurer}{TPML 1.0 - Ein interaktives Lernwerkzeug}
\maketitle

\addoverviewitem{Einleitung}
\addoverviewitem{Die Sprachen}
\addoverviewitem{Die Kernkomponenten}
\addoverviewitem{Die Benutzerschnittstelle}
\addoverviewitem{Fazit}

\CenteredGraphics



%%
%% Einleitung
%%

\makeoverviewslide

\myslide{Die Vorlesung ,,Theorie der Programmierung I''}{
  \begin{itemgroup}{,,Theorie der Programmierung I''}
    \item Vermittelt Grundlagen von Programmiersprachen anhand einfacher funktionaler Programmiersprache (orientiert an O'Caml)
    \item Operationelle Semantik anhand von small und big steps
    \item Typsysteme (Polymorphie, Typinferenz)
    \item Pflichtveranstaltung f"ur Informatik-Studenten
  \end{itemgroup}

  \animate{1}{
    {\bf Problem:} Einstieg in den Stoff wird als schwierig empfunden!
  }
}

\myslide{Motivation I}{
  {\bf Frage:} Warum ein Programm zur ,,Theorie der Programmierung''?

  \animate{1}{
    \begin{itemgroup}{Gr"unde}
      \item Erleichterter Zugang zu theoretischen Inhalten.
      \item Regelwerk durch ,,praktisches Arbeiten'' besser zu verstehen.
      \item ,,Gef"uhl'' f"ur Interpreter und Typsysteme vermitteln.
      \item Hilfestellung bei der Pr"ufungsvorbereitung ($\to$ nicht auf Beispiele aus "Ubung/Vorlesung beschr"anken)
      \item Verst"andnis f"ur Zusammenhang von Programmtext und Ausf"uhrung auf einer Maschine.
    \end{itemgroup}
  }
}

\myslide{Motivation II}{
  \begin{itemgroup}{Warum nicht O'Caml?}
    \item ,,Echte Implementierungen'' ungeeignet.
    \item Abl"aufe nicht sichtbar f"ur den Benutzer
    \item Typfehler von O'Caml schwer verst"andlich
    \item Semantik nicht zug"anglich\\ ($\to$ wird in Byte/native Code kompiliert)
    \item Fehlende formale Spezifikation!
  \end{itemgroup}

  \animate{1}{
    {\bf Folgerung:} Spezielles Lernprogramm besser geeignet.
  }
}

\myslide{Ziele}{
  \begin{itemgroup}{Ziele der Entwicklung}
    \item Geeignete Visualierung von Abl"aufen.
    \item Leichter Zugang zum Regelwerk.
    \item Leicht erweiterbar ($\to$ Vorlesung sehr dynamisch).
    \item Plattformunabh"angig einsetzbar.
    \item Flache Lernkurve ($\to$ IDE)
  \end{itemgroup}
}

\myslide{Planung I}{
  {\bf Dazu:} Planung der Ziele im einzelnen.

  \animate{1}{
    \begin{itemgroup}{Geeignete Visualierung von Abl"aufen}
      \item User Interface soll Darstellung aus der Vorlesung bzw. "Ubung\\ entsprechen.
      \item Benutzer kann selbstst"andig t"atig werden.
      \item Programm kann automatisch vervollst"andigen\\ (Schrittweise/Komplett).
    \end{itemgroup}
  }
}

\myslide{Planung II}{
  \begin{itemgroup}{Leichter Zugang zum Regelwerk}
    \item Unterschiedliche Sprachen verf"ugbar (derzeit ${\cal L}_0$ bis ${\cal L}_4$).
    \item Inkrementelles Erlernen komplexerer Sprachfeatures m"oglich.
    \item Benutzer wird nicht direkt mit der M"achtigkeit\\ ($\to$ Un"ubersichtlichkeit) von ${\cal L}_4$ konfrontiert.
  \end{itemgroup}
}

\myslide{Planung III}{
  \begin{itemgroup}{Leicht erweiterbar}
    \item Vorlesung ,,Theorie der Programmierung'' "andert sich j"ahrlich.
    \item Neue Konzepte kommen hinzu.
    \item Programm soll einfach um neue Sprachen erweiterbar sein.
    \item Benutzerschnittstelle soll um neue Features erweiterbar sein \\ ($\to$ Highlighting von Bindungen).
  \end{itemgroup}
}

\myslide{Planung IV}{
  \begin{itemgroup}{Plattformunabh"angig einsetzbar}
    \item Programm sollte ,,out-of-the-box'' funktionieren \\ ($\to$ keine Installation).
    \item M"oglichst unabh"angig von einer speziellen Plattform \\ ($\to$ nur ein Binary/Download).
    \item Wahl zugunsten Java 5.0, O'Caml Framework ungeeignet \\ f"ur die Benutzerschnittstelle.
  \end{itemgroup}

  \animate{1}{
    \begin{itemgroup}{Flache Lernkurve}
      \item Benutzerschnittstelle angelehnt an g"angige IDEs.
      \item M"oglichst keine Einrichtung notwendig.
    \end{itemgroup}
  }
}

\myslide{Realisierung I}{
  {\bf Realisierung:} Projekt in drei Teilprojekte aufteilen.

  \begin{itemgroup}{Teilprojekte}
    \item {\tt de.unisiegen.tpml.core}      - Die Kernkomponenten Typechecker, Interpretern, Parsern, Lexern, Pretty Printern, \ldots
    \item {\tt de.unisiegen.tpml.graphics}  - Untere Ebene der Benutzeroberfl"ache mit Texteditor, big und small step und Typechecker Oberfl"ache
    \item {\tt de.unisiegen.tpml.ui}        - Obere Ebene der Benutzeroberfl"ache die alles zusammenf"ugt
  \end{itemgroup}
  \graphicybox{5cm}{images/realisierung.pdf}
}

\myslide{Realisierung II}{
  \begin{itemgroup}{Werkzeuge}
    \item Plattform: JavaSE 5.0
    \item Entwicklungsumgebung: Eclipse 3.1.2
    \item GUI Builder: NetBeans 5.0
    \item Lexer Generator: JFlex 1.4.1
    \item Parser Generator: JavaCUP 11a
    \item Protokollierung: log4j 1.2.14
  \end{itemgroup}

  \begin{itemgroup}{Grundlage}
    \item Vorlesungsinhalt ,,Theorie der Programmierung I'' (2005/2006)
    \item OCaml 3.09.3
  \end{itemgroup}
}



%%
%% Die Sprachen
%%

\makeoverviewslide

\myslide{Die Sprachen I}{
  \begin{itemgroup}{TPML modular/erweiterbar}
    \item Vorlesung beginnt mit einfachem, ungetypten $\lambda$-Kalk"ul.
    \item Inkrementelle Erweiterung der Sprache.
    \item Bis hin zu imperativen und objekt-orientierten Konzepten.
    \item Programm soll diese Lernkurve wiederspiegeln.
  \end{itemgroup}

  \animate{1}{
    {\bf Dazu:} Mehrere aufeinander aufbauende Sprachen.
  }
}

\myslide{Die Sprachen II}{
  \begin{itemgroup}{Die Sprachen im "Uberblick}
    \item ${\cal L}_0$ - ungetypter $\lambda$-Kalk"ul.
    \item ${\cal L}_1$ - einfach getypter $\lambda$-Kalk"ul.
    \item ${\cal L}_2$ - ${\cal L}_1$ mit Rekursion.
    \item ${\cal L}_3$ - polymorph getypte Sprache mit Listen und Tupeln.
    \item ${\cal L}_4$ - imperative Konzepte (Speicher, Schleifen).
  \end{itemgroup}

  \animate{1}{
    {\bf Beispiel:} {\tt let id = lambda x:int.x in id 1} geht erst ab ${\cal L}_1$,\\
    da ${\cal L}_0$ kein {\tt let} enth"alt.
  }
}

\myslide{Die Sprachen III}{
  \begin{itemgroup}{Realisierung}
    \item Benutzer w"ahlt beim Erstellen neuer Datei eine Sprache.
    \item Analog zu IDEs ($\to$ {\tt .java}, {\tt .cpp}, \ldots).
    \item Sprache bestimmt dann Programmverhalten (Typregeln,\\ Semantikregeln, Syntaxhighlighting, \ldots).
  \end{itemgroup}

  \animate{1}{
    {\bf Dazu:} Generische Komponenten, Regelwerk wird aus der Sprache geladen.
  }
}



%%
%% Die Kernkomponenten
%%

\makeoverviewslide

\myslide{"Uberblick I}{
  \begin{itemgroup}{Kernkomponenten}
    \item Abstract Syntax Tree
    \item Small step Interpreter
    \item Big step Interpreter
    \item Type Checker
    \item Parser/Lexer
    \item Pretty Printer
  \end{itemgroup}

  \animate{1}{
    \begin{itemgroup}{Ziele}
      \item \cemph{Generische} Komponenten (Big/Small Stepper, Type Checker)
      \item Sprachabh"angige Teile \cemph{isolieren}
      \item Einziger Abstract Syntax Tree
    \end{itemgroup}
  }
}

\myslide{"Uberblick II}{
  {\bf "Uberblick:} Datenflu"s zwischen den Kernkomponenten

  \graphicxbox{24cm}{images/overview.pdf}

  \begin{itemize}
    \item grobe Strukturierung
    \item einige Komponenten mehrfach vorhanden (z.B. Parser/Lexer)
  \end{itemize}
}

\myslide{"Uberblick III}{
  \begin{itemgroup}{Voraussetzung:}
    \item Unterschiedliche Sprachen (nur teilweise aufeinander aufbauend)
    \item Parser, Lexer, abstrakte Syntax (und damit Pretty Printer), Big/Small Stepper, Type Checker augenscheinlich sprachabh"angig
  \end{itemgroup}

  {\bf Problem:} Jede Komponente pro Sprache realisieren w"are zu aufwendig/nicht wartbar

  {\bf L"osung:} Aufteilung in sprachabh"angige/-unabh"angige Teile
}

\myslide{"Uberblick IV}{
  {\bf Aufteilung:} Sprachabh"angige/-unabh"angige Teile

  \graphicxbox{18cm}{images/separierung.pdf}

  \begin{itemize}
    \item AST, PrettyPrinter, Parser/Lexer klar
    \item Interpreter, Type Checker aufspalten
  \end{itemize}
}

\myslide{Die abstrakte Syntax I}{
  {\bf Vorlesung:} Abstrakte Syntax der Ausdr"ucke
  \begin{eqnarray*}
    op & ::= & +\,|\,-\,|\,*\,|\,\textbf{mod}\,|\,\ldots \\
    \\
    c & ::= & op \\
      & |   & n \quad \quad (n \in {\mathord{\mathbb Z}}) \\
      & |   & \ldots \\
    \\
    e & ::= & c \\
      & |   & id \\
      & |   & \lambda id.e_1 \\
      & |   & e_1\,e_2 \\
      & |   & \textbf{rec}\,id.e_1 \\
      & |   & \textbf{let}\,id = e_1\,\textbf{in}\,e_2 \\
      & |   & \textbf{if}\,e_0\,\textbf{then}\,e_1\,\textbf{else}\,e_2 \\
      & |   & \ldots
  \end{eqnarray*}
}

\myslide{Die abstrakte Syntax II}{
  \begin{itemgroup}{Abstrakte Syntax}
    \item Darstellung m"oglichst nahe an der Vorlesung
    \item Realisierung durch \cemph{Vererbung} in Java (einfache Hierarchie)
  \end{itemgroup}

  \graphicybox{10cm}{images/ast.pdf}
}

\myslide{Die abstrakte Syntax III}{
  \begin{itemgroup}{Syntaktischer Zucker}
    \item eigene Klassen f"ur syntaktischen Zucker
    \item z.B. {\tt LetRec} f"ur $\textbf{let rec}\,id=e_1\,\textbf{in}\,e_2$
    \item oder {\tt CurriedLet} f"ur $\textbf{let}\,id\ id_1\,\ldots\,id_n = e_1\,\textbf{in}\,e_2$
  \end{itemgroup}

  \animate{1}{
    "Ubersetzung in Kernsyntax durch sprachabh"angigen {\tt LanguageTranslator}
    \begin{itemize}
      \item erm"oglicht Konstrukte sp"ater in Kernsyntax zu "ubernehmen
      \item z.B. {\bf let} syntaktischer Zucker f"ur $\mathcal{L}_1$ aber Kernsyntax f"ur $\mathcal{L}_1^{typed}$
    \end{itemize}

    Zwei Modi f"ur {\tt LanguageTranslator}: {\em outermost only} und {\em recursive}
  }
}

\myslide{Die konkrete Syntax}{
  \begin{itemgroup}{Konkrete Syntax:}
    \item Definitiv \cemph{sprachabh"angig}
    \item Eigene Lexer/Parser pro Sprache
    \item Lexer f"ur \cemph{Syntaxhighlighting} im Editor benutzen
  \end{itemgroup}

  \animate{1}{
    \begin{itemgroup}{Dazu:}
      \item Gemeinsame Schnittstellen {\tt LanguageScanner} und {\tt LanguageParser} f"ur alle Lexer/Parser.
      \item Parser durch {\tt Java CUP}, Lexer durch {\tt JFlex} generieren.
    \end{itemgroup}

    {\bf Beachte:} Konkrete Syntax nicht 100\%ig gleich abstrakter Syntax, z.B. {\tt lambda id:'a\,->\,'b.e} statt $\lambda id:\alpha\to\beta.e$, etc.
  }
}

\myslide{Der Pretty Printer}{
  \begin{itemgroup}{Pretty Printing}
    \item \cemph{Sprachunabh"angig}, basierend auf abstrakter Syntax
    \item ,,Umkehrung'' des Parsings, Prinzip der \cemph{,,Priority Grammars''} zur Klammerung
    \item {\tt PrettyString} als Repr"asentation mit zus"atzlichen Informationen
    \item {\tt PrettyPrintable} implementiert in {\tt Expression} und {\tt Type}
    \item {\tt PrettyStringBuilder} zum Konstruieren von {\tt PrettyString}s
  \end{itemgroup}
}

\myslide{ProofModels}{
  {\bf Idee:} Big/Small Stepper und Type Checker aufteilen in sprachabh"angige/unabh"angige Teile

  \animate{1}{
    \begin{itemgroup}{Sprachunabh"angiger Teil}
      \item Bietet zwei Schnittstellen:
      \item zum sprachabh"angigen Teil
      \item zum User Interface
    \end{itemgroup}

    {\bf Schnittstelle zur Sprache:} Regeln ({\tt ProofRuleSet}s) in das {\tt ProofModel} laden

    {\bf Schnittstelle zum UI:} Baumdarstellung basierend auf {\tt TreeModel} (Swing)
  }
}

\myslide{ProofRuleSets}{
  \begin{itemgroup}{Schnittstelle zur Sprache}
    \item Sprachen bieten Regeln, z.B. {\tt BigStepProofRule}s
    \item Regeln angeordnet in {\tt ProofRuleSet}s
    \item Regeln interagieren mit spezifischem {\tt ProofModel} "uber {\tt ProofContext}s
  \end{itemgroup}

  \animate{1}{
    \begin{itemgroup}{Big step und Type Checker Regeln:}
      \item {\tt apply()} zum Anwenden auf Knoten
      \item {\tt update()} f"ur z.B. {\bf (LET)}
    \end{itemgroup}

    Small stepper hingegen ,,wei"s'' Regeln exakt und vergleicht lediglich Benutzerauswahl ($\to$ Eindeutigkeit des small steps)
  }
}

\myslide{ProofContexts}{
  {\bf Frage:} Regeln interagieren "uber {\tt ProofContext}s statt direkt mit {\tt ProofModel}?

  \animate{1}{
    \begin{itemize}
      \item {\tt ProofContext} als \cemph{Protokollierungsschicht} zwischen Regeln und Model
      \item kann Schritte f"ur \cemph{Undo}/\cemph{Redo} bestimmen
      \item Undo/Redo damit transparent f"ur Model und Regeln, keine explizite Programmierung erforderlich
    \end{itemize}
  }
}

\myslide{TreeModel}{
  \begin{itemgroup}{Schnittstelle zum UI}
    \item grunds"atzlich alle drei \cemph{baumartige} Strukturen
    \item basierend auf {\tt javax.swing.tree.TreeModel}
    \item da existierendes Framework ($\to$ well-tested code)
    \item leichter zu debuggen, z.B. mittels {\tt JTree}
  \end{itemgroup}

  {\bf Small stepper:} Darstellung als degenerierter Baum
}

\myslide{ProofModels revisited}{
  {\bf Zusammenfassung:} Big/Small step und Type Checker {\tt ProofModel}s

  \begin{itemize}
    \item Sprachunabh"angiger, generischer Kern
    \item Schnittstelle zum Regelwerk (sprachabh"angig)
    \item Schnittstelle zum UI (sprachneutral)
    \item Beispielhaft: das {\tt BigStepProofModel}
  \end{itemize}

  \graphicybox{4cm}{images/proofmodels.pdf}
}



%%
%% Die Benutzerschnittstelle
%%

\makeoverviewslide

\include{renderer}



%%
%% Fazit
%%

\makeoverviewslide

\myslide{Fazit}{
  {\bf Fazit:} Projektgruppe ,,TPML 1.0''

  \begin{itemize}
    \item Kleine Projektgruppengr"osse vorteilhaft.
    \item Flexible Einteilung, (fast) keine fixen Termine.
    \item Erst ,,Extreme Prototyping'', dann ,,saubere Implementierung''.
    \item Flexible Zielsetzung, inkrementell in kleinen Schritten.
    \item Feedback der Teilnehmer von ,,TP I'' bisher durchweg positiv.
  \end{itemize}
}



\end{document}

