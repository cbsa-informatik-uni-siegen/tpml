Package l1;


Helpers
 digit = ['0' .. '9'];
 letter = [['a' .. 'z'] + ['A' .. 'Z']];


Tokens
 blank = (' ' | 13 | 10)+;

 plus = '+';
 minus = '-';
 multiply = '*';
 divide = '/';
 modulo = 'mod';
 lower_than = '<';
 greater_than = '>';
 lower_equal = '<=';
 greater_equal = '>=';
 equal = '=';
 left_paren = '(';
 right_paren = ')';
 comma = ',';
 dot = '.';
 and = '&&';
 or = '||';

 if = 'if';
 then = 'then';
 else = 'else';
 lambda = 'lambda';
 let = 'let';
 in = 'in';
 rec = 'rec';
 fst = 'fst';
 snd = 'snd';
 projection = '#' digit+ '_' digit+;
 ref = 'ref';
 deref = '!';

 unit = '()';
 true = 'true';
 false = 'false';
 number = digit+;
 
 identifier = letter (digit | letter)*;


Ignored Tokens
 blank;


Productions
 expression =
  {conjunction} conjunction {-> conjunction.expression} |
  {condition} if [e0]:conjunction then [e1]:expression else [e2]:expression {-> New expression.condition(e0.expression, e1, e2)} |
  {let} let identifier equal [e1]:expression in [e2]:expression {-> New expression.let(identifier, e1, e2)} |
  {letrec} let rec identifier equal [e1]:expression in [e2]:expression {-> New expression.letrec(identifier, e1, e2)} |
  {abstraction} lambda identifier dot [e]:expression {-> New expression.abstraction(identifier, e)} |
  {recursion} rec identifier dot [e]:expression {-> New expression.recursion(identifier, e)};

 conjunction {-> expression} =
  {comparison} comparison {-> comparison.expression} |
  {or} [e1]:conjunction or [e2]:comparison {-> New expression.or(e1.expression, e2.expression)} |
  {and} [e1]:conjunction and [e2]:comparison {-> New expression.and(e1.expression, e2.expression)};

 comparison {-> expression} =
  {term} term {-> term.expression} |
  {lower_than} comparison lower_than term {-> New expression.infix(comparison.expression, New expression.lower_than(lower_than), term.expression)} |
  {greater_than} comparison greater_than term {-> New expression.infix(comparison.expression, New expression.greater_than(greater_than), term.expression)} |
  {lower_equal} comparison lower_equal term {-> New expression.infix(comparison.expression, New expression.lower_equal(lower_equal), term.expression)} |
  {greater_equal} comparison greater_equal term {-> New expression.infix(comparison.expression, New expression.greater_equal(greater_equal), term.expression)} |
  {equal} comparison equal term {-> New expression.infix(comparison.expression, New expression.equal(equal), term.expression)};

 term {-> expression} =
  {factor} factor {-> factor.expression} |
  {addition} term plus factor {-> New expression.infix(term.expression, New expression.plus(plus), factor.expression)} |
  {substraction} term minus factor {-> New expression.infix(term.expression, New expression.minus(minus), factor.expression)};

 factor {-> expression} =
  {application} application {-> application.expression} |
  {multiplication} factor multiply application {-> New expression.infix(factor.expression, New expression.multiply(multiply), application.expression)} |
  {division} factor divide application {-> New expression.infix(factor.expression, New expression.divide(divide), application.expression)} |
  {modulation} factor modulo application {-> New expression.infix(factor.expression, New expression.modulo(modulo), application.expression)};

 application {-> expression} =
  {atom} atom {-> atom.expression} |
  {application} application atom {-> New expression.application(application.expression, atom.expression)};

 atom {-> expression} =
  {constant} constant {-> constant.expression} |
  {identifier} identifier {-> New expression.identifier(identifier)} |
  {expression} left_paren [e]:expression right_paren {-> e} |
  {tuple} left_paren [l]:tuple_list comma [e]:expression right_paren {-> New expression.tuple([l.expression, e])};

 tuple_list {-> expression*} =
  {list} [l]:tuple_list comma [e]:expression {-> [l.expression, e]} |
  {single} [e]:expression {-> [e]};

 constant {-> expression} =
  {unit} unit {-> New expression.unit(unit)} |
  {bool} bool {-> bool.expression} |
  {number} number {-> New expression.number(number)} |
  {operator} left_paren operator right_paren {-> operator.expression} |
  {projection} projection {-> New expression.projection(projection)} |
  {fst} fst {-> New expression.fst(fst)} |
  {snd} snd {-> New expression.snd(snd)} |
  {ref} ref {-> New expression.ref(ref)} |
  {deref} deref {-> New expression.deref(deref)};

 bool {-> expression} =
  {true} true {-> New expression.true(true)} |
  {false} false {-> New expression.false(false)};

 operator {-> expression} =
  {plus} plus {-> New expression.plus(plus)} |
  {minus} minus {-> New expression.minus(minus)} |
  {multiply} multiply {-> New expression.multiply(multiply)} |
  {divide} divide {-> New expression.divide(divide)} |
  {modulo} modulo {-> New expression.modulo(modulo)} |
  {lower_than} lower_than {-> New expression.lower_than(lower_than)} |
  {greater_than} greater_than {-> New expression.greater_than(greater_than)} |
  {lower_equal} lower_equal {-> New expression.lower_equal(lower_equal)} |
  {greater_equal} greater_equal {-> New expression.greater_equal(greater_equal)} |
  {equal} equal {-> New expression.equal(equal)};


Abstract Syntax Tree
 expression =
  {application} [e0]:expression [e1]:expression |
  {condition} [e0]:expression [e1]:expression [e2]:expression |
  {let} [id]:identifier [e1]:expression [e2]:expression |
  {letrec} [id]:identifier [e1]:expression [e2]:expression |
  {abstraction} [id]:identifier [e]:expression |
  {recursion} [id]:identifier [e]:expression |
  {infix} [e1]:expression [op]:expression [e2]:expression |
  {and} [e0]:expression [e1]:expression |
  {or} [e0]:expression [e1]:expression |
  {tuple} [expressions]:expression+ |
  {identifier} identifier |
  {unit} unit |
  {true} true |
  {false} false |
  {number} number |
  {plus} plus |
  {minus} minus |
  {multiply} multiply |
  {divide} divide |
  {modulo} modulo |
  {lower_than} lower_than |
  {greater_than} greater_than |
  {lower_equal} lower_equal |
  {greater_equal} greater_equal |
  {equal} equal |
  {projection} projection |
  {fst} fst |
  {snd} snd |
  {ref} ref |
  {deref} deref;

