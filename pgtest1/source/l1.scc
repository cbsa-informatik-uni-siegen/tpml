Package l1;


Helpers
 digit = ['0' .. '9'];
 letter = [['a' .. 'z'] + ['A' .. 'Z']];


Tokens
 blank = (' ' | 13 | 10)+;

 plus = '+';
 minus = '-';
 multiply = '*';
 divide = '/';
 modulo = 'mod';
 lower_than = '<';
 greater_than = '>';
 lower_equal = '<=';
 greater_equal = '>=';
 equal = '=';
 uminus = '~-';
 not = 'not';
 left_paren = '(';
 right_paren = ')';
 semicolon = ';';
 comma = ',';
 dot = '.';
 and = '&&';
 or = '||';

 if = 'if';
 then = 'then';
 else = 'else';
 lambda = 'lambda';
 let = 'let';
 in = 'in';
 rec = 'rec';
 while = 'while';
 do = 'do';
 fst = 'fst';
 snd = 'snd';
 projection = '#' digit+ '_' digit+;
 ref = 'ref';
 deref = '!';
 assign = ':=';

 unit = '()';
 true = 'true';
 false = 'false';
 number = digit+;
 
 identifier = letter (digit | letter)*;


Ignored Tokens
 blank;


/*
  Hinweise:
  ---------
  
  1. open_expression, closed_expression wird benötigt um Dangling-Else-Problem zu lösen,
     siehe: http://www.parsifalsoft.com/ifelse.html

 */
 
Productions
 expression =
  {open_expression} [e]:open_expression {-> e.expression} |
  {closed_expression} [e]:closed_expression {-> e.expression};
 
 open_expression {-> expression} =
  {condition1} if [e0]:expression then [e1]:expression {-> New expression.condition1(e0.expression, e1.expression)} |
  {condition} if [e0]:expression then [e1]:closed_expression else [e2]:open_expression {-> New expression.condition(e0.expression, e1.expression, e2.expression)} |
  {while} while [e1]:expression do [e2]:open_expression {-> New expression.while(e1.expression, e2.expression)};

 closed_expression {-> expression} =
  {simple} [e]:simple_expression {-> e.expression} |
  {condition} if [e0]:expression then [e1]:closed_expression else [e2]:closed_expression {-> New expression.condition(e0.expression, e1.expression, e2.expression)} |
  {while} while [e1]:expression do [e2]:closed_expression {-> New expression.while(e1.expression, e2.expression)};
  
 simple_expression {-> expression} = 
  {conjunction} conjunction {-> conjunction.expression} |
  {let} let [idlist]:identifier+ equal [e1]:expression in [e2]:closed_expression {-> New expression.let([idlist], e1, e2.expression)} |
  {letrec} let rec [idlist]:identifier+ equal [e1]:expression in [e2]:closed_expression {-> New expression.letrec([idlist], e1, e2.expression)} |
  {lambda} lambda identifier dot [e]:closed_expression {-> New expression.lambda(identifier, e.expression)} |
  {multi_lambda} lambda left_paren [l]:id_list right_paren dot [e]:closed_expression {-> New expression.multi_lambda([l.identifier], e.expression)} |
  {recursion} rec identifier dot [e]:closed_expression {-> New expression.recursion(identifier, e.expression)};
  
 id_list {-> identifier*} =
  {list} [l]:id_list comma [id]:identifier {-> [l.identifier, id]} |
  {single} [id]:identifier {-> [id]};
  
 conjunction {-> expression} =
  {assignment} assignment {-> assignment.expression} |
  {sequence} [e1]:conjunction semicolon [e2]:assignment {-> New expression.sequence(e1.expression, e2.expression)} |
  {or} [e1]:conjunction or [e2]:assignment {-> New expression.or(e1.expression, e2.expression)} |
  {and} [e1]:conjunction and [e2]:assignment {-> New expression.and(e1.expression, e2.expression)};

 assignment {-> expression} =
  {comparison} comparison {-> comparison.expression} |
  {assign} assignment assign comparison {-> New expression.infix(assignment.expression, New expression.assign(assign), comparison.expression)};

 comparison {-> expression} =
  {term} term {-> term.expression} |
  {lower_than} comparison lower_than term {-> New expression.infix(comparison.expression, New expression.lower_than(lower_than), term.expression)} |
  {greater_than} comparison greater_than term {-> New expression.infix(comparison.expression, New expression.greater_than(greater_than), term.expression)} |
  {lower_equal} comparison lower_equal term {-> New expression.infix(comparison.expression, New expression.lower_equal(lower_equal), term.expression)} |
  {greater_equal} comparison greater_equal term {-> New expression.infix(comparison.expression, New expression.greater_equal(greater_equal), term.expression)} |
  {equal} comparison equal term {-> New expression.infix(comparison.expression, New expression.equal(equal), term.expression)};

 term {-> expression} =
  {factor} factor {-> factor.expression} |
  {addition} term plus factor {-> New expression.infix(term.expression, New expression.plus(plus), factor.expression)} |
  {substraction} term minus factor {-> New expression.infix(term.expression, New expression.minus(minus), factor.expression)};

 factor {-> expression} =
  {application} application {-> application.expression} |
  {multiplication} factor multiply application {-> New expression.infix(factor.expression, New expression.multiply(multiply), application.expression)} |
  {division} factor divide application {-> New expression.infix(factor.expression, New expression.divide(divide), application.expression)} |
  {modulation} factor modulo application {-> New expression.infix(factor.expression, New expression.modulo(modulo), application.expression)};

 application {-> expression} =
  {atom} atom {-> atom.expression} |
  {application} application atom {-> New expression.application(application.expression, atom.expression)};

 atom {-> expression} =
  {constant} constant {-> constant.expression} |
  {identifier} identifier {-> New expression.identifier(identifier)} |
  {expression} left_paren [e]:expression right_paren {-> e} |
  {tuple} left_paren [l]:tuple_list comma [e]:expression right_paren {-> New expression.tuple([l.expression, e])};

 tuple_list {-> expression*} =
  {list} [l]:tuple_list comma [e]:expression {-> [l.expression, e]} |
  {single} [e]:expression {-> [e]};

 constant {-> expression} =
  {unit} unit {-> New expression.unit(unit)} |
  {bool} bool {-> bool.expression} |
  {number} number {-> New expression.number(number)} |
  {operator} left_paren operator right_paren {-> operator.expression} |
  {projection} projection {-> New expression.projection(projection)} |
  {uminus} uminus {-> New expression.uminus(uminus)} |
  {not} not {-> New expression.not(not)} |
  {fst} fst {-> New expression.fst(fst)} |
  {snd} snd {-> New expression.snd(snd)} |
  {ref} ref {-> New expression.ref(ref)} |
  {deref} deref {-> New expression.deref(deref)};

 bool {-> expression} =
  {true} true {-> New expression.true(true)} |
  {false} false {-> New expression.false(false)};

 operator {-> expression} =
  {plus} plus {-> New expression.plus(plus)} |
  {minus} minus {-> New expression.minus(minus)} |
  {multiply} multiply {-> New expression.multiply(multiply)} |
  {divide} divide {-> New expression.divide(divide)} |
  {modulo} modulo {-> New expression.modulo(modulo)} |
  {lower_than} lower_than {-> New expression.lower_than(lower_than)} |
  {greater_than} greater_than {-> New expression.greater_than(greater_than)} |
  {lower_equal} lower_equal {-> New expression.lower_equal(lower_equal)} |
  {greater_equal} greater_equal {-> New expression.greater_equal(greater_equal)} |
  {equal} equal {-> New expression.equal(equal)} |
  {assign} assign {-> New expression.assign(assign)};


Abstract Syntax Tree
 expression =
  {application} [e0]:expression [e1]:expression |
  {condition} [e0]:expression [e1]:expression [e2]:expression |
  {condition1} [e0]:expression [e1]:expression |
  {let} [idlist]:identifier+ [e1]:expression [e2]:expression |
  {letrec} [idlist]:identifier+ [e1]:expression [e2]:expression |
  {lambda} [id]:identifier [e]:expression |
  {multi_lambda} [idlist]:identifier+ [e]:expression |
  {recursion} [id]:identifier [e]:expression |
  {infix} [e1]:expression [op]:expression [e2]:expression |
  {and} [e0]:expression [e1]:expression |
  {or} [e0]:expression [e1]:expression |
  {tuple} [expressions]:expression+ |
  {sequence} [e1]:expression [e2]:expression |
  {while} [e1]:expression [e2]:expression |
  {identifier} identifier |
  {unit} unit |
  {true} true |
  {false} false |
  {number} number |
  {plus} plus |
  {minus} minus |
  {multiply} multiply |
  {divide} divide |
  {modulo} modulo |
  {lower_than} lower_than |
  {greater_than} greater_than |
  {lower_equal} lower_equal |
  {greater_equal} greater_equal |
  {equal} equal |
  {uminus} uminus |
  {not} not |
  {projection} projection |
  {fst} fst |
  {snd} snd |
  {ref} ref |
  {deref} deref |
  {assign} assign;

