package de.unisiegen.tpml.core.languages;

import java.io.IOException;

import de.unisiegen.tpml.core.prettyprinter.PrettyStyle;


/**
 * Abstract base class for classes that implement the {@link de.unisiegen.tpml.core.languages.LanguageScanner}
 * interface.
 *
 * @author Benedikt Meurer
 * @version $Rev$
 * 
 * @see de.unisiegen.tpml.core.languages.LanguageScanner
 */
public abstract class AbstractLanguageScanner implements LanguageScanner {
  //
  // Constructor (protected)
  //
  
  /**
   * Allocates a new <code>AbstractLanguageScanner</code>, which implements the <code>LanguageScanner</code>
   * interface and should be used as base class for all scanners generated by JFlex.
   */
  protected AbstractLanguageScanner() {
    // nothing to do here...
  }
  
  
  
  //
  // Symbol allocation (protected)
  //
  
  /**
   * Allocates a new {@link LanguageSymbol} with the specified <code>name</code> and symbol <code>id</code>.
   * The remaining parameters are optional, see the documentation of the {@link LanguageSymbol} and
   * {@link LanguageSymbolFactory} classes for details.
   * 
   * @param name the name of the symbol.
   * @param id the unique identifier of the symbol.
   * @param left the left position of the symbol, or <code>-1</code>.
   * @param right the right position of the symbol, or <code>-1</code>.
   * @param value the value of the symbol.
   * 
   * @return the generated {@link LanguageSymbol}.
   */
  protected final LanguageSymbol symbol(String name, int id, int left, int right, Object value) {
    return new LanguageSymbol(name, id, left, right, value);
  }
  
  
  
  //
  // Style management
  //

  /**
   * {@inheritDoc}
   *
   * @see languages.LanguageScanner#getStyleBySymbol(languages.LanguageSymbol)
   */
  public final PrettyStyle getStyleBySymbol(LanguageSymbol symbol) {
    return getStyleBySymbolId(symbol.getId());
  }
  
  /**
   * Returns the {@link PrettyStyle} for the specified symbol <code>id</code>, for example {@link PrettyStyle#KEYWORD}
   * if the <code>id</code> refers to the token <code>"let"</code>.
   * 
   * This method must be implemented by all lexers generated by JFlex.
   * 
   * @param id the unique identifier of a symbol.
   * 
   * @return the {@link PrettyStyle} for the symbol <code>id</code>.
   * 
   * @see #getStyleBySymbol(LanguageSymbol)
   */
  protected abstract PrettyStyle getStyleBySymbolId(int id);
  
  
  
  //
  // Primitives
  //
  
  /**
   * Implementation of the <code>next_token()</code> interface of the {@link java_cup.runtime.Scanner} interface.
   * 
   * This is a simple wrapper around the <code>nextSymbol()</code> method, which automatically skips all symbols
   * that should be ignored by the parser.
   * 
   * @return the next symbol from the scanner, skipping all tokens that should be ignored by the parser, or
   *         <code>null</code> on end-of-file.
   *
   * @see java_cup.runtime.Scanner#next_token()
   * 
   * @throws IOException if an error occurs while reading characters from the input source stream.
   * @throws LanguageScannerException if a syntax error occurred while trying to scan the input stream.
   */
  public final LanguageSymbol next_token() throws IOException, LanguageScannerException {
    for (;;) {
      // return the next symbol, skipping comments
      LanguageSymbol symbol = nextSymbol();
      if (symbol != null && getStyleBySymbol(symbol) == PrettyStyle.COMMENT)
        continue;
      return symbol;
    }
  }
}
