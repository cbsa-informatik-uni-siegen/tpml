import de.unisiegen.tpml.core.expressions.*;
import de.unisiegen.tpml.core.types.*;


/* Binary operators */
terminal			PLUS, MINUS, STAR, SLASH, MOD;
terminal			EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;

/* Tuple operators */
terminal			FST, SND;

/* Syntactic tokens */
terminal			ARROW, COLON, COMMA, DOT;
terminal			SEMI, BELOW_SEMI;
terminal			LPAREN, RPAREN;
terminal			PARENPAREN;
terminal			COLONEQUAL, EXCLAMATION;

/* Keywords */
terminal			LAMBDA, LET, REC, REF, IN, IF, THEN, ELSE, WHILE, DO;
terminal			TRUE, FALSE;

/* Types */
terminal			BOOL, INT, UNIT;

/* Special tokens */
terminal Integer	NUMBER;
terminal String		IDENTIFIER;
terminal Integer[]	PROJECTION;
terminal			COMMENT;


/* Non-Terminals */
non terminal Expression		seq_expr;
non terminal Expression		expr;
non terminal Expression		simple_expr;
non terminal Expression[]	simple_expr_list;
non terminal Expression		constant;
non terminal Expression		operator;
non terminal Expression[]	expr_comma_list;	/* list of expressions separated by comma */
non terminal String[]		id_list;			/* list of identifiers without any separator */
non terminal String[]		id_comma_list;		/* list of identifiers separated by comma */
non terminal MonoType		type;
non terminal MonoType		simple_type;
non terminal MonoType[]		type_star_list;		/* list of types separated by star */


/* Precedences, based on http://caml.inria.fr/pub/docs/manual-ocaml/manual015.html */
precedence nonassoc	IN;
precedence nonassoc	BELOW_SEMI;
precedence nonassoc	SEMI;				/* below EQUAL ({lbl = ...; lbl = ...}) */
precedence nonassoc LET, REC;			/* above SEMI (...; let ... in ...) */
precedence nonassoc DO;					/* below THEN (while ... do ...) */
precedence nonassoc THEN;				/* below ELSE (if ... then ...) */
precedence nonassoc ELSE;				/* (if ... then ... else ...) */

precedence right	COLONEQUAL;			/* expr (e := e := e) */

precedence right	ARROW;

precedence left		EQUAL, LESS, GREATER, LESSEQUAL, GREATEREQUAL;
precedence left		PLUS, MINUS;
precedence left		STAR, SLASH, MOD;



/***************
 * Expressions *
 ***************/


seq_expr			::= expr:e
						{: RESULT = e; :}
						%prec BELOW_SEMI
					|	expr:e1 SEMI seq_expr:e2
						{: RESULT = new Sequence(e1, e2); :}
					;
					
					
expr				::=	simple_expr:e
						{: RESULT = e; :}
				
					/* Applications */
					|	simple_expr:e simple_expr_list:l
						{: for (int n = 0; n < l.length; ++n) {
						     e = new Application(e, l[n]);
						   }
						   RESULT = e; :}

					/* Infix Operations */
					|	expr:e1 COLONEQUAL expr:e2
						{: RESULT = new InfixOperation(Assign.ASSIGN, e1, e2); :}

					|	expr:e1 PLUS expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.PLUS, e1, e2); :}
					|	expr:e1 MINUS expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.MINUS, e1, e2); :}
					|	expr:e1 STAR expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.MULT, e1, e2); :}
					|	expr:e1 SLASH expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.DIV, e1, e2); :}
					|	expr:e1 MOD expr:e2
						{: RESULT = new InfixOperation(ArithmeticOperator.MOD, e1, e2); :}

					|	expr:e1 EQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.EQUALS, e1, e2); :}
					|	expr:e1 LESS expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.LOWER_THAN, e1, e2); :}
					|	expr:e1 GREATER expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.GREATER_THAN, e1, e2); :}
					|	expr:e1 LESSEQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.LOWER_EQUAL, e1, e2); :}
					|	expr:e1 GREATEREQUAL expr:e2
						{: RESULT = new InfixOperation(RelationalOperator.GREATER_EQUAL, e1, e2); :}

					/* Conditions */
					|	IF seq_expr:e0 THEN seq_expr:e1 ELSE seq_expr:e2
						{: RESULT = new Condition(e0, e1, e2); :}
					|	IF seq_expr:e0 THEN seq_expr:e1
						{: RESULT = new Condition1(e0, e1); :}

					/* Lambda Abstraction */
					|	LAMBDA IDENTIFIER:id DOT seq_expr:e
						{: RESULT = new Lambda(id, null, e); :}
					|	LAMBDA IDENTIFIER:id COLON type:tau DOT seq_expr:e
						{: RESULT = new Lambda(id, tau, e); :}
					|	LAMBDA LPAREN id_comma_list:il RPAREN DOT seq_expr:e
						{: RESULT = new MultiLambda(il, null, e); :}
					|	LAMBDA LPAREN id_comma_list:il RPAREN COLON type:tau DOT seq_expr:e
						{: RESULT = new MultiLambda(il, tau, e); :}

					/* Let */
					|	LET IDENTIFIER:id EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new Let(id, e1, e2); :}
					|	LET IDENTIFIER:id id_list:il EQUAL seq_expr:e1 IN seq_expr:e2
						{: String[] identifiers = new String[il.length + 1];
						   identifiers[0] = id;
						   System.arraycopy(il, 0, identifiers, 1, il.length);
						   RESULT = new CurriedLet(identifiers, e1, e2); :}
					|	LET LPAREN id_comma_list:il RPAREN EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new MultiLet(il, null, e1, e2); :}
					|	LET LPAREN id_comma_list:il RPAREN COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new MultiLet(il, tau, e1, e2); :}

					/* Recursion */				
					|	REC IDENTIFIER:id DOT seq_expr:e
						{: RESULT = new Recursion(id, null, e); :}
					|	REC IDENTIFIER:id COLON type:tau DOT seq_expr:e
						{: RESULT = new Recursion(id, tau, e); :}
					|	LET REC IDENTIFIER:id EQUAL expr:e1 IN expr:e2
						{: RESULT = new LetRec(id, null, e1, e2); :}
					|	LET REC IDENTIFIER:id COLON type:tau EQUAL seq_expr:e1 IN seq_expr:e2
						{: RESULT = new LetRec(id, tau, e1, e2); :}
					|	LET REC IDENTIFIER:id id_list:il EQUAL seq_expr:e1 IN seq_expr:e2
						{: String[] identifiers = new String[il.length + 1];
						   identifiers[0] = id;
						   System.arraycopy(il, 0, identifiers, 1, il.length);
						   RESULT = new CurriedLetRec(identifiers, e1, e2); :}
						   
					/* Loops */
					|	WHILE seq_expr:e1 DO seq_expr:e2
						{: RESULT = new While(e1, e2); :}
					;


simple_expr			::=	constant:c
						{: RESULT = c; :}
					|	IDENTIFIER:id
						{: RESULT = new Identifier(id); :}

					/* Parenthized operators/expressions */
					|	LPAREN operator:o RPAREN
						{: RESULT = o; :}
					|	LPAREN seq_expr:e RPAREN
						{: RESULT = e; :}

					/* Tuples */
					|	LPAREN expr_comma_list:el RPAREN
						{: RESULT = new Tuple(el); :}
					;


/* for applications */
simple_expr_list	::=	simple_expr:e
						{: RESULT = new Expression[] { e }; :}
					|	simple_expr_list:l simple_expr:e
						{: RESULT = new Expression[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = e; :}
					;


constant			::=	PARENPAREN		{: RESULT = UnitConstant.UNIT; :}
					|	TRUE			{: RESULT = BooleanConstant.TRUE; :}
					|	FALSE			{: RESULT = BooleanConstant.FALSE; :}
					|	NUMBER:n		{: RESULT = new IntegerConstant(n.intValue()); :}
					
					/* Reference operators */
					|	EXCLAMATION		{: RESULT = Deref.DEREF; :}
					|	REF				{: RESULT = Ref.REF; :}

					/* Tuple operators */
					|	PROJECTION:proj	{: RESULT = new Projection(proj[0], proj[1]); :}
					|	FST				{: RESULT = Fst.FST; :}
					|	SND				{: RESULT = Snd.SND; :}
					;


operator			::=	PLUS			{: RESULT = ArithmeticOperator.PLUS; :}
					|	MINUS			{: RESULT = ArithmeticOperator.MINUS; :}
					|	STAR			{: RESULT = ArithmeticOperator.MULT; :}
					|	SLASH			{: RESULT = ArithmeticOperator.DIV; :}
					|	MOD				{: RESULT = ArithmeticOperator.MOD; :}
					|	EQUAL			{: RESULT = RelationalOperator.EQUALS; :}
					|	LESS			{: RESULT = RelationalOperator.LOWER_THAN; :}
					|	GREATER			{: RESULT = RelationalOperator.GREATER_THAN; :}
					|	LESSEQUAL		{: RESULT = RelationalOperator.LOWER_EQUAL; :}
					|	GREATEREQUAL	{: RESULT = RelationalOperator.GREATER_EQUAL; :}
					
					/* Reference operators */
					|	COLONEQUAL		{: RESULT = Assign.ASSIGN; :}
					;


expr_comma_list		::=	expr_comma_list:el COMMA seq_expr:e
						{: RESULT = new Expression[el.length + 1];
						   System.arraycopy(el, 0, RESULT, 0, el.length);
						   RESULT[el.length] = e; :}
					|	seq_expr:e1 COMMA seq_expr:e2
						{: RESULT = new Expression[] { e1, e2 }; :}
					;
				
				
id_list				::=	id_list:l IDENTIFIER:id
						{: RESULT = new String[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = id; :}
					|	IDENTIFIER:id
						{: RESULT = new String[] { id }; :}
					;

					
id_comma_list		::=	id_comma_list:l COMMA IDENTIFIER:id
						{: RESULT = new String[l.length + 1];
						   System.arraycopy(l, 0, RESULT, 0, l.length);
						   RESULT[l.length] = id; :}
					|	IDENTIFIER:id
						{: RESULT = new String[] { id }; :}
					;

					
					
/*********
 * Types *
 *********/


type				::=	simple_type:t			{: RESULT = t; :}
					|	type:tau REF			{: RESULT = new RefType(tau); :}
					|	type:t1 ARROW type:t2	{: RESULT = new ArrowType(t1, t2); :}
					|	type_star_list:tl
						{: RESULT = new TupleType(tl); :}
					;


simple_type			::=	LPAREN type:t RPAREN	{: RESULT = t; :}
					|	BOOL					{: RESULT = BooleanType.BOOL; :}
					|	INT						{: RESULT = IntegerType.INT; :}
					|	UNIT					{: RESULT = UnitType.UNIT; :}
					;


type_star_list		::= type_star_list:tl STAR type:t
						{: RESULT = new MonoType[tl.length + 1];
						   System.arraycopy(tl, 0, RESULT, 0, tl.length);
						   RESULT[tl.length] = t; :}
					|	type:t1 STAR type:t2
						{: RESULT = new MonoType[] { t1, t2 }; :}
					;
					